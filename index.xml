<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss
    xmlns:yandex="http://news.yandex.ru"
    xmlns:media="http://search.yahoo.com/mrss/"
    xmlns:turbo="http://turbo.yandex.ru"
    version="2.0">
  <channel>
    <title>Фокусов Игорь</title>
    <link>https://fokusov.com/</link>
    <description>on Фокусов Игорь. Блог.</description>
    <language>ru</language>
    
    <item turbo="true">
      <turbo:topic>Разработка приложения-галереи под Android на Kotlin</turbo:topic>
      <link>https://fokusov.com/posts/razrabotka-prilozhenija-galerei-pod-android-na-kotlin/</link>
      <pubDate>Sun, 04 Mar 2018 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ 

<p><img src="img/x70d0e8.png.pagespeed.ic.8gLWffyQWF.jpg" alt="Разработка: Разработка приложения-галереи под Android на Kotlin" /></p>

<p>В этом уроке мы разработаем полноценное <a href="https://play.google.com/store/apps/details?id=com.titleapps.canalpic&amp;hl=en">приложение — галерею изображений</a> на Kotlin. Также мы рассмотрим следующие темы:</p>

<ul>
<li>Реализация паттерна Singleton на Kotlin.</li>
<li>Передача экземпляра класса из одной activity в другую с помощью Parcelable на Kotlin</li>
<li>Пример реализации Shared preferences.</li>
<li>Пример Recyclerview на Kotlin.</li>
<li>Настройка RecyclerView Adapter на Kotlin.</li>
<li>NavigationView и настройка DrawerLayout на Kotlin.</li>
<li>Загрузка и вывод изображений с внутреннего накопителя Android на Kotlin.</li>
<li>Использование библиотеки для загрузки изображений Glide.</li>
<li>Работа с разрешениями в режиме выполнения в Android.
<br /></li>
</ul>

<p>Если вы ещё новичок и только планируете освоить Kotlin, рекомендую вначале ознакомиться со следующими материалами:</p>

<ol>
<li><a href="http://developine.com/kotlin-idioms-introductory-tutorial-part-1/">Идиомы Kotlin (англ.)</a></li>
<li><a href="http://developine.com/classes-objects-modifiers-and-interfaces-in-kotlin-tutorial/">Классы, объекты, модификаторы и интерфейсы в Kotlin (англ.)</a>
<br />
<br /></li>
</ol>

<p>Таким образом, разработав это приложение, вы неплохо освоите Kotlin.</p>

<h3 id="итак-приступим">Итак, приступим.</h3>

<p>Создадим новый проект в Android Studio и включим галочку &ldquo;Add support for Kotlin&rdquo; при его создании.</p>

<h3 id="добавим-необходимые-разрешения-в-манифест">Добавим необходимые разрешения в манифест.</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;uses-permission android:name=&#34;android.permission.READ_EXTERNAL_STORAGE&#34; /&gt;    </pre></div>
<h3 id="создадим-data-class-albums-и-реализуем-интерфейс-parcelable">Создадим Data Class &ldquo;Albums&rdquo; и реализуем интерфейс Parcelable.</h3>

<p>Вот наш класс модели, хранящий информацию о папках изображений (например, Whatsapp Images, Camera), пути до последних изображений в папке, общем количестве изображений в каждой папке.</p>

<p>И так как мы планируем передать эту информацию с окна запуска приложения в MainActivity с помощью Intent, мы должны реализовать интерфейс Parcelable в классе &ldquo;Albums&rdquo;:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">data class Albums(var folderNames: String, var imagePath: String, var imgCount: Int, var isVideo: Boolean) : Parcelable {
    constructor(parcel: Parcel) : this(
            parcel.readString(),
            parcel.readString(),
            parcel.readInt(),
            parcel.readByte() != 0.toByte()) {
    }

    override fun writeToParcel(parcel: Parcel, flags: Int) {
        parcel.writeString(folderNames)
        parcel.writeString(imagePath)
        parcel.writeInt(imgCount)
        parcel.writeByte(if (isVideo) 1 else 0)
    }

    override fun describeContents(): Int {
        return 0
    }

    companion object CREATOR : Parcelable.Creator {
        override fun createFromParcel(parcel: Parcel): Albums {
            return Albums(parcel)
        }

        override fun newArray(size: Int): Array {
            return arrayOfNulls(size)
        }
    }
}</pre></div>
<h3 id="добавим-splash-activity">Добавим Splash Activity</h3>

<p>В методе onCreate нашей Splash Activity нам сперва необходимо получить доступ к внешнему накопителю. Для этого мы должны запросить у пользователя разрешение на доступ к изображениям на устройстве.</p>

<p>После того, как пользователь даст разрешение read_external_storage, мы сможем загрузить изображения и передать имя изображения, его путь и количество изображений в папках в нашу Main Activity для вывода изображений в Recyclerview.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// SplashActivity.kt

internal var SPLASH_TIME_OUT = 800

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    setContentView(R.layout.activity_splash)

    Handler().postDelayed(
            {
                 // проверка того, что пользователь дал разрешение на доступ к накопителю.
                 // в противном случае запросим такое разрешение.
                if (!checkSelfPermission()) {
                    requestPermission()
                } else {
                   // если разрешение получено, загрузим изображения.
                   // исходный код этого метода будет описан ниже.
                    loadAllImages()
                }
            }, SPLASH_TIME_OUT.toLong())
}</pre></div>
<h3 id="добавим-код-перехватывающий-выдачу-разрешения">Добавим код, перехватывающий выдачу разрешения.</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">private fun requestPermission() {
    ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE), 6036)
}

private fun checkSelfPermission(): Boolean {

    if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
        return false
    } else
        return true
}</pre></div>
<p>Когда пользователь даст разрешение или откажет в нём, выполнится следующий код:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">override fun onRequestPermissionsResult(requestCode: Int, permissions: Array, grantResults: IntArray) {
    when (requestCode) {
        6036 -&gt; {
            if (grantResults.size &gt; 0) {
                var permissionGranted = grantResults[0] == PackageManager.PERMISSION_GRANTED
                if (permissionGranted) {

    // Теперь мы готовы к чтению внешнего хранилища и имеющихся там изображений.

                    loadAllImages()
                } else {
                    Toast.makeText(this, &#34;Permission Denied! Cannot load images.&#34;, Toast.LENGTH_SHORT).show()
                }
            }
        }
    }
    super.onRequestPermissionsResult(requestCode, permissions, grantResults)
}</pre></div>
<p>Если разрешение получено, мы передадим загруженные изображения в MainActivity.kt</p>

<h3 id="передаём-экземпляр-класса-данных-класса-модели-в-intent-е-как-parcelable">Передаём экземпляр класса данных (класса модели) в intent-е как Parcelable.</h3>

<p>Эта функция вызовет другой метод getAllShownImagesPath(context), которая вернёт List типа Albums.</p>

<p>Передадим полученный список Albums в MainActivity с помощью Intent.</p>

<p>MainActivity выведет список всех папок с изображениями и видео (типа Camera, Instagram, Whatsapp Images) в RecyclerView.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">fun loadAllImages() {
    var imagesList = getAllShownImagesPath(this)
    var intent = Intent(this, MainActivity::class.java)
    intent.putParcelableArrayListExtra(&#34;image_url_data&#34;, imagesList)
    startActivity(intent)
    finish()
}</pre></div>
<blockquote>
<p>В этом куске кода у нас есть экземпляр Data Class и нам необходимо передать эти данные в другую activity, поэтому мы передаём сериализованные данные.</p>
</blockquote>

<h3 id="загрузка-изображений-из-внутреннего-хранилища">Загрузка изображений из внутреннего хранилища.</h3>

<p>Здесь мы рассмотрим чтение всех папок с изображениями и видео с помощью класса MediaStore. И вернём ArrayList.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">private fun getAllShownImagesPath(activity: Activity): ArrayList {

    val uri: Uri
    val cursor: Cursor
    var cursorBucket: Cursor
    val column_index_data: Int
    val column_index_folder_name: Int
    val listOfAllImages = ArrayList()
    var absolutePathOfImage: String? = null
    var albumsList = ArrayList()
    var album: Albums? = null


    val BUCKET_GROUP_BY = &#34;1) GROUP BY 1,(2&#34;
    val BUCKET_ORDER_BY = &#34;MAX(datetaken) DESC&#34;

    uri = android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI

    val projection = arrayOf(MediaStore.Images.ImageColumns.BUCKET_ID,
            MediaStore.Images.ImageColumns.BUCKET_DISPLAY_NAME,
            MediaStore.Images.ImageColumns.DATE_TAKEN,
            MediaStore.Images.ImageColumns.DATA)

    cursor = activity.contentResolver.query(uri, projection, BUCKET_GROUP_BY, null, BUCKET_ORDER_BY)

    if (cursor != null) {
        column_index_data = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA)
        column_index_folder_name = cursor
                .getColumnIndexOrThrow(MediaStore.Images.Media.BUCKET_DISPLAY_NAME)
        while (cursor.moveToNext()) {
            absolutePathOfImage = cursor.getString(column_index_data)
            Log.d(&#34;title_apps&#34;, &#34;bucket name:&#34; + cursor.getString(column_index_data))

            val selectionArgs = arrayOf(&#34;%&#34; + cursor.getString(column_index_folder_name) + &#34;%&#34;)
            val selection = MediaStore.Images.Media.DATA + &#34; like ? &#34;
            val projectionOnlyBucket = arrayOf(MediaStore.MediaColumns.DATA, MediaStore.Images.Media.BUCKET_DISPLAY_NAME)

            cursorBucket = activity.contentResolver.query(uri, projectionOnlyBucket, selection, selectionArgs, null)
            Log.d(&#34;title_apps&#34;, &#34;bucket size:&#34; + cursorBucket.count)

            if (absolutePathOfImage != &#34;&#34; &amp;&amp; absolutePathOfImage != null) {
                listOfAllImages.add(absolutePathOfImage)
                albumsList.add(Albums(cursor.getString(column_index_folder_name), absolutePathOfImage, cursorBucket.count, false))
            }
        }
    }
    return getListOfVideoFolders(albumsList)
}

// Эта функция отвечает за чтение всех видео из всех папок.
private fun getListOfVideoFolders(albumsList: ArrayList): ArrayList {

    var cursor: Cursor
    var cursorBucket: Cursor
    var uri: Uri
    val BUCKET_GROUP_BY = &#34;1) GROUP BY 1,(2&#34;
    val BUCKET_ORDER_BY = &#34;MAX(datetaken) DESC&#34;
    val column_index_album_name: Int
    val column_index_album_video: Int

    uri = android.provider.MediaStore.Video.Media.EXTERNAL_CONTENT_URI

    val projection1 = arrayOf(MediaStore.Video.VideoColumns.BUCKET_ID,
            MediaStore.Video.VideoColumns.BUCKET_DISPLAY_NAME,
            MediaStore.Video.VideoColumns.DATE_TAKEN,
            MediaStore.Video.VideoColumns.DATA)

    cursor = this.contentResolver.query(uri, projection1, BUCKET_GROUP_BY, null, BUCKET_ORDER_BY)

    if (cursor != null) {
        column_index_album_name = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.BUCKET_DISPLAY_NAME)
        column_index_album_video = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DATA)
        while (cursor.moveToNext()) {
            Log.d(&#34;title_apps&#34;, &#34;bucket video:&#34; + cursor.getString(column_index_album_name))
            Log.d(&#34;title_apps&#34;, &#34;bucket video:&#34; + cursor.getString(column_index_album_video))
            val selectionArgs = arrayOf(&#34;%&#34; + cursor.getString(column_index_album_name) + &#34;%&#34;)

            val selection = MediaStore.Video.Media.DATA + &#34; like ? &#34;
            val projectionOnlyBucket = arrayOf(MediaStore.MediaColumns.DATA, MediaStore.Video.Media.BUCKET_DISPLAY_NAME)

            cursorBucket = this.contentResolver.query(uri, projectionOnlyBucket, selection, selectionArgs, null)
            Log.d(&#34;title_apps&#34;, &#34;bucket size:&#34; + cursorBucket.count)

            albumsList.add(Albums(cursor.getString(column_index_album_name), cursor.getString(column_index_album_video), cursorBucket.count, true))
        }
    }
    return albumsList
}</pre></div>
<h3 id="итак-что-мы-уже-сделали">Итак, что мы уже сделали</h3>

<ol>
<li>Запрос разрешения на чтение изображений в режиме выполнения.</li>
<li>С помощью MediaStore и Cursor реализовали загрузку путей до изображений из внутренней памяти.</li>
<li>Научились передавать экземпляр сериализованного класса данных (Serialized Data Class) из одной Activity в другую на Kotlin.</li>
<li>Поняли как использовать Data Class в Kotlin (Albums.kt).
<br /></li>
</ol>

<p>Теперь создадим другую activity и назовём её MainActivity.kt. В ней мы сделаем следующее:</p>

<ol>
<li>Мы получим объект Albums, отправленный из Splash Activity.</li>
<li>Напишем код слушателя нажатия на элемент RecyclerView.</li>
<li>Создадим файл макета (разметки) и адаптер RecyclerView для вывода всех папок.
<br /></li>
</ol>

<h3 id="разметка-для-mainactivity">Разметка для MainActivity</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">//файл activity_main.xml

&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;RelativeLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
    xmlns:app=&#34;http://schemas.android.com/apk/res-auto&#34;
    android:layout_width=&#34;match_parent&#34;
    android:layout_height=&#34;match_parent&#34;
    android:fitsSystemWindows=&#34;true&#34;&gt;

    &lt;android.support.v7.widget.Toolbar
        android:id=&#34;@+id/my_toolbar&#34;
        android:layout_width=&#34;match_parent&#34;
        android:layout_height=&#34;?attr/actionBarSize&#34;
        android:background=&#34;?attr/colorPrimary&#34;
        android:elevation=&#34;4dp&#34;
        app:titleTextColor=&#34;@color/colorIcons&#34; /&gt;
    
    &lt;android.support.v4.widget.DrawerLayout
        android:id=&#34;@+id/drawer_layout&#34;
        android:layout_width=&#34;match_parent&#34;
        android:layout_height=&#34;match_parent&#34;
        android:layout_below=&#34;@+id/my_toolbar&#34;
        android:fitsSystemWindows=&#34;true&#34;&gt;

        &lt;!-- Ваш контент --&gt;
        &lt;include layout=&#34;@layout/include_main_content&#34;&gt;&lt;/include&gt;

        &lt;android.support.design.widget.NavigationView
            android:id=&#34;@+id/navigation&#34;
            android:layout_width=&#34;wrap_content&#34;
            android:layout_height=&#34;match_parent&#34;
            android:layout_gravity=&#34;start&#34;
            android:onClick=&#34;toast&#34;
            app:menu=&#34;@menu/my_navigation_menu&#34;
            app:theme=&#34;@style/NavigationDrawerStyle&#34; /&gt;
    &lt;/android.support.v4.widget.DrawerLayout&gt;
&lt;/RelativeLayout&gt;</pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">//include_main_content.xml 

&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
    xmlns:app=&#34;http://schemas.android.com/apk/res-auto&#34;
    android:id=&#34;@+id/main_content&#34;
    android:layout_width=&#34;match_parent&#34;
    android:layout_height=&#34;match_parent&#34;&gt;


    &lt;android.support.v7.widget.RecyclerView
        android:id=&#34;@+id/rvAlbums&#34;
        android:layout_width=&#34;match_parent&#34;
        android:layout_height=&#34;match_parent&#34;
        android:clipToPadding=&#34;false&#34; /&gt;

    &lt;android.support.design.widget.FloatingActionButton
        android:id=&#34;@+id/fab_camera&#34;
        android:layout_width=&#34;wrap_content&#34;
        android:layout_height=&#34;wrap_content&#34;
        android:layout_gravity=&#34;bottom|right&#34;
        android:layout_margin=&#34;16dp&#34;
        android:src=&#34;@drawable/ic_photo_camera_white_24dp&#34;
        app:layout_anchor=&#34;@id/rvAlbums&#34;
        app:layout_anchorGravity=&#34;bottom|right|end&#34;
        app:layout_behavior=&#34;com.title_apps.canalpic.util.ScrollAwareFABBehavior&#34; /&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;

    </pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">    //MainActivity.kt
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    
        savedState = savedInstanceState
    
        if (savedState != null)
            folder_name = savedInstanceState!!.getString(&#34;folder_name&#34;)
    
        setSupportActionBar(my_toolbar)
        // Включим кнопку &#34;Вверх&#34; (Up button)
        supportActionBar!!.setDisplayHomeAsUpEnabled(true)
        supportActionBar!!.setHomeAsUpIndicator(resources.getDrawable(R.drawable.ic_menu_white_24dp))
    
        setupNavigationView()
    
        var extra = intent.extras;
        if (extra != null) {
            var extraData = extra.get(&#34;image_url_data&#34;) as ArrayList
            select_fragment(extraData)
        }
    
        drawer_layout_listener()
        supportActionBar!!.setTitle(&#34;Folders&#34;)
    }
    </pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">    // в этом методе мы посылаем имя папки, по которой кликнул пользователь. К примеру, если пользователь
    // нажал на папку downloads из общего списка папок нашего приложения, мы передадим это 
    // имя папки следующей activity, которая загрузит и выведет на экран все изображения из этой папки.
    
    override fun onItemClick(position: String, isVideo: Boolean) {
    
        var bundle = Bundle()
        bundle.putString(&#34;folder_name&#34;, position)
            var intent = Intent(this, AlbumActivity::class.java)
            intent.putExtra(&#34;folder_name&#34;, position)
            startActivity(intent)
    }</pre></div>
<h3 id="инициализируем-glide-и-настраиваем-recyclerview-для-вывода-изображений">Инициализируем Glide и настраиваем RecyclerView для вывода изображений.</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">private var folder_name: String = &#34;&#34;

public fun select_fragment(imagesList: ArrayList) {

    val options = RequestOptions()
            .diskCacheStrategy(DiskCacheStrategy.RESOURCE).override(160, 160).skipMemoryCache(true).error(R.drawable.ic_image_unavailable)
    val glide = Glide.with(this)

    val builder = glide.asBitmap()
    rvAlbums?.layoutManager = GridLayoutManager(this, 2)

    rvAlbums?.setHasFixedSize(true)

    // AlbumFoldersAdapter.kt это класс адаптера RecyclerView.
    rvAlbums?.adapter = AlbumFoldersAdapter(imagesList, this, options, builder, glide, this)


    rvAlbums?.addOnScrollListener(object : RecyclerView.OnScrollListener() {
        override fun onScrolled(recyclerView: RecyclerView?, dx: Int, dy: Int) {
            super.onScrolled(recyclerView, dx, dy)
        }

        override fun onScrollStateChanged(recyclerView: RecyclerView?, newState: Int) {
            super.onScrollStateChanged(recyclerView, newState)
            when (newState) {
                RecyclerView.SCROLL_STATE_IDLE -&gt; glide.resumeRequests()
                AbsListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL, AbsListView.OnScrollListener.SCROLL_STATE_FLING -&gt; glide.pauseRequests()
            }
        }
    }
    )

    fab_camera?.setOnClickListener(object : View.OnClickListener {
        override fun onClick(p0: View?) {
            launchCamera()
        }
    }
    )
}</pre></div>
<h3 id="слушатели-для-navigationview-и-drawerlayout">Слушатели для NavigationView и drawerLayout</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// слушатель клика для drawer layout.
private fun drawer_layout_listener() {

    drawer_layout.addDrawerListener(object : DrawerLayout.DrawerListener {
        override fun onDrawerStateChanged(newState: Int) {
        }

        override fun onDrawerSlide(drawerView: View?, slideOffset: Float) {
        }

        override fun onDrawerClosed(drawerView: View?) {
            supportActionBar!!.setHomeAsUpIndicator(resources.getDrawable(R.drawable.ic_menu_white_24dp))
        }

        override fun onDrawerOpened(drawerView: View?) {
            supportActionBar!!.setHomeAsUpIndicator(resources.getDrawable(R.drawable.ic_keyboard_backspace_white_24dp))
        }
    }
    )
}

// слушатель клика для элементов Navigation.
private fun setupNavigationView() {

    navigation.setNavigationItemSelectedListener(object : NavigationView.OnNavigationItemSelectedListener {
        override fun onNavigationItemSelected(item: MenuItem): Boolean {
            drawer_layout.closeDrawer(Gravity.START)
            when (item.itemId) {
                R.id.nav_all_folders -&gt; {
                                 }
                R.id.nav_hidden_folders -&gt; {
                                 }
            }
            return false
        }
    })
}</pre></div>
<p>Добавим код в AlbumsFolderAdapter.kt для RecyclerView</p>

<h3 id="создаём-файлы-разметки-для-адаптера-recyclerview-из-mainactivity">Создаём файлы разметки для адаптера RecyclerView из MainActivity</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// list_layout.xml
// layout file for RecyclerView adapter.

&lt;LinearLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
    xmlns:card_view=&#34;http://schemas.android.com/apk/res-auto&#34;
    android:layout_width=&#34;match_parent&#34;
    android:layout_height=&#34;wrap_content&#34;&gt;

    &lt;android.support.v7.widget.CardView
        android:id=&#34;@+id/card_view&#34;
        android:layout_width=&#34;wrap_content&#34;
        android:layout_height=&#34;wrap_content&#34;
        android:layout_gravity=&#34;center&#34;
        android:layout_margin=&#34;@dimen/five_dp&#34;
        android:elevation=&#34;3dp&#34;
        card_view:cardCornerRadius=&#34;@dimen/zero_dp&#34;&gt;

        &lt;RelativeLayout
            android:layout_width=&#34;wrap_content&#34;
            android:layout_height=&#34;match_parent&#34;
            android:background=&#34;?attr/selectableItemBackgroundBorderless&#34;&gt;

            &lt;ImageView
                android:id=&#34;@+id/thumbnail&#34;
                android:layout_width=&#34;match_parent&#34;
                android:layout_height=&#34;@dimen/album_cover_height&#34;
                android:scaleType=&#34;centerCrop&#34; /&gt;

            &lt;TextView
                android:id=&#34;@+id/title&#34;
                android:layout_width=&#34;wrap_content&#34;
                android:layout_height=&#34;wrap_content&#34;
                android:layout_below=&#34;@id/thumbnail&#34;
                android:paddingLeft=&#34;@dimen/ten_dp&#34;
                android:paddingRight=&#34;@dimen/ten_dp&#34;
                android:paddingTop=&#34;@dimen/ten_dp&#34;
                android:text=&#34;Camera&#34;
                android:textColor=&#34;@color/colorPrimaryText&#34;
                android:textSize=&#34;@dimen/fifteen_dp&#34; /&gt;

            &lt;RelativeLayout
                android:layout_width=&#34;wrap_content&#34;
                android:layout_height=&#34;wrap_content&#34;
                android:layout_below=&#34;@id/title&#34;&gt;

                &lt;TextView
                    android:id=&#34;@+id/photoCount&#34;
                    android:layout_width=&#34;wrap_content&#34;
                    android:layout_height=&#34;wrap_content&#34;
                    android:paddingBottom=&#34;@dimen/five_dp&#34;
                    android:paddingLeft=&#34;@dimen/ten_dp&#34;
                    android:paddingRight=&#34;@dimen/six_dp&#34;
                    android:textColor=&#34;@color/colorSecondaryText&#34;
                    android:textSize=&#34;@dimen/twelve_dp&#34; /&gt;
            &lt;/RelativeLayout&gt;
        &lt;/RelativeLayout&gt;
    &lt;/android.support.v7.widget.CardView&gt;
&lt;/LinearLayout&gt;</pre></div>
<p>Создадим ещё класс, назовём файл с ним AlbumFoldersAdapter.kt — это будет адаптер для RecyclerView.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">    class AlbumFoldersAdapter(val albumList: ArrayList, val context: Context, val options: RequestOptions, val glide: RequestBuilder, val glideMain: RequestManager, val inOnItemClick: IOnItemClick) : RecyclerView.Adapter() {
    
     override fun onViewRecycled(holder: ViewHolder?) {
     if (holder != null) {
     //glideMain.clear(holder.itemView.thumbnail)
     // glide.clear(holder.itemView.thumbnail)
     //Glide.get(context).clearMemory()
     // holder?.itemView?.thumbnail?.setImageBitmap(null)
     }// Glide.clear(holder?.itemView?.thumbnail)
     super.onViewRecycled(holder)
    
    }
    
    override fun onViewDetachedFromWindow(holder: ViewHolder) {
     if (holder != null) {
     // glideMain.clear(holder.itemView.thumbnail)
     //Glide.get(context).clearMemory()
     // holder?.itemView?.thumbnail?.setImageBitmap(null)
     
    }
    
    super.onViewDetachedFromWindow(holder)
     }
    
    override fun getItemCount(): Int {
     return albumList.size
     }
    
    override fun onBindViewHolder(holder: ViewHolder?, position: Int) {
     holder?.bindItems(albumList.get(position), glide, options, inOnItemClick, albumList.get(position).isVideo)
    
    holder?.itemView?.title?.setText(albumList.get(position).folderNames)
     if (albumList.get(position).isVideo)
     holder?.itemView?.photoCount?.setText(&#34;&#34; + albumList.get(position).imgCount + &#34; videos&#34;)
     else
     holder?.itemView?.photoCount?.setText(&#34;&#34; + albumList.get(position).imgCount + &#34; photos&#34;)
     }
    
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
     val v = LayoutInflater.from(parent.context).inflate(R.layout.list_layout, parent, false)
     return ViewHolder(v)
     }
    
    class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
    
    fun bindItems(albumList: Albums, glide: RequestBuilder, options: RequestOptions, inOnItemClick: IOnItemClick, isVideo: Boolean) {
     glide.load(albumList.imagePath).apply { options }.thumbnail(0.4f)
     .into(itemView.thumbnail)
    
    itemView.setOnClickListener(object : View.OnClickListener {
     override fun onClick(p0: View?) {
     inOnItemClick.onItemClick(albumList.folderNames, isVideo)
         }
      })
    }}}</pre></div>
<h3 id="добавим-interface-для-обработки-клика-в-recyclerview">Добавим Interface для обработки клика в RecyclerView</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">    interface IOnItemClick {
        fun onItemClick(position: String, isVideo: Boolean)
    }</pre></div>
<p>Итак, мы реализовали вывод всех папок с изображениями и самих изображений выбранной папки в recyclerView.</p>

<p>Также мы создали код для RecyclerView Adapter и использовали библиотеку Glide для загрузки изображений в него.</p>

<h3 id="создадим-новую-activity-albumsactivity-kt-ответственную-за-вывод-изображений-выбранной-папки-в-recyclerview">Создадим новую Activity AlbumsActivity.kt, ответственную за вывод изображений выбранной папки в RecyclerView.</h3>

<p>Создадим файл разметки для AlbumsActivity.kt</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// activity_album.xml

&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
    xmlns:app=&#34;http://schemas.android.com/apk/res-auto&#34;
    android:id=&#34;@+id/main_content&#34;
    android:layout_width=&#34;match_parent&#34;
    android:layout_height=&#34;match_parent&#34;&gt;

    &lt;android.support.v7.widget.Toolbar
        android:id=&#34;@+id/my_album_toolbar&#34;
        android:layout_width=&#34;match_parent&#34;
        android:layout_height=&#34;?attr/actionBarSize&#34;
        android:background=&#34;?attr/colorPrimary&#34;
        android:elevation=&#34;4dp&#34;
        app:titleTextColor=&#34;@color/colorIcons&#34; /&gt;

    &lt;android.support.v7.widget.RecyclerView
        android:id=&#34;@+id/rvAlbumSelected&#34;
        android:layout_width=&#34;match_parent&#34;
        android:layout_height=&#34;match_parent&#34;
        android:layout_marginTop=&#34;?attr/actionBarSize&#34;
        android:clipToPadding=&#34;false&#34; /&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;</pre></div>
<h3 id="albumsactivity-kt">AlbumsActivity.kt</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_album)
    
        setSupportActionBar(my_album_toolbar)
        // Включим кнопку &#34;Вверх&#34;
        supportActionBar!!.setDisplayHomeAsUpEnabled(true)
    
        val folder_name = intent.getStringExtra(&#34;folder_name&#34;)
        supportActionBar!!.setTitle(&#34;&#34; + folder_name)
        val isVideo = intent.getBooleanExtra(&#34;isVideo&#34;, false)
        init_ui_views(folder_name, isVideo)
    
    }
    </pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">    var adapter: SingleAlbumAdapter? = null
    
    private fun init_ui_views(folderName: String?, isVideo: Boolean?) {
    
        val options = RequestOptions()
                .diskCacheStrategy(DiskCacheStrategy.RESOURCE).override(160, 160).skipMemoryCache(true).error(R.drawable.ic_image_unavailable)
        val glide = Glide.with(this)
        val builder = glide.asBitmap()
    
            rvAlbumSelected.layoutManager = GridLayoutManager(this, 2)
        rvAlbumSelected?.setHasFixedSize(true)
        adapter = SingleAlbumAdapter(getAllShownImagesPath(this, folderName, isVideo), this, options, builder, glide, this)
        rvAlbumSelected?.adapter = adapter
    
        rvAlbumSelected?.addOnScrollListener(object : RecyclerView.OnScrollListener() {
            override fun onScrolled(recyclerView: RecyclerView?, dx: Int, dy: Int) {
                super.onScrolled(recyclerView, dx, dy)
            }
    
            override fun onScrollStateChanged(recyclerView: RecyclerView?, newState: Int) {
                super.onScrollStateChanged(recyclerView, newState)
                when (newState) {
                    RecyclerView.SCROLL_STATE_IDLE -&gt; glide.resumeRequests()
                    AbsListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL, AbsListView.OnScrollListener.SCROLL_STATE_FLING -&gt; glide.pauseRequests()
                }
            }
        }
        )
    }
    
    // Читаем все пути до изображений в выбранной папке.
    
    private fun getAllShownImagesPath(activity: Activity, folderName: String?, isVideo: Boolean?): MutableList {
    
        val uri: Uri
        val cursorBucket: Cursor
        val column_index_data: Int
        val listOfAllImages = ArrayList()
        var absolutePathOfImage: String? = null
    
        val selectionArgs = arrayOf(&#34;%&#34; + folderName + &#34;%&#34;)
    
        uri = android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI
        val selection = MediaStore.Images.Media.DATA + &#34; like ? &#34;
    
        val projectionOnlyBucket = arrayOf(MediaStore.MediaColumns.DATA, MediaStore.Images.Media.BUCKET_DISPLAY_NAME)
    
        cursorBucket = activity.contentResolver.query(uri, projectionOnlyBucket, selection, selectionArgs, null)
    
        column_index_data = cursorBucket.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA)
    
        while (cursorBucket.moveToNext()) {
            absolutePathOfImage = cursorBucket.getString(column_index_data)
            if (absolutePathOfImage != &#34;&#34; &amp;&amp; absolutePathOfImage != null)
                listOfAllImages.add(absolutePathOfImage)
        }
        return listOfAllImages.asReversed()
    }</pre></div>
<h3 id="слушатель-клика-для-album-activity">Слушатель клика для Album Activity</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">override fun onItemClick(position: String, isVideo: Boolean) {
    val intent = Intent(this, PhotoActivity::class.java)
    intent.putExtra(&#34;folder_name&#34;, position)
    startActivity(intent)
}</pre></div>
<h3 id="recyclerview-adapter-для-albumactivity-kt">RecyclerView adapter для AlbumActivity.kt</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">class SingleAlbumAdapter(val albumList: MutableList, val context: Context, val options: RequestOptions, val glide: RequestBuilder, val glideMain: RequestManager, val inOnItemClick: IOnItemClick) : RecyclerView.Adapter() {


    override fun onViewRecycled(holder: ViewHolder?) {
        if (holder != null) {
        }
        super.onViewRecycled(holder)
    }

    override fun onViewDetachedFromWindow(holder: ViewHolder) {
        if (holder != null) {

        }
        super.onViewDetachedFromWindow(holder)
    }

    override fun getItemCount(): Int {
        return albumList.size
    }

    override fun onBindViewHolder(holder: ViewHolder?, position: Int) {
        holder?.bindItems(albumList.get(position), glide, options, inOnItemClick)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val v = LayoutInflater.from(parent.context).inflate(R.layout.list_single_album_layout, parent, false)
        return ViewHolder(v)
    }

    class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        fun bindItems(albumList: String, glide: RequestBuilder, options: RequestOptions, inOnItemClick: IOnItemClick) {

            glide.load(albumList).apply { options }.thumbnail(0.4f)
                    .into(itemView.thumbnail)

            itemView.setOnClickListener(object : View.OnClickListener {
                override fun onClick(p0: View?) {
                    inOnItemClick.onItemClick(albumList, false)
                }
            })
        }
    }
}</pre></div>
<h3 id="файл-разметки-для-single-album-adapter">Файл разметки для Single Album Adapter</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;LinearLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
    xmlns:card_view=&#34;http://schemas.android.com/apk/res-auto&#34;
    android:layout_width=&#34;match_parent&#34;
    android:layout_height=&#34;wrap_content&#34;&gt;

    &lt;android.support.v7.widget.CardView
        android:id=&#34;@+id/card_view&#34;
        android:layout_width=&#34;wrap_content&#34;
        android:layout_height=&#34;wrap_content&#34;
        android:layout_gravity=&#34;center&#34;
        android:layout_margin=&#34;@dimen/five_dp&#34;
        android:elevation=&#34;3dp&#34;
        card_view:cardCornerRadius=&#34;@dimen/zero_dp&#34;&gt;

        &lt;RelativeLayout
            android:layout_width=&#34;wrap_content&#34;
            android:layout_height=&#34;match_parent&#34;
            android:background=&#34;?attr/selectableItemBackgroundBorderless&#34;&gt;

            &lt;ImageView
                android:id=&#34;@+id/thumbnail&#34;
                android:layout_width=&#34;@dimen/album_cover_height&#34;
                android:layout_height=&#34;@dimen/album_cover_height&#34;
                android:scaleType=&#34;centerCrop&#34; /&gt;
        &lt;/RelativeLayout&gt;
    &lt;/android.support.v7.widget.CardView&gt;
&lt;/LinearLayout&gt;</pre></div>
<h3 id="теперь-добавим-detail-activity-выводящую-единственное-изображение">Теперь добавим Detail Activity, выводящую единственное изображение</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">    
    // SingleActivity.kt
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_photo)
    
        setSupportActionBar(toolbar)
        // Enable the Up button
        supportActionBar!!.setDisplayHomeAsUpEnabled(true)
        supportActionBar!!.setDisplayShowTitleEnabled(false)
    
        val folder_name = intent.getStringExtra(&#34;folder_name&#34;)
        Glide.with(this).load(folder_name).into(imageFullScreenView)
    
        Handler().postDelayed(Runnable
        {
            if (supportActionBar != null)
                appbar.animate().translationY(-appbar.bottom.toFloat()).setInterpolator(AccelerateInterpolator()).start()
            isAppBarShown = false
        }, 1500)
    
    }
    </pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// activity_photo.xml


&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
    xmlns:app=&#34;http://schemas.android.com/apk/res-auto&#34;
    xmlns:tools=&#34;http://schemas.android.com/tools&#34;
    android:layout_width=&#34;match_parent&#34;
    android:layout_height=&#34;match_parent&#34;
    android:background=&#34;@android:color/black&#34;
    tools:context=&#34;com.title_apps.canalpic.screens.detail.PhotoActivity&#34;&gt;

    &lt;android.support.design.widget.AppBarLayout
        android:id=&#34;@+id/appbar&#34;
        android:layout_width=&#34;match_parent&#34;
        android:layout_height=&#34;wrap_content&#34;
        android:background=&#34;#93000000&#34;&gt;

        &lt;android.support.v7.widget.Toolbar
            android:id=&#34;@+id/toolbar&#34;
            android:layout_width=&#34;match_parent&#34;
            android:layout_height=&#34;?attr/actionBarSize&#34;
            android:elevation=&#34;4dp&#34;
            app:titleTextColor=&#34;@color/colorIcons&#34; /&gt;
    &lt;/android.support.design.widget.AppBarLayout&gt;


    &lt;ImageView
        android:id=&#34;@+id/imageFullScreenView&#34;
        android:layout_width=&#34;wrap_content&#34;
        android:layout_height=&#34;wrap_content&#34;
        android:layout_gravity=&#34;center&#34; /&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;</pre></div>
<h3 id="резюмируя">Резюмируя</h3>

<p>Сегодня мы рассмотрели полный пример реализации приложения — галереи изображений под Android, а также освоили синтаксис Kotlin, классы данных, библиотеку Glide, RecyclerView и его адаптер, NavigationView, Drawer Layout и реализацию слушателей для них на Kotlin.</p>

<p>По материалам <a href="http://developine.com/develop-android-image-gallery-app-kotlin-with-source-code/?utm_source=Android+Weekly&amp;utm_campaign=3bfb7e3406-androidweekly-288&amp;utm_medium=email&amp;utm_term=0_4eb677ad19-3bfb7e3406-338185001">«How to Develop Android Image Gallery App in Kotlin Tutorial with Complete Source Code»</a></p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Hugo &#43; Firebase: как быстро и бесплатно создать статический сайт </turbo:topic>
      <link>https://fokusov.com/posts/hugo--firebase-kak-bystro-i-besplatno-sozdat-staticheskij-sajt/</link>
      <pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ 

<p><img src="img/xd1e96004bf.jpg.pagespeed.ic.ckMpY8wdm1.jpg" alt="Разработка: Hugo + Firebase: как быстро и бесплатно создать статический сайт" /></p>

<p>На­вер­ня­ка каж­дый из вас за­ду­мы­вал­ся о том, что­бы со­здать сайт, на ко­то­ром мож­но бы­ло бы раз­ме­стить своё порт­фо­лио, ре­зю­ме или да­же свой блог. Про­чи­тав эту ста­тью, вы смо­же­те сде­лать се­бе та­кой сайт.</p>

<p>Во­об­ще для раз­ра­бот­ки сай­та необ­хо­ди­мо знать HTML, CSS и немно­го JavaScript. В на­шем слу­чае вы мо­же­те не знать ни­че­го из это­го. До­ста­точ­но про­сто уве­рен­но поль­зо­вать­ся ком­пью­те­ром.</p>

<p>Для раз­ме­ще­ния веб-сай­та, необ­хо­ди­мо «про­стран­ство» (веб-хо­стинг), ку­да бу­дут за­гру­же­ны фай­лы ва­ше­го сай­та. И ко­гда кто-ни­будь вве­дёт ад­рес сай­та и на­жмет «ввод», эти са­мые фай­лы бу­дут за­гру­же­ны в его бра­у­зер.</p>

<p>Итак, что вам необ­хо­ди­мо:</p>

<h5 id="учёт-ная-за-пись-google">Учёт­ная за­пись Google</h5>

<p>Ес­ли у вас есть по­ста на Gmail, зна­чит она у вас есть. Ес­ли нет, со­здай­те учёт­ную за­пись.</p>

<h6 id="до-мен">До­мен</h6>

<p>Это по же­ла­нию. В ми­ре есть мно­же­ство про­вай­де­ров до­мен­ных имён, най­ти та­ко­го про­вай­де­ра мож­но в <a href="https://www.google.com/search?q=Регистрация+домена">Google</a>. В от­крыв­шем­ся по­ис­ке мо­же­те клик­нуть на лю­бой ва­ри­ант, это так же про­сто, как ку­пить то­вар в ин­тер­нет-ма­га­зине.</p>

<h6 id="hugo">Hugo</h6>

<p><a href="https://gohugo.io/">Hugo</a> это ути­ли­та, со­зда­ю­щая ста­ти­че­ские сай­ты. Вы мо­же­те ис­поль­зо­вать мно­же­ство тем оформ­ле­ния для сай­та, есть спе­ци­аль­ные те­мы для бло­га, порт­фо­лио и т.п.</p>

<p>Ска­чать её мож­но <a href="https://github.com/gohugoio/hugo/releases">от­сю­да</a>.</p>

<h6 id="firebase">Firebase</h6>

<p><a href="http://firebase.com/">Firebase</a> это плат­фор­ма для мо­биль­ных и веб-при­ло­же­ний от Google. Од­на из функ­ций Firebase это хо­стинг. Раз­ра­бот­чи­ки та­к­же мо­гут ис­поль­зо­вать Firebase для со­зда­ния ана­ли­ти­ки, уве­дом­ле­ний, со­об­ще­ний об ошиб­ках в сво­их при­ло­же­ни­ях. Ну а мы бу­дем раз­ме­щать там свой сайт.</p>

<h6 id="node-js">Node.js</h6>

<p>Node.js это сре­да вы­пол­не­ния JavaScript, по­стро­ен­ная на ос­но­ве <a href="https://developers.google.com/v8/">движ­ка V8 JavaScript из Chrome</a>.<br />
Для на­шей за­да­чи необ­хо­ди­мо про­сто уста­но­вить её для ра­бо­ты ути­лит Firebase. Ска­чай­те её <a href="https://nodejs.org/en/download/">здесь</a>.</p>

<h6 id="шаг-1-уста-но-вим-hugo">Шаг 1: Уста­но­вим Hugo</h6>

<p>Windows: у вас бу­дет про­стой ис­пол­ня­е­мый файл, ко­то­рый вы мо­же­те раз­ме­стить где угод­но и за­пус­кать впо­след­ствии из ко­манд­ной стро­ки. Вы мо­же­те до­ба­вить этот путь в пе­ре­мен­ную «PATH» в пе­ре­мен­ных сре­ды Windows для за­пус­ка из лю­бо­го ме­ста.</p>

<p>Mac: мож­но уста­но­вить его с по­мо­щью Homebrew. Ес­ли у вас не уста­нов­лен brew, ска­чай­те его <a href="https://github.com/gohugoio/hugo/releases">здесь</a>.</p>

<h6 id="шаг-2-со-зда-дим-шаб-лон-ный-сайт">Шаг 2: Со­зда­дим шаб­лон­ный сайт</h6>

<p>Пе­рей­ди­те в ко­манд­ной стро­ке в пап­ку, где вы хо­ти­те раз­ме­стить свой сайт и вве­ди­те сле­ду­ю­щую ко­ман­ду:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ hugo new site &lt;путь_до_папки&gt;</pre></div>
<p>По­сле это­го вы долж­ны уви­деть в пап­ке при­мер­но сле­ду­ю­щую кар­ти­ну:</p>

<p><img src="img/x9f03522200.jpg.pagespeed.ic.5eR85RKcya.jpg" alt="Разработка: Hugo + Firebase: как быстро и бесплатно создать статический сайт" /><br />
Не пу­гай­тесь, в этих пап­ках бу­дет хра­нит­ся ваш сайт и сей­час бу­дет по­нят­но &mdash; ка­кая за­чем нуж­на. К при­ме­ру, в пап­ке content бу­дет хра­нит­ся весь тек­сто­вый кон­тент сай­та.</p>

<p>Для до­бав­ле­ния кон­тен­та вы­пол­ни­те сле­ду­ю­щую ко­ман­ду:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ hugo new about.md</pre></div>
<p>Для со­зда­ния по­ста в бло­ге, мож­но со­здать пап­ку &ldquo;blog&rdquo; в пап­ке &ldquo;content&rdquo; и в неё до­бав­лять кон­тент. Фай­лы име­ют рас­ши­ре­ние &ldquo;.md&rdquo; т.к. это фай­лы фор­ма­та <a href="https://ru.wikipedia.org/wiki/Markdown">Markdown</a>.</p>

<p>Markdown это фор­мат раз­мет­ки тек­сто­вых фай­лов. Он очень про­стой и кра­си­вый. Та­к­же по фор­ма­ту Markdown есть ку­ча ин­струк­ций и шпар­га­лок в ин­тер­не­те, <a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">вот од­на из них (ан­гл.)</a>.</p>

<h6 id="шаг-3-уста-но-вим-те-му-сай-та">Шаг 3: Уста­но­вим те­му сай­та</h6>

<p>У Hugo огром­ное со­об­ще­ство и <a href="https://themes.gohugo.io/">сайт тем для него</a> со­дер­жит мно­же­ство ка­те­го­рий тем оформ­ле­ния сай­тов. Най­ди­те там те­му, ко­то­рая под­хо­дит вам.</p>

<p>Я вы­брал те­му <a href="https://github.com/vickylaiio/hugo-theme-introduction">Introduction</a>. Для её за­груз­ки бра­у­зер пе­ре­бро­сит нас на <a href="https://github.com/vickylaiio/hugo-theme-introduction">GitHub</a>.</p>

<p>Каж­дая те­ма на­стра­и­ва­ет­ся по-раз­но­му. В на­шем слу­чае про­сто ска­чай­те и рас­па­куй­те её в пап­ку themes и ско­пи­руй­те файл config.toml в кор­не­вую пап­ку сай­та.</p>

<h6 id="шаг-4-на-стро-им-сайт">Шаг 4: На­стро­им сайт</h6>

<p>От­кро­ем файл config.toml в тек­сто­вом ре­дак­то­ре. За­да­дим в нём ва­ше имя и дру­гую ин­фор­ма­цию, ко­то­рую вы хо­ти­те опуб­ли­ко­вать на сай­те. Неко­то­рые те­мы под­дер­жи­ва­ют ана­ли­ти­ку Google Analytics и вы смо­же­те от­сле­жи­вать раз­ные мет­ри­ки, та­кие как, на­при­мер, ко­ли­че­ство поль­зо­ва­те­лей сай­та. Для это­го в на­строй­ках нуж­но бу­дет ука­зать иден­ти­фи­ка­тор Google Analytics.</p>

<h6 id="шаг-5-со-зда-дим-про-ект-хо-стин-га-firebase">Шаг 5: Со­зда­дим про­ект хо­стин­га Firebase</h6>

<p>Как я го­во­рил, Firebase это очень мощ­ная плат­фор­ма с ку­чей воз­мож­но­стей. Но я ис­поль­зую толь­ко хо­стинг Firebase для раз­ме­ще­ния сай­та, со­здан­но­го Hugo.</p>

<p>Для ис­поль­зо­ва­ния служб Firebase, необ­хо­ди­мо <a href="https://firebase.google.com/">зай­ти в них</a> с учёт­ной за­пи­сью Google.</p>

<p>По­сле это­го на­жми­те «ПЕ­РЕЙ­ТИ К КОН­СО­ЛИ» (&ldquo;Go to console&rdquo;). Со­здай­те про­ект, за­дав ему имя. По­сле это­го вы ока­же­тесь на стра­ни­це про­ек­та и да­лее нуж­но пе­рей­ти к эле­мен­ту Hosting (&ldquo;getting started on Hosting&rdquo;)</p>

<h6 id="шаг-6-на-строй-те-ути-ли-ты-firebase-на-ло-каль-ном-ком-пью-те-ре">Шаг 6: На­строй­те ути­ли­ты Firebase на ло­каль­ном ком­пью­те­ре</h6>

<p>От­крой­те ко­манд­ную стро­ку и вве­ди­те ко­ман­ду:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ npm install -g firebase-tools</pre></div>
<p>Эта ко­ман­да уста­но­вит па­кет Firebase-tools. Для раз­ме­ще­ния сай­та по­тре­бу­ет­ся вве­сти ещё немно­го ко­манд.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ firebase login</pre></div>
<p>Эта ко­ман­да со­еди­нит ваш ком­пью­тер с про­ек­том Firebase. Вам бу­дет дан вы­бор про­ек­та для на­шей за­да­чи.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ firebase list</pre></div>
<p>Этой ко­ман­дой вы смо­же­те вы­ве­сти в кон­соль имя со­здан­но­го ра­нее про­ек­та. Оста­лось ини­ци­а­ли­зи­ро­вать пап­ку про­ек­та Firebase.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ firebase init</pre></div>
<p>Да­лее от­веть­те на во­про­сы:</p>

<ul>
<li>Ка­кие функ­ции Firebase вы хо­ти­те на­стро­ить? (Which Firebase CLI features do you want to setup?) От­вет: Хо­стинг/Hosting.</li>
<li>Вы­бе­ри­те про­ект Firebase для этой пап­ки (Select a default Firebase project for this directory) От­вет: Вы­бе­ри­те про­ект Firebase, со­здан­ный на ша­ге 5.</li>
<li>Вы хо­ти­те ис­поль­зо­вать её как об­ще­до­ступ­ную пап­ку? (Do you want to use as your public directory?) От­вет: Да/Yes.</li>
<li>На­стро­ить как од­но­стра­нич­ное при­ло­же­ние? (Configure as a single-page app?) От­вет: Да/Yes.</li>
</ul>

<p>Я сде­лал скрин­шо­ты всех ша­гов этой ко­ман­ды, что­бы вы не за­пу­та­лись:</p>

<p><a href="img/f9b7e2.png"><img src="img/xf9b7e2_preview.png.pagespeed.ic.HDAwRrksZY.png" alt="Разработка: Hugo + Firebase: как быстро и бесплатно создать статический сайт" /></a></p>

<p><a href="img/236219.png"><img src="img/x236219_preview.png.pagespeed.ic.PevjZNkCWt.png" alt="Разработка: Hugo + Firebase: как быстро и бесплатно создать статический сайт" /></a></p>

<p><a href="img/28ea99.png"><img src="img/x28ea99_preview.png.pagespeed.ic.0aY2KPJ12-.png" alt="Разработка: Hugo + Firebase: как быстро и бесплатно создать статический сайт" /></a></p>

<p><a href="img/25dbe9.png"><img src="img/x25dbe9_preview.png.pagespeed.ic.QZiMCVjJib.png" alt="Разработка: Hugo + Firebase: как быстро и бесплатно создать статический сайт" /></a></p>

<p>От­лич­но! Ини­ци­а­ли­за­ция Firebase окон­че­на.</p>

<h6 id="шаг-7-про-ве-рим-ра-бо-ту-сай-та-ло-каль-но">Шаг 7: Про­ве­рим ра­бо­ту сай­та ло­каль­но</h6>

<p>Для за­пус­ка ло­каль­ной про­вер­ки ва­ше­го сай­та, вы­пол­ни­те сле­ду­ю­щую ко­ман­ду:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ hugo server -w</pre></div>
<p>Вме­сте с Hugo идёт лёг­кий и мощ­ный веб-сер­вер, ко­то­рый поз­во­ля­ет пол­но­цен­но про­ве­рить ре­зуль­тат ра­бо­ты сай­та. Убе­ди­тесь, что все изоб­ра­же­ния сай­та раз­ме­ще­ны в пап­ке static/img. Про­верь­те на­строй­ки в фай­ле config.toml. За­тем от­крой­те свой сайт в бра­у­зе­ре <a href="http://localhost:1313">http://localhost:1313</a></p>

<h6 id="шаг-8-раз-ме-ще-ние-сай-та">Шаг 8: Раз­ме­ще­ние сай­та</h6>

<p>Вве­ди­те сле­ду­ю­щую ко­ман­ду для со­зда­ния сай­та и вы­груз­ки его в Firebase:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ hugo &amp;&amp; firebase deploy</pre></div>
<h6 id="шаг-9-при-вя-жем-свой-до-мен-необя-за-тель-но">Шаг 9: При­вя­жем свой до­мен (необя­за­тель­но)</h6>

<p>В Firebase есть функ­ция при­вяз­ки до­ме­на к при­ло­же­нию Firebase. На­ж­жми­те на connect domain, за­тем вве­ди­те имя до­ме­на и до­бавь­те TXT-за­пи­си для про­вер­ки вла­де­ния до­ме­ном.</p>

<p><img src="img/x2201ed606b.jpg.pagespeed.ic.jaYj9eopkf.jpg" alt="Разработка: Hugo + Firebase: как быстро и бесплатно создать статический сайт" />
Это де­ла­ет­ся в лич­ном ка­би­не­те ре­ги­стра­то­ра до­ме­на.</p>

<h6 id="шаг-10-со-зда-дим-пост-в-бло-ге">Шаг 10: Со­зда­дим пост в бло­ге</h6>

<p>Это очень про­сто. Hugo по­ни­ма­ет фай­лы markdown. Пе­рей­ди­те в пап­ку content-&gt;blog (её раз­ме­ще­ние мо­жет за­ви­сеть от на­строй­ки те­мы). Со­здай­те файл markdown. По­вто­ри­те шаг 8 для про­вер­ки ре­зуль­та­та.</p>

<p>От­пи­ши­тесь в ком­мен­та­ри­ях, ес­ли у вас есть во­про­сы/по­же­ла­ния :)</p>

<p>По ма­те­ри­а­лам <a href="https://medium.freecodecamp.org/hugo-firebase-how-to-create-your-own-dynamic-website-for-free-in-minutes-463b4fb7bf5a">«Hugo + Firebase: How to create your own static website for free in minutes»</a></p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Как отправлять СМС и звонить с Angular NativeScript</turbo:topic>
      <link>https://fokusov.com/posts/kak-otpravljat-sms-i-zvonit-s-angular-nativescript/</link>
      <pubDate>Sat, 25 Mar 2017 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ <p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA8AAAAGQCAMAAABWGfl3AAABGlBMVEUeh+QeiOUfiOUgh+EgieUiZcIiiuUkWbcmhNcmjOUng9UoNZMqjuYrgc8sgM4uf8kzfME0fMA1k+Y2e7s2e7w5ebY6luc7l+c8l+dAmedCdKdCmudEc6RFcqJFnOdHcZ9Lb5hMn+hQbI5Sa4tSouhUaodXaINapuhapulbp+lcp+leZHZeZHdeqOliYm9iYnBoX2ZqXWJrXWBrr+psr+ptXF1tr+pvW1lxsupzs+p0WFF1tOp2tOp3Vkt5VUh5tup6tuqHr+OHvOuHveuNwOuQweySwuyUw+yas+Kbx+yfqNqrzu2x0u621O661u671+692O7AxuTB2u/L0efN4O/P4O/X5fDa5vDf6fDj6/Dj6/Hm7PHn7fHs7/GEfjSnAAAF30lEQVR42u3d3U+TZxjAYWoppUhFNHPtHFo/osd+zZgsnvgH+M96uiMXk5mMnThilvkVjBIBRYFAgVKDxmaxUI2+z5vdb6/roDa2fZ7kLr/ytmlL6eYIENUhIwABAwIGBAwCBgQMCBgQMAgYEDAgYBAwIGBAwICAQcCAgAEBAwIGAQMCBgQMAgYEDAgYEDAIGPj/GTWCWN6udnbTPZyX61NGLGAS6c4vtBNvUW3MlAw6jvJpMwhj5eFiJ/Uenbeva+NGLWAyt/z3Vh7bbL2anDDsKLyIFcbaXF47za2ZtoDJ2Hwht0LAQ/IEeCm/vZZWzFvAZOp1YTdDwENgtbCbIeAh8K6wmyFgEDAgYEDAgIChyHwaKaixjNfbMlIBE/eOE7BDaEDAgIBBwICAAQEDAgYBAwIGBAwCBgQMCBgQMAgYEDAgYEDAIGBAwICAQcCAgAEBAwIGAQMCBgQMCBgEDAgYEDAIGBAwIGBAwCBgQMCAgEHAgIABAQMCBgEDAgYEDAgYBAwIGBAwCBgQMCBgQMAgYEDAgIABAYOAAQEDAgYBAwIGBAwIGAQMCBgQMAgYEDAgYEDAIGBAwICAAQGDgAEBAwIGAQMCBgQMCBgEDAgYEDAgYBAwIGBAwCBgQMCAgAEBg4ABAQMCBgQMsY0aQUjdrawXLBmqgMlLaSfrBc3UITQgYEDA4Dkwkf10vjrS/veFQQiYgG41905PvfzNKBxCE8615sd/m9fMQsCE0+g7g4AJY7LvDAIminK5/xwCJojO9qdz2x3TEDDRrPWdQcCE8azvDAImjAePP3ziYefxA7MoLG/kKLB7s62jIytPN01CwES0+dAMHEIDAgYEDHgOXADnfq589vD74WtxugNvtN9VdrefPzJOAZOjyq8/jPX95/LeyfGBt9v/KjNXFn/fNlQBk9dv30vjma43dvL2X34LC5h8XMz+E77jN8r/GGw8XsQK6ESST+j/8qPJCpgcXE2z7BWTFTDptY6lWfdYy2wFTHLnwy2MgOmph1sYAdMzEW5hBExPKdzCCBgQMAgYEDDwnbwXOp7l6qBLv+I7ZA+6SttsBUx67W++UKgOoQEBAwIGz4GJpFQ76JKNvZPawBsPvkqpa7wCJq3uxMA6J74c8IFX0a9DaEDAgIBBwICAychuuIURMD1r4RZGwAgYARfBXLiFETA9C0tp1l1aMFsBk97djRSrbtw1WQGTg/X7CT7R276/brLxeC90RPOb149mvOTKH4vmKmDysXjn8kyWf0dh9fmfhipg8jM7O9048tm9V9k7eTLwZvtdZefdwhsDFTD5eqM6vIgFAgYEDAgYBMww31N+LPxYkK0jhd0MAQ+BqcJuhoCHwHRhN0PAQ6DezG+vZt28BUy2WrlVVW+ZtoDJ2OjZWj4b1c56g20Y5dNmEEV1enMjh22OX5g0awGTvcqJaif1H+eeOnWmYtKBjsuMIJJGo73eTvf1zYeqh6uGLGASHkcrjP8+5hoBCBgQMCBgEDAgYEDAgIBBwICAAQGDgAEBAwIGBAwCBgQMCBgQMAgYEDAgYBAwIGBAwICAQcCAgAEBAwIGAQMCBgQMAgYEDAgYEDAIGBAwIGAQMCBgQMCAgEHAgIABAQMCBgEDAgYEDAIGBAwIGBAwCBgQMCBgQMAgYEDAgIBBwICAAQEDAgYBAwIGBAwIGAQMCBgQMAgYEDAgYEDAIGBAwICAQcCAgAEBAwIGAQMCBgQMCBgEDAgYEDAIGBAwIGBAwCBgQMCAgAEBg4ABAQMCBgEDAgYEDAgYBAwIGBAwIGAQMCBgQMAgYEDAgIABAYOAAQEDAgYBAwIGBAwIGAQMCBgQMCBgEDAgYEDAIGBAwICAAQGDgAEBAwIGBAwCBgQMCBgEDAgYEDAgYBAwIGBAwCBgQMCAgAEBg4ABAQMCBgQMAgYEDAgYBAwIGBAwIGAQMCBgQMCAgEHAgIABAYOAAQEDAgYEDAIGBAwIGBAwCBgQMCBgEDAgYEDAwP7eA/uKlWl+BO43AAAAAElFTkSuQmCC" alt="Разработка: Как отправлять СМС и звонить с Angular NativeScript" /></p>

<p>От­прав­лять СМС из при­ло­же­ния NativeScript очень про­сто! И се­год­ня я по­ка­жу вам как это сде­лать.</p>

<p>Ис­ход­ный код мож­но ска­чать <a href="https://github.com/PWHSoftware/NativeScript_SMS_Phone">здесь</a>.</p>

<p>Убе­ди­тесь, что у вас уста­нов­лен NodeJS и NativeScript CLI.</p>

<p>Вна­ча­ле со­зда­дим пу­стой про­ект Angular NativeScript:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">tns create HelloWorld --template nativescript-template-ng-tutorial</pre></div>
<p>Эта ко­ман­да со­здаст про­ект smsApp. Пе­рей­ди­те в со­здан­ную ди­рек­то­рию про­ек­та и уста­но­ви­те пла­гин nativescript-phone:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">tns plugin add nativescript-phone</pre></div>
<p>Им­пор­ти­ру­ем этот мо­дуль в фай­ле app.​com​pone​nt.​ts:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">import * as phone from &#39;nativescript-phone&#39;;</pre></div>
<p>Для ис­поль­зо­ва­ния ngModel в на­шем про­ек­те, нуж­но до­ба­вить NativeScriptFormsModule в файл app.​module.​ts:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">import {NativeScriptFormsModule} from &#34;nativescript-angular/forms&#34;

@NgModule({
  declarations: [AppComponent],
  bootstrap: [AppComponent],
  imports: [NativeScriptModule, NativeScriptFormsModule],
  schemas: [NO_ERRORS_SCHEMA],
})</pre></div>
<p>До­ба­вим сти­ли в app.​css для кно­пок:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">@import &#34;nativescript-theme-core/css/sky.css&#34;;

.phone-button {
    background-color:#2ecc71;
    color:white;
}

.text-button {
    background-color:#3498db;
    color:white;
}</pre></div>
<p>Те­перь нуж­но раз­ра­бо­тать ин­тер­фейс. Для про­сто­ты опи­шем его в шаб­лоне в фай­ле app.​com​pone​nt.​ts</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">@Component({
  selector: &#34;my-app&#34;,
  template: `
    &lt;ActionBar class=&#34;action-bar&#34; title=&#34;NativeScript SMS Application&#34;&gt;&lt;/ActionBar&gt;
    &lt;StackLayout class=&#34;p-20&#34;&gt;

      &lt;Label text=&#34;Select either TEXT or PHONE to continue.&#34;&gt;&lt;/Label&gt;

      &lt;FlexboxLayout&gt;
        &lt;Button class=&#34;phone-button&#34; (tap)=&#34;setPhoneType(0)&#34; text=&#34;PHONE&#34;&gt;&lt;/Button&gt;
        &lt;Button class=&#34;text-button&#34;(tap)=&#34;setPhoneType(1)&#34; text=&#34;Text&#34;&gt;&lt;/Button&gt;
      &lt;/FlexboxLayout&gt;

      &lt;StackLayout *ngIf=&#34;phoneType === 0&#34;&gt;
        &lt;TextField keyboardType=&#34;phone&#34; hint=&#34;Enter Phone Number...&#34; [(ngModel)]=&#34;phoneNumber&#34;&gt;&lt;/TextField&gt;
        &lt;Button (tap)=&#34;callNumber()&#34; *ngIf=&#34;phoneNumber&#34; class=&#34;phone-button&#34; [text]=&#34;&#39;Call &#39; + phoneNumber&#34;&gt;&lt;/Button&gt;
      &lt;/StackLayout&gt;

      &lt;StackLayout *ngIf=&#34;phoneType === 1&#34;&gt;
        &lt;TextField keyboardType=&#34;phone&#34; hint=&#34;Enter Phone Number...&#34; [(ngModel)]=&#34;phoneNumber&#34;&gt;&lt;/TextField&gt;
        &lt;TextField keyboardType=&#34;text&#34; hint=&#34;Enter Message...&#34; [(ngModel)]=&#34;message&#34;&gt;&lt;/TextField&gt;
        &lt;Button (tap)=&#34;textNumber()&#34; *ngIf=&#34;phoneNumber &amp;&amp; message&#34; class=&#34;text-button&#34; [text]=&#34;&#39;Text &#39; + phoneNumber&#34;&gt;&lt;/Button&gt;
      &lt;/StackLayout&gt;

    &lt;/StackLayout&gt;
  `
})</pre></div>
<p>Для на­бо­ра но­ме­ра мы мо­жем ис­поль­зо­вать функ­цию phone.dial(). Мы по­лу­чим этот но­мер че­рез при­вяз­ку к ngModel в шаб­лоне. Вот как вы­гля­дит эта функ­ция:</p>

<p><img src="img/x6e1b9a8cc5.jpg.pagespeed.ic.4319TXPgfu.jpg" alt="Разработка: Как отправлять СМС и звонить с Angular NativeScript" /><br />
До­ста­точ­но про­сто. Нуж­но про­сто пе­ре­дать но­мер стро­кой в ме­тод. Так как мы пе­ре­да­ём но­мер чис­лом с циф­ро­вой кла­ви­а­ту­ры, до­ста­точ­но бу­дет про­сто пре­об­ра­зо­вать его в стро­ку:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">export class AppComponent {
  //Переменные
  phoneNumber: number;
  message: string;

  //Для определения какой выбор сделал пользователь
  phoneType: number;

  //Установим выбор пользователя (смс или звонок)
  setPhoneType(val) {
    this.phoneType = val;
  }

  callNumber() {
    phone.dial(String(this.phoneNumber), true)
  }
}</pre></div>
<p>Для пе­ре­да­чи СМС есть со­от­вет­ству­ю­щий ме­тод:</p>

<p><img src="img/xaaa8d9c912.jpg.pagespeed.ic.eIimPN-OnC.jpg" alt="Разработка: Как отправлять СМС и звонить с Angular NativeScript" /><br />
Ин­те­рес­ное здесь то, что мы мо­жем от­пра­вить со­об­ще­ние мас­си­ву но­ме­ров, по­это­му мы мо­жем со­здать несколь­ко по­лей для вво­да но­ме­ров. Я по­ка пе­ре­дам толь­ко один но­мер ме­то­ду:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">textNumber() {
  /*
    Здесь у нас массив номеров, поэтому легко можем добавить ещё один номер:
    phone.sms([&#39;1234&#39;,&#39;5678&#39;...], message)
  */
  phone.sms([String(this.phoneNumber)], this.message).then((result) =&gt; {
    //Возвращает promise, делайте с ним что хотите
    console.log(result);
  })
}</pre></div>
<p>Вот пол­ный код уро­ка:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">import { Component } from &#34;@angular/core&#34;;
import * as phone from &#39;nativescript-phone&#39;;
@Component({
  selector: &#34;my-app&#34;,
  template: `
    &lt;ActionBar class=&#34;action-bar&#34; title=&#34;NativeScript SMS Application&#34;&gt;&lt;/ActionBar&gt;
    &lt;StackLayout class=&#34;p-20&#34;&gt;

      &lt;Label text=&#34;Select either TEXT or PHONE to continue.&#34;&gt;&lt;/Label&gt;

      &lt;FlexboxLayout&gt;
        &lt;Button class=&#34;phone-button&#34; (tap)=&#34;setPhoneType(0)&#34; text=&#34;PHONE&#34;&gt;&lt;/Button&gt;
        &lt;Button class=&#34;text-button&#34;(tap)=&#34;setPhoneType(1)&#34; text=&#34;Text&#34;&gt;&lt;/Button&gt;
      &lt;/FlexboxLayout&gt;

      &lt;StackLayout *ngIf=&#34;phoneType === 0&#34;&gt;
        &lt;TextField keyboardType=&#34;phone&#34; hint=&#34;Enter Phone Number...&#34; [(ngModel)]=&#34;phoneNumber&#34;&gt;&lt;/TextField&gt;
        &lt;Button (tap)=&#34;callNumber()&#34; *ngIf=&#34;phoneNumber&#34; class=&#34;phone-button&#34; [text]=&#34;&#39;Call &#39; + phoneNumber&#34;&gt;&lt;/Button&gt;
      &lt;/StackLayout&gt;

      &lt;StackLayout *ngIf=&#34;phoneType === 1&#34;&gt;
        &lt;TextField keyboardType=&#34;phone&#34; hint=&#34;Enter Phone Number...&#34; [(ngModel)]=&#34;phoneNumber&#34;&gt;&lt;/TextField&gt;
        &lt;TextField keyboardType=&#34;text&#34; hint=&#34;Enter Message...&#34; [(ngModel)]=&#34;message&#34;&gt;&lt;/TextField&gt;
        &lt;Button (tap)=&#34;textNumber()&#34; *ngIf=&#34;phoneNumber &amp;&amp; message&#34; class=&#34;text-button&#34; [text]=&#34;&#39;Text &#39; + phoneNumber&#34;&gt;&lt;/Button&gt;
      &lt;/StackLayout&gt;

    &lt;/StackLayout&gt;
  `
})
export class AppComponent {
  //Переменные
  phoneNumber: number;
  message: string;

  //Для определения какой выбор сделал пользователь
  phoneType: number;

  //Установим выбор пользователя (смс или звонок)
  setPhoneType(val) {
    this.phoneType = val;
  }

  callNumber() {
    phone.dial(String(this.phoneNumber), true)
  }

  textNumber() {
    /*
      Здесь у нас массив номеров, поэтому легко можем добавить ещё один номер:
      phone.sms([&#39;1234&#39;,&#39;5678&#39;...], message)
    */
    phone.sms([String(this.phoneNumber)], this.message).then((result) =&gt; {
      //Возвращает promise, делайте с ним что хотите
      console.log(result);
    })
  }
}</pre></div>
<p><img src="img/x08172bae34.png.pagespeed.ic.YfEgjZNdWm.png" alt="Разработка: Как отправлять СМС и звонить с Angular NativeScript" /></p>

<p>Ис­точ­ник: <a href="https://pwhsoftware.com/blog/2017/03/17/how-to-send-an-sms-and-make-phone-calls-with-nativescript">«How to Send an SMS and Make Phone Calls with Angular NativeScript»</a></p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Создаём укорачивалку URL на Golang с Couchbase NoSQL</turbo:topic>
      <link>https://fokusov.com/posts/sozdaem-ukorachivalku-url-na-golang-s-couchbase-nosql/</link>
      <pubDate>Thu, 23 Mar 2017 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ 

<p><img src="img/xc9392a.jpg.pagespeed.ic.Xf6FF9zr0z.jpg" alt="Разработка: Создаём укорачивалку URL на Golang с Couchbase NoSQL" /><br />
Раз­ра­бот­ка сер­ви­са по уко­ра­чи­ва­нию ссы­лок (та­ко­го как TinyURL или Bitly) на Go, ду­маю, бу­дет очень кру­тым при­ме­ром для на­чи­на­ю­щих. Итак, при­сту­пим!</p>

<h5 id="под-го-тов-ка">Под­го­тов­ка</h5>

<p>Для на­ча­ла про­верь­те, что у вас уста­нов­лен <a href="https://golang.org/">Go</a> вер­сии не ни­же 1.7 и уста­но­ви­те <a href="http://www.couchbase.com/">Couchbase Server</a> 4.1+</p>

<p>На­ше при­ло­же­ние бу­дет ис­поль­зо­вать за­про­сы N1QL &mdash; SQL за­про­сы к ба­зе дан­ных Couchbase NoSQL.</p>

<h6 id="под-го-тов-ка-ба-зы-дан-ных-со-зда-ние-мо-де-ли-дан-ных">Под­го­тов­ка ба­зы дан­ных, со­зда­ние мо­де­ли дан­ных</h6>

<p>Для хра­не­ния ин­фор­ма­ции о длин­ных и ко­рот­ких URL нам нуж­на ба­за дан­ных. Для на­шей неслож­ной за­да­чи луч­шим ва­ри­ан­том бу­дет вы­бор NoSQL ба­зы, по­это­му оста­но­вим­ся на БД с от­кры­тым ис­ход­ным ко­дом Couchbase.</p>

<p><a href="http://www.couchbase.com/downloads">Ска­чай­те</a> и уста­но­ви­те нуж­ную вер­сию для ва­шей опе­ра­ци­он­ной си­сте­мы. Во вре­мя уста­нов­ки необ­хо­ди­мо вклю­чить служ­бу за­про­сов (query service).</p>

<p>Для ра­бо­ты нам необ­хо­ди­мо со­здать и на­стро­ить хра­ни­ли­ще дан­ных в Couchbase.</p>

<p><a href="https://gifyu.com/image/SDh5"><img src="https://gifyu.com/images/couchbase-create-bucket.gif" alt="Разработка: couchbase-create-bucket.gif" /></a><br />
Так как мы бу­дем ис­поль­зо­вать за­про­сы N1QL, нам по­на­до­бит­ся как ми­ни­мум один ин­декс в хра­ни­ли­ще. Его мож­но со­здать несколь­ки­ми спо­со­ба­ми: с по­мо­щью Couchbase Query Workbench или че­рез обо­лоч­ку CBQ. За­прос со­зда­ния ин­дек­са бу­дет при­мер­но та­ким:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">CREATE PRIMARY INDEX ON `bucket-name` USING GSI;</pre></div>
<p>Для боль­ших при­ло­же­ний мож­но со­здать несколь­ко ин­декс­ных по­лей.</p>

<p><a href="https://gifyu.com/image/SDhA"><img src="https://gifyu.com/images/couchbase-create-primary-index.gif" alt="Разработка: couchbase-create-primary-index.gif" /></a><br />
Пе­рей­дём к мо­де­ли дан­ных. На­ше при­ло­же­ние бу­дет при­ни­мать длин­ный URL и от­да­вать со­от­вет­ству­ю­щий ко­рот­кий URL. Оба URL бу­дут хра­нит­ся в ба­зе дан­ных. Вот как при­мер­но мо­жет вы­гля­деть мо­дель дан­ных:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">{
    &#34;id&#34;: &#34;5Qp8oLmWX&#34;,
    &#34;longUrl&#34;: &#34;https://www.thepolyglotdeveloper.com/2016/08/using-couchbase-server-golang-web-application/&#34;,
    &#34;shortUrl&#34;: &#34;http://localhost:3000/5Qp8oLmWX&#34;
}</pre></div>
<p>id &mdash; это уни­каль­ный ко­рот­кий хэш, при­вя­зан­ный к кон­крет­но­му URL, он бу­дет вы­да­вать­ся ав­то­ма­ти­че­ски для лю­бо­го ад­ре­са.</p>

<p>Те­перь нач­нём раз­ра­бот­ку при­ло­же­ния.</p>

<h6 id="со-зда-ние-restful-при-ло-же-ния-на-golang">Со­зда­ние RESTful при­ло­же­ния на Golang</h6>

<p>Мы со­зда­дим RESTful API, но пе­ред этим нуж­но опре­де­лить­ся с ло­ги­кой каж­дой ко­неч­ной точ­ки, а та­к­же по­за­бо­тить­ся о на­дёж­ной ра­бо­те при­ло­же­ния.</p>

<p>Со­зда­дим но­вый про­ект Go. Я на­зо­ву его про­сто main.go и он бу­дет рас­по­ло­жен в $GOPATH/src/github.com/nraboy/shorturl. До­бавь­те сле­ду­ю­щий код в файл $GOPATH/src/github.com/nraboy/shorturl/main.go:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#fff;font-weight:bold">package</span> main

<span style="color:#fff;font-weight:bold">import</span> (
    <span style="color:#0ff;font-weight:bold">&#34;net/http&#34;</span>
    <span style="color:#0ff;font-weight:bold">&#34;github.com/couchbase/gocb&#34;</span>
    <span style="color:#0ff;font-weight:bold">&#34;github.com/gorilla/mux&#34;</span>
)

<span style="color:#fff;font-weight:bold">var</span> bucket *gocb.Bucket
<span style="color:#fff;font-weight:bold">var</span> bucketName <span style="color:#fff;font-weight:bold">string</span>

<span style="color:#fff;font-weight:bold">func</span> ExpandEndpoint(w http.ResponseWriter, req *http.Request) { }

<span style="color:#fff;font-weight:bold">func</span> CreateEndpoint(w http.ResponseWriter, req *http.Request) { }

<span style="color:#fff;font-weight:bold">func</span> RootEndpoint(w http.ResponseWriter, req *http.Request) { }

<span style="color:#fff;font-weight:bold">func</span> main() {
    router := mux.NewRouter()
    cluster, _ := gocb.Connect(<span style="color:#0ff;font-weight:bold">&#34;couchbase://localhost&#34;</span>)
    bucketName = <span style="color:#0ff;font-weight:bold">&#34;example&#34;</span>
    bucket, _ = cluster.OpenBucket(bucketName, <span style="color:#0ff;font-weight:bold">&#34;&#34;</span>)
    router.HandleFunc(<span style="color:#0ff;font-weight:bold">&#34;/{id}&#34;</span>, RootEndpoint).Methods(<span style="color:#0ff;font-weight:bold">&#34;GET&#34;</span>)
    router.HandleFunc(<span style="color:#0ff;font-weight:bold">&#34;/expand/&#34;</span>, ExpandEndpoint).Methods(<span style="color:#0ff;font-weight:bold">&#34;GET&#34;</span>)
    router.HandleFunc(<span style="color:#0ff;font-weight:bold">&#34;/create&#34;</span>, CreateEndpoint).Methods(<span style="color:#0ff;font-weight:bold">&#34;PUT&#34;</span>)
    log.Fatal(http.ListenAndServe(<span style="color:#0ff;font-weight:bold">&#34;:12345&#34;</span>, router))
}</pre></div>
<p>Рас­смот­рим по­дроб­но что мы сде­ла­ли здесь. Мы им­пор­ти­ро­ва­ли Couchbase Go SDK и ути­ли­ту Mux, с по­мо­щью ко­то­рой так лег­ко со­зда­вать RESTful API. Уста­но­вить эти па­ке­ты мож­но так:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">go get github.com/couchbase/gocb
go get github.com/gorilla/mux</pre></div>
<p>За­тем нам нуж­ны две пе­ре­мен­ных, ко­то­рые бу­дут до­ступ­ны во всём фай­ле main.go, в них мы бу­дем хра­нить ко­пию от­кры­то­го хра­ни­ли­ща и на­зва­ние это­го хра­ни­ли­ща.</p>

<p>В ме­то­де main мы на­стра­и­ва­ем ро­у­тер, со­еди­ня­ем­ся с ло­каль­ным кла­сте­ром Couchbase и от­кры­ва­ем на­ше хра­ни­ли­ще. В на­шем слу­чае от­кры­ва­ет­ся хра­ни­ли­ще example, ко­то­рое уже есть в кла­сте­ре.</p>

<p>Да­лее мы со­зда­ём три ро­у­та, пред­став­ля­ю­щие ко­неч­ные точ­ки API. Ро­ут /create при­ни­ма­ет длин­ный URL и от­да­ёт ко­рот­кий. /expand де­ла­ет об­рат­ное пре­об­ра­зо­ва­ние. И, на­ко­нец, ро­ут /root при­ни­ма­ет хэш и пе­ре­ки­ды­ва­ет на нуж­ную стра­ни­цу.</p>

<h6 id="ло-ги-ка-api">Ло­ги­ка API</h6>

<p>Пе­ред тем как со­здать ло­ги­ку, опре­де­лим мо­дель дан­ных, это бу­дет струк­ту­ра дан­ных Go:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">type MyUrl struct {
    ID       string `json:&#34;id,omitempty&#34;`
    LongUrl  string `json:&#34;longUrl,omitempty&#34;`
    ShortUrl string `json:&#34;shortUrl,omitempty&#34;`
}</pre></div>
<p>В струк­ту­ре MyUrl есть три по­ля, пред­став­ля­ю­щие свой­ством JSON.</p>

<p>До­ба­вим са­мую слож­ную ко­неч­ную точ­ку /create:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">func CreateEndpoint(w http.ResponseWriter, req *http.Request) {
    var url MyUrl
    _ = json.NewDecoder(req.Body).Decode(&amp;url)
    var n1qlParams []interface{}
    n1qlParams = append(n1qlParams, url.LongUrl)
    query := gocb.NewN1qlQuery(&#34;SELECT `&#34; + bucketName + &#34;`.* FROM `&#34; + bucketName + &#34;` WHERE longUrl = $1&#34;)
    rows, err := bucket.ExecuteN1qlQuery(query, n1qlParams)
    if err != nil {
        w.WriteHeader(401)
        w.Write([]byte(err.Error()))
        return
    }
    var row MyUrl
    rows.One(&amp;row)
    if row == (MyUrl{}) {
        hd := hashids.NewData()
        h := hashids.NewWithData(hd)
        now := time.Now()
        url.ID, _ = h.Encode([]int{int(now.Unix())})
        url.ShortUrl = &#34;http://localhost:12345/&#34; + url.ID
        bucket.Insert(url.ID, url, 0)
    } else {
        url = row
    }
    json.NewEncoder(w).Encode(url)
}</pre></div>
<p>Ро­ут /create бу­дет до­сту­пен че­рез за­прос PUT. В этом за­про­се бу­дет ука­зан длин­ный URL в фор­ма­те JSON. Для удоб­ства мы бу­дем хра­нить весь JSON объ­ект в объ­ек­те MyUrl.<br />
Та­к­же необ­хо­ди­мо убе­дит­ся, что мы хра­ним толь­ко уни­каль­ные длин­ные URL, а это зна­чит, что каж­дый ко­рот­кий URL дол­жен быть та­к­же уни­каль­ным. По­это­му вна­ча­ле мы про­ве­ря­ем ба­зу дан­ных на су­ще­ство­ва­ние та­ко­го URL:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">var n1qlParams []interface{}
n1qlParams = append(n1qlParams, url.LongUrl)
query := gocb.NewN1qlQuery(&#34;SELECT `&#34; + bucketName + &#34;`.* FROM `&#34; + bucketName + &#34;` WHERE longUrl = $1&#34;)
rows, err := bucket.ExecuteN1qlQuery(query, n1qlParams)</pre></div>
<p>Здесь мы ис­поль­зу­ем па­ра­мет­ри­зо­ван­ный за­прос N1QL для про­вер­ки. При ошиб­ках в за­про­се мы вы­ве­дем их на экран.</p>

<p>Ес­ли оши­бок не бу­дет, мы по­лу­чим ре­зуль­тат за­про­са и уви­дим, не пу­стой ли он. Ес­ли он пуст, зна­чит нам нуж­но уко­ро­тить URL и со­хра­нить в ба­зе.</p>

<p>Мож­но раз­ра­бо­тать соб­ствен­ный ал­го­ритм хэ­ши­ро­ва­ния, но я пред­по­чи­таю ис­поль­зо­вать па­кет <a href="http://hashids.org/">Hashids</a>.</p>

<p>Пе­ред ис­поль­зо­ва­ни­ем, уста­но­вим его:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">go get github.com/speps/go-hashids</pre></div>
<p>Для по­лу­че­ния уни­каль­но­го ко­рот­ко­го URL мы бу­дем де­лать хэш из те­ку­ще­го вре­ме­ни:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">hd := hashids.NewData()
h := hashids.NewWithData(hd)
now := time.Now()
url.ID, _ = h.Encode([]int{int(now.Unix())})</pre></div>
<p>По­сле по­лу­че­ния уни­каль­но­го хэ­ша со­хра­ним его в MyUrl вме­сте с ко­рот­ким URL. А длин­ный URL уже хра­нит­ся в ней.</p>

<p>Пе­рей­дём к /expand, вот код для ро­у­та:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">func ExpandEndpoint(w http.ResponseWriter, req *http.Request) {
    var n1qlParams []interface{}
    query := gocb.NewN1qlQuery(&#34;SELECT `&#34; + bucketName + &#34;`.* FROM `&#34; + bucketName + &#34;` WHERE shortUrl = $1&#34;)
    params := req.URL.Query()
    n1qlParams = append(n1qlParams, params.Get(&#34;shortUrl&#34;))
    rows, _ := bucket.ExecuteN1qlQuery(query, n1qlParams)
    var row MyUrl
    rows.One(&amp;row)
    json.NewEncoder(w).Encode(row)
}</pre></div>
<p>Здесь по­чти та­кой же код, как и у /create, но есть от­ли­чия: вме­сто N1QL за­про­са, мы пе­ре­да­ём ко­рот­кий URL и пе­ре­да­ём па­ра­мет­ры в за­про­се вме­сто то­го, что­бы пе­ре­да­вать пол­ный за­прос.</p>

<p>Те­перь остал­ся ро­ут root. Мы мо­жем рас­смат­ри­вать все за­про­сы к точ­ке root как ко­рот­кие URL:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">func RootEndpoint(w http.ResponseWriter, req *http.Request) {
    params := mux.Vars(req)
    var url MyUrl
    bucket.Get(params[&#34;id&#34;], &amp;url)
    http.Redirect(w, req, url.LongUrl, 301)
}</pre></div>
<p>По­сле по­ис­ка по id, бу­дет сде­лан 301 ре­ди­рект на длин­ный URL.</p>

<h6 id="пол-ный-код-про-ек-та">Пол­ный код про­ек­та</h6>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#fff;font-weight:bold">package</span> main

<span style="color:#fff;font-weight:bold">import</span> (
    <span style="color:#0ff;font-weight:bold">&#34;encoding/json&#34;</span>
    <span style="color:#0ff;font-weight:bold">&#34;log&#34;</span>
    <span style="color:#0ff;font-weight:bold">&#34;net/http&#34;</span>
    <span style="color:#0ff;font-weight:bold">&#34;time&#34;</span>

    <span style="color:#0ff;font-weight:bold">&#34;github.com/couchbase/gocb&#34;</span>
    <span style="color:#0ff;font-weight:bold">&#34;github.com/gorilla/mux&#34;</span>
    <span style="color:#0ff;font-weight:bold">&#34;github.com/speps/go-hashids&#34;</span>
)

<span style="color:#fff;font-weight:bold">type</span> MyUrl <span style="color:#fff;font-weight:bold">struct</span> {
    ID       <span style="color:#fff;font-weight:bold">string</span> <span style="color:#0ff;font-weight:bold">`json:&#34;id,omitempty&#34;`</span>
    LongUrl  <span style="color:#fff;font-weight:bold">string</span> <span style="color:#0ff;font-weight:bold">`json:&#34;longUrl,omitempty&#34;`</span>
    ShortUrl <span style="color:#fff;font-weight:bold">string</span> <span style="color:#0ff;font-weight:bold">`json:&#34;shortUrl,omitempty&#34;`</span>
}

<span style="color:#fff;font-weight:bold">var</span> bucket *gocb.Bucket
<span style="color:#fff;font-weight:bold">var</span> bucketName <span style="color:#fff;font-weight:bold">string</span>

<span style="color:#fff;font-weight:bold">func</span> ExpandEndpoint(w http.ResponseWriter, req *http.Request) {
    <span style="color:#fff;font-weight:bold">var</span> n1qlParams []<span style="color:#fff;font-weight:bold">interface</span>{}
    query := gocb.NewN1qlQuery(<span style="color:#0ff;font-weight:bold">&#34;SELECT `&#34;</span> + bucketName + <span style="color:#0ff;font-weight:bold">&#34;`.* FROM `&#34;</span> + bucketName + <span style="color:#0ff;font-weight:bold">&#34;` WHERE shortUrl = $1&#34;</span>)
    params := req.URL.Query()
    n1qlParams = <span style="color:#fff;font-weight:bold">append</span>(n1qlParams, params.Get(<span style="color:#0ff;font-weight:bold">&#34;shortUrl&#34;</span>))
    rows, _ := bucket.ExecuteN1qlQuery(query, n1qlParams)
    <span style="color:#fff;font-weight:bold">var</span> row MyUrl
    rows.One(&amp;row)
    json.NewEncoder(w).Encode(row)
}

<span style="color:#fff;font-weight:bold">func</span> CreateEndpoint(w http.ResponseWriter, req *http.Request) {
    <span style="color:#fff;font-weight:bold">var</span> url MyUrl
    _ = json.NewDecoder(req.Body).Decode(&amp;url)
    <span style="color:#fff;font-weight:bold">var</span> n1qlParams []<span style="color:#fff;font-weight:bold">interface</span>{}
    n1qlParams = <span style="color:#fff;font-weight:bold">append</span>(n1qlParams, url.LongUrl)
    query := gocb.NewN1qlQuery(<span style="color:#0ff;font-weight:bold">&#34;SELECT `&#34;</span> + bucketName + <span style="color:#0ff;font-weight:bold">&#34;`.* FROM `&#34;</span> + bucketName + <span style="color:#0ff;font-weight:bold">&#34;` WHERE longUrl = $1&#34;</span>)
    rows, err := bucket.ExecuteN1qlQuery(query, n1qlParams)
    <span style="color:#fff;font-weight:bold">if</span> err != <span style="color:#fff;font-weight:bold">nil</span> {
        w.WriteHeader(<span style="color:#ff0;font-weight:bold">401</span>)
        w.Write([]<span style="color:#fff;font-weight:bold">byte</span>(err.Error()))
        <span style="color:#fff;font-weight:bold">return</span>
    }
    <span style="color:#fff;font-weight:bold">var</span> row MyUrl
    rows.One(&amp;row)
    <span style="color:#fff;font-weight:bold">if</span> row == (MyUrl{}) {
        hd := hashids.NewData()
        h := hashids.NewWithData(hd)
        now := time.Now()
        url.ID, _ = h.Encode([]<span style="color:#fff;font-weight:bold">int</span>{<span style="color:#fff;font-weight:bold">int</span>(now.Unix())})
        url.ShortUrl = <span style="color:#0ff;font-weight:bold">&#34;http://localhost:12345/&#34;</span> + url.ID
        bucket.Insert(url.ID, url, <span style="color:#ff0;font-weight:bold">0</span>)
    } <span style="color:#fff;font-weight:bold">else</span> {
        url = row
    }
    json.NewEncoder(w).Encode(url)
}

<span style="color:#fff;font-weight:bold">func</span> RootEndpoint(w http.ResponseWriter, req *http.Request) {
    params := mux.Vars(req)
    <span style="color:#fff;font-weight:bold">var</span> url MyUrl
    bucket.Get(params[<span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>], &amp;url)
    http.Redirect(w, req, url.LongUrl, <span style="color:#ff0;font-weight:bold">301</span>)
}

<span style="color:#fff;font-weight:bold">func</span> main() {
    router := mux.NewRouter()
    cluster, _ := gocb.Connect(<span style="color:#0ff;font-weight:bold">&#34;couchbase://localhost&#34;</span>)
    bucketName = <span style="color:#0ff;font-weight:bold">&#34;example&#34;</span>
    bucket, _ = cluster.OpenBucket(bucketName, <span style="color:#0ff;font-weight:bold">&#34;&#34;</span>)
    router.HandleFunc(<span style="color:#0ff;font-weight:bold">&#34;/{id}&#34;</span>, RootEndpoint).Methods(<span style="color:#0ff;font-weight:bold">&#34;GET&#34;</span>)
    router.HandleFunc(<span style="color:#0ff;font-weight:bold">&#34;/expand/&#34;</span>, ExpandEndpoint).Methods(<span style="color:#0ff;font-weight:bold">&#34;GET&#34;</span>)
    router.HandleFunc(<span style="color:#0ff;font-weight:bold">&#34;/create&#34;</span>, CreateEndpoint).Methods(<span style="color:#0ff;font-weight:bold">&#34;PUT&#34;</span>)
    log.Fatal(http.ListenAndServe(<span style="color:#0ff;font-weight:bold">&#34;:12345&#34;</span>, router))
}</pre></div>
<p>По­сле за­пус­ка при­ло­же­ния, оно бу­дет при­ни­мать за­про­сы на <a href="http://localhost:12345">localhost:12345</a></p>

<p>Этот же урок в ви­део (на ан­глий­ском): <a href="https://youtu.be/OVBvOuxbpHA">youtu.be/OVBvOuxbpHA</a></p>

<p>По ма­те­ри­а­лам: <a href="https://www.thepolyglotdeveloper.com/2016/12/create-a-url-shortener-with-golang-and-couchbase-nosql/">«Create A URL Shortener With Golang And Couchbase NoSQL»</a> by Nic Raboy</p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Создание hacker news с angular 2 cli, rxjs и webpack</turbo:topic>
      <link>https://fokusov.com/posts/sozdanie-hacker-news-s-angular-2-cli-rxjs-i-webpack/</link>
      <pubDate>Mon, 13 Mar 2017 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ 

<p><img src="img/x65e3afe142.jpg.pagespeed.ic.M1vevGVti6.jpg" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack" /><br />
Ес­ли вы ко­гда-ли­бо со­зда­ва­ли при­ло­же­ния с Angular 2, то зна­е­те, что пер­во­на­чаль­ная на­строй­ка про­ек­та от­ни­ма­ет нема­ло вре­ме­ни. К сча­стью, ко­ман­да Angular со­зда­ла <a href="https://cli.angular.io/">Angular CLI</a> &mdash; ути­ли­ту ко­манд­ной стро­ки, об­лег­ча­ю­щую эту за­да­чу.</p>

<p>В этой ста­тье мы по­стро­им кли­ен­та Hacker News, ис­поль­зуя Angular CLI, RxJS Observables и Webpack как за­груз­чик мо­ду­лей.</p>

<p><a href="https://angular2-hn.firebaseapp.com/">Го­то­вое при­ло­же­ние.</a><br />
<a href="https://github.com/housseindjirdeh/angular2-hn/tree/version-1">Ис­ход­ный код.</a></p>

<p><img src="https://i.imgur.com/3gIhXqC.gif" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack" /><br />
Мы по­сте­пен­но, шаг за ша­гом, прой­дём весь про­цесс по­стро­е­ния при­ло­же­ния и я по­ста­ра­юсь по­дроб­но объ­яс­нять важ­ные мо­мен­ты по хо­ду де­ла, а та­к­же сде­лан­ные мной ошиб­ки и спо­со­бы их ре­ше­ния.</p>

<p>Вот крат­кий спи­сок то­го, что нам пред­сто­ит сде­лать:</p>

<ol>
<li>Мы нач­нём с по­стро­е­ния кар­ка­са при­ло­же­ния, глав­ной стра­ни­цы Hacker News</li>
<li>За­тем под­клю­чим Observable Data Service для асин­хрон­ной за­груз­ки дан­ных</li>
<li>До­ба­вим ро­утинг с <a href="https://angular.io/docs/ts/latest/guide/router.html">Angular Component Router</a> для по­стро­е­ния на­ви­га­ции меж­ду стра­ни­ца­ми и ви­да­ми то­пи­ков</li>
<li>И, на­ко­нец, до­ба­вим ро­уты что­бы поль­зо­ва­тель мог пе­рей­ти к ком­мен­та­ри­ям к то­пи­ку и в про­фи­ли поль­зо­ва­те­лей.</li>
</ol>

<h5 id="при-сту-пим">При­сту­пим</h5>

<p>Убе­ди­тесь, что у вас уста­нов­лен Node и npm, за­тем уста­но­ви­те CLI в тер­ми­на­ле:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">npm install -g @angular/cli</pre></div>
<p>Со­зда­дим и за­пу­стим при­ло­же­ние:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">ng new angular2-hn
cd angular2-hn
ng serve</pre></div>
<p>От­крой­те бра­у­зер по ад­ре­су <a href="https://localhost:4200/">localhost:4200/</a></p>

<p><img src="img/x31c3b1585c.png.pagespeed.ic.7RVek_scrv.png" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 1" /><br />
Кру­то, да?</p>

<p>На­стро­им <a href="http://sass-lang.com/">Sass</a> как пре­про­цес­сор CSS:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">ng set defaults.styleExt scss</pre></div>
<p>Со­зда­дим пер­вый ком­по­нент <strong>HeaderComponent</strong></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">ng generate component Header</pre></div>
<p>Бу­дет со­зда­на пап­ка header, со­дер­жа­щая та­кие фай­лы:</p>

<ul>
<li>header.​com​pone​nt.​scss</li>
<li>header.​com​pone​nt.​html</li>
<li>header.​com​pone​nt.​ts</li>
<li>header.​com​pone​nt.​spec.​ts</li>
</ul>

<p>По­смот­рим на файл app.​module.​ts и уви­дим, что наш ком­по­нент уже за­де­кла­ри­ро­ван:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app.module.ts

// ...
import { AppComponent } from &#39;./app.component&#39;;
import { HeaderComponent } from &#39;./header/header.component&#39;;

@NgModule({
  declarations: [
    AppComponent,
    HeaderComponent
  ],
//...</pre></div>
<p>А взгля­нув в файл header.​com​pone​nt.​ts, вы уви­ди­те, что се­лек­тор ком­по­нен­тов &mdash; app-header. До­ба­вим его в наш кор­не­вой ком­по­нент, app.​com​pone​nt.​ts.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app.component.html --&gt;

&lt;app-header&gt;&lt;/app-header&gt;</pre></div>
<p>За­пу­стим при­ло­же­ние. Ком­по­нент header за­гру­зил­ся нор­маль­но:</p>

<p><img src="img/x282de552aa.png.pagespeed.ic.xpD_nFEGpi.png" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 1" /><br />
Су­пер. Те­перь до­ба­вим кое-ка­кую раз­мет­ку и сти­ли.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app.component.html --&gt;

&lt;div id=&#34;wrapper&#34;&gt;
  &lt;app-header&gt;&lt;/app-header&gt;
&lt;/div&gt;</pre></div>
<p>Сти­ли из фай­ла app.​com​pone​nt.​scss мо­же­те ска­чать <a href="https://github.com/housseindjirdeh/angular2-hn/blob/initial-setup/src/app/app.component.scss">здесь</a>. Пе­рей­дём к header.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- header.component.html --&gt;

&lt;header id=&#34;header&#34;&gt;
  &lt;a class=&#34;home-link&#34; href=&#34;https://fokusov.com/&#34;&gt;
    &lt;img class=&#34;logo&#34; src=&#34;https://i.imgur.com/J303pQ4.png&#34; alt=&#34;Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 1&#34; /&gt;
  &lt;/a&gt;
  &lt;div class=&#34;header-text&#34;&gt;
    &lt;div class=&#34;left&#34;&gt;
      &lt;h1 class=&#34;name&#34;&gt;
        &lt;a href=&#34;https://fokusov.com/&#34;&gt;Angular 2 HN&lt;/a&gt;
      &lt;/h1&gt;
      &lt;span class=&#34;header-nav&#34;&gt;
        &lt;a href=&#34;&#34;&gt;new&lt;/a&gt;
        &lt;span class=&#34;divider&#34;&gt;
          |
        &lt;/span&gt;
        &lt;a href=&#34;&#34;&gt;show&lt;/a&gt;
        &lt;span class=&#34;divider&#34;&gt;
          |
        &lt;/span&gt;
        &lt;a href=&#34;&#34;&gt;ask&lt;/a&gt;
        &lt;span class=&#34;divider&#34;&gt;
          |
        &lt;/span&gt;
        &lt;a href=&#34;&#34;&gt;jobs&lt;/a&gt;
      &lt;/span&gt;
    &lt;/div&gt;
    &lt;div class=&#34;info&#34;&gt;
      Built with &lt;a href=&#34;https://cli.angular.io/&#34; target=&#34;_blank&#34;&gt;Angular CLI&lt;/a&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/header&gt;</pre></div>
<p>Сти­ли это­го ком­по­нен­та мож­но ска­чать <a href="https://github.com/housseindjirdeh/angular2-hn/blob/initial-setup/src/app/header/header.component.scss">здесь</a>. За­пу­стим при­ло­же­ние:</p>

<p><img src="img/x7c2f995f0c.png.pagespeed.ic.EyV2l7qFOd.png" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 1" /></p>

<p>На­ше при­ло­же­ние долж­но быть от­зыв­чи­вым. По­смот­рим, как оно вы­гля­дит сей­час на умень­шен­ном экране:</p>

<p><img src="img/xcb0f2ba0ee.png.pagespeed.ic.s3IGwPYMnR.png" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 1" /><br />
Но у нас с края по­явил­ся непред­ви­ден­ный от­ступ. Это из-за то­го, что эле­мент body име­ет от­ступ по-умол­ча­нию (че­рез margin):</p>

<p><img src="img/xa10a8b3ba8.png.pagespeed.ic.XA-I-KxIqv.png" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 1" /><br />
Но ес­ли от­крыть app.​com​pone​nt.​scss, там ука­за­но пра­ви­ло margin: 0 для экра­нов мень­ше 768px:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$mobile-only: &#34;only screen and (max-width : 768px)&#34;;

body {
  margin-bottom: 0;

  @media #{$mobile-only} {
    margin: 0;
  }
}</pre></div>
<p>Так по­че­му же оно так ра­бо­та­ет? Это из-за спо­со­ба, ко­то­рым Angular ин­кап­су­ли­ру­ет CSS-сти­ли ком­по­нен­та. Не бу­дем вда­вать­ся в де­та­ли, но есть три спо­со­ба, ко­то­рые мо­жет ис­поль­зо­вать Angular для это­го:</p>

<ul>
<li>None: Angular ни­че­го не пред­при­ни­ма­ет &mdash; ни ин­кап­су­ля­ции, ни Shadow DOM, про­сто обыч­ная за­груз­ка сти­лей.</li>
<li>Emulated: Angular эму­ли­ру­ет по­ве­де­ние Shadow DOM. Это спо­соб по-умол­ча­нию.</li>
<li>Native: Angular ис­поль­зу­ет на­тив­ный Shadow DOM бра­у­зе­ра (толь­ко в бра­у­зе­рах, име­ю­щих со­от­вет­ству­ю­щую <a href="http://caniuse.com/#feat=shadowdom">под­держ­ку</a>).<br />
В кор­не­вом ком­по­нен­те мы до­бав­ля­ем сти­ли эле­мен­ту body, но оно не ра­бо­та­ет, по­то­му что мы не ука­за­ли Angular не при­ме­нять ни­ка­ких дей­ствий к пред­став­ле­нию ком­по­нен­та:</li>
</ul>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app.component.ts

import { Component, ViewEncapsulation } from &#39;@angular/core&#39;;

@Component({
  selector: &#39;app-root&#39;,
  encapsulation: ViewEncapsulation.None,
  templateUrl: &#39;./app.component.html&#39;,
  styleUrls: [&#39;./app.component.scss&#39;]
})

export class AppComponent {
}</pre></div>
<p>Пе­ре­за­пу­стим при­ло­же­ние и по­смот­рим на него. Те­перь сти­ли при­ме­ни­лись как и долж­но.</p>

<p><img src="img/x5701c78004.png.pagespeed.ic.nLSgXqKyxj.png" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 1" /></p>

<h6 id="несколь-ко-ком-по-нен-тов">Несколь­ко ком­по­нен­тов</h6>

<p>До­ба­вим ещё па­ру ком­по­нен­тов, Stories и Footer. Stories пред­став­ля­ют то­пи­ки в Hacker News, и мы нач­нём с кар­ка­са, до­ба­вив в него упо­ря­до­чен­ный спи­сок.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">ng g component Stories</pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// stories.component.ts

import { Component, OnInit } from &#39;@angular/core&#39;;

@Component({
  selector: &#39;app-stories&#39;,
  templateUrl: &#39;./stories.component.html&#39;,
  styleUrls: [&#39;./stories.component.scss&#39;]
})

export class StoriesComponent implements OnInit {
  items: number[];

  constructor() {
    this.items = Array(30);
  }

  ngOnInit() {
  }
}</pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- stories.component.html --&gt;

&lt;div class=&#34;main-content&#34;&gt;
  &lt;ol&gt;
    &lt;li *ngFor=&#34;let item of items; let i = index&#34; class=&#34;post&#34;&gt;
      Story #{{i}}
    &lt;/li&gt;
  &lt;/ol&gt;
  &lt;div class=&#34;nav&#34;&gt;
    &lt;a href=&#34;&#34; class=&#34;prev&#34;&gt;
      ‹ Prev
    &lt;/a&gt;
    &lt;a href=&#34;&#34; class=&#34;more&#34;&gt;
      More ›
    &lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div>
<p>Сти­ли для Stories мож­но взять <a href="https://github.com/housseindjirdeh/angular2-hn/blob/initial-setup/src/app/stories/stories.component.scss">здесь</a>. Под­вал стра­ни­цы очень про­стой (сти­ли для него ска­чай­те <a href="https://github.com/housseindjirdeh/angular2-hn/blob/initial-setup/src/app/footer/footer.component.scss">тут</a>).</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">ng g component Footer</pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- footer.component.html --&gt;

&lt;div id=&#34;footer&#34;&gt;
    &lt;p&gt;Show this project some ❤ on
      &lt;a href=&#34;https://github.com/housseindjirdeh/angular2-hn&#34; target=&#34;_blank&#34;&gt;
        GitHub
      &lt;/a&gt;
    &lt;/p&gt;
&lt;/div&gt;</pre></div>
<p>Об­но­вим кор­не­вой ком­по­нент, что­бы уви­деть до­бав­лен­ные ком­по­нен­ты:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app.component.html --&gt;

&lt;div id=&#34;wrapper&#34;&gt;
  &lt;app-header&gt;&lt;/app-header&gt;
  &lt;app-stories&gt;&lt;/app-stories&gt;
  &lt;app-footer&gt;&lt;/app-footer&gt;
&lt;/div&gt;</pre></div>
<p>Вот так те­перь вы­гля­дит при­ло­же­ние:</p>

<p><img src="img/x316b368554.png.pagespeed.ic.yEdR5XM2D2.png" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 1" /><br />
Так как каж­дый то­пик, или эле­мент, бу­дет иметь соб­ствен­ные ат­ри­бу­ты, име­ет смысл со­здать от­дель­ный ком­по­нент для это­го.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">ng g component Item</pre></div>
<p>Ко­гда у нас бу­дут ре­аль­ные дан­ные, нуж­но бу­дет пе­ре­да­вать иден­ти­фи­ка­тор эле­мен­та из ком­по­нен­та то­пи­ков его до­чер­не­му эле­мен­ту. Тем вре­ме­нем, сде­ла­ем пе­ре­да­чу по­зи­ции спис­ка как itemID:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- stories.component.html --&gt;

&lt;div class=&#34;main-content&#34;&gt;
  &lt;ol&gt;
    &lt;li *ngFor=&#34;let item of items; let i = index&#34; class=&#34;post&#34;&gt;
      &lt;item class=&#34;item-block&#34; itemID=&#34;{{ i + 1 }}&#34;&gt;&lt;/item&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  &lt;div class=&#34;nav&#34;&gt;
    &lt;a href=&#34;&#34; class=&#34;prev&#34;&gt;
      ‹ Prev
    &lt;/a&gt;
    &lt;a href=&#34;&#34; class=&#34;more&#34;&gt;
      More ›
    &lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// item.component.ts

import { Component, Input, OnInit } from &#39;@angular/core&#39;;

@Component({
  selector: &#39;item&#39;,
  templateUrl: &#39;./item.component.html&#39;,
  styleUrls: [&#39;./item.component.scss&#39;]
})
export class ItemComponent implements OnInit {
  @Input() itemID: number;

  constructor() { }

  ngOnInit() {
  }

}</pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- item.component.html --&gt;

&lt;p&gt;Story #{{itemID}}&lt;p&gt;</pre></div>
<p>Пе­ре­за­пу­сти­те при­ло­же­ние, всё долж­но ра­бо­тать так же, а это зна­чит, что па­ра­метр по­зи­ции пе­ре­да­ёт­ся успеш­но с <strong>@Input</strong>.</p>

<p>Итак, у нас по­лу­чил­ся от­лич­ный кар­кас глав­ной стра­ни­цы. <a href="https://github.com/housseindjirdeh/angular2-hn/tree/initial-setup">Здесь</a> ис­ход­ный код при­ме­ра на те­ку­щем эта­пе.</p>

<h6 id="rxjs-и-observables">RxJS и Observables</h6>

<p>В Angular 2 для общения с сервером мы используем библиотеку <a href="https://github.com/Reactive-Extensions/RxJS">RxJS</a>, которая возвращает <em>Observable</em> с данными, или <em>асинхронный поток данных</em>. Вероятно, вы уже знакомы с концепцией Promise-ов и как с их помощью можно асинхронно получать данные. Observable получают данные подобно promise-ам, но при этом позволяют следить за потоком данных и реагировать на различные события с ним.</p>

<p><img src="img/x9fc5ddfe63.png.pagespeed.ic.EfMiP5FqLn.png" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 2" /><br />
<a href="https://habrahabr.ru/post/279715/">Источник: Вступление в Реактивное Программирование, которое вы пропустили</a></p>

<p>На диаграмме изображены события, которые происходят при клике на кнопку. Обратите внимание, как этот поток испускает значения (представляющие события клика по кнопке), ошибку, а также событие завершения.</p>

<p>Концепция использования Observable в приложениях известна как Реактивное Программирование.</p>

<h6 id="observable-data-service">Observable Data Service</h6>

<p>Пришло время для получения реальных данных. Для этого нам нужно создать Observable Data Service и включить его в наши компоненты.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">ng g service hackernews-api</pre></div>
<p>Будет создан и настроен файл службы. А ещё нам следует разобраться с тем, как работает Hacker News API. Из <a href="https://github.com/HackerNews/API">документации</a> понятно, что всё (опросы, комментарии, топики, вакансии) это элементы с различающимися id. И информация по конкретному элементу может быть получена по специальному адресу</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// https://hacker-news.firebaseio.com/v0/item/2.json?print=pretty

{
  &#34;by&#34; : &#34;phyllis&#34;,
  &#34;descendants&#34; : 0,
  &#34;id&#34; : 2,
  &#34;kids&#34; : [ 454411 ],
  &#34;score&#34; : 16,
  &#34;time&#34; : 1160418628,
  &#34;title&#34; : &#34;A Student&#39;s Guide to Startups&#34;,
  &#34;type&#34; : &#34;story&#34;,
  &#34;url&#34; : &#34;https://www.paulgraham.com/mit.html&#34;
}</pre></div>
<p>К примеру, если нам нужно получить такие данные, как рейтинги на главной страницы, необходимо использовать специальную конечную точку, близкую к топикам. И лучшие топики можно получить так:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// https://hacker-news.firebaseio.com/v0/topstories.json?print=pretty

[ 12426766, 12426315, 12424656, 12425725, 12426064, 12427341, 12425692, 12425776, 12425324, 12425750, 12425135, 12427073, 12425632, 12423733, 12425720, 12427135, 12425683, 12423794, 12424987, 12423809, 12424738, 12425119, 12426759, 12425711, 12422891, 12424731, 12423742, 12424131, 12424184, 12422833, 12424421, 12426729, 12423373, 12421687, 12427437 ...]</pre></div>
<p>Таким образом, мы получаем список топиков в топе, а затем необходимо пройтись по каждому из них. Приступим.</p>

<p>Включим службу в метаданные provider нашего NgModule:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app.module.ts

//...
import { HackerNewsAPIService } from &#39;./hackernews-api.service&#39;;

@NgModule({
  declarations: [
    ...
   ],
  imports: [
    ...
  ],
  providers: [HackerNewsAPIService],
  bootstrap: [AppComponent]
})
export class AppModule { }</pre></div>
<p>Теперь добавим метод для запроса в неё:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// hackernews-api.service.ts

import { Injectable } from &#39;@angular/core&#39;;
import { Http } from &#39;@angular/http&#39;;
import { Observable } from &#39;rxjs/Observable&#39;;
import &#39;rxjs/add/operator/map&#39;;

@Injectable()
export class HackerNewsAPIService {
  baseUrl: string;

  constructor(private http: Http) {
    this.baseUrl = &#39;https://hacker-news.firebaseio.com/v0&#39;;
  }

  fetchStories(): Observable&lt;any&gt; {
    return this.http.get(`${this.baseUrl}/topstories.json`)
                    .map(response =&gt; response.json());
  }
}</pre></div>
<p>Как мы говорили ранее, вызов http.get возвращает Observable с данными. В fetchStories мы принимаем Observable, а затем map-им его в формат JSON.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// stories.component.ts

import { Component, OnInit } from &#39;@angular/core&#39;;
import { Observable } from &#39;rxjs/Observable&#39;;

import { HackerNewsAPIService } from &#39;../hackernews-api.service&#39;;

@Component({
  selector: &#39;app-stories&#39;,
  templateUrl: &#39;./stories.component.html&#39;,
  styleUrls: [&#39;./stories.component.scss&#39;]
})

export class StoriesComponent implements OnInit {
  items;

  constructor(private _hackerNewsAPIService: HackerNewsAPIService) {}

  ngOnInit() {
    this._hackerNewsAPIService.fetchStories()
                    .subscribe(
                      items =&gt; this.items = items,
                      error =&gt; console.log(&#39;Error fetching stories&#39;));
  }
}</pre></div>
<p>В хуке ngOnInit, который срабатывает при инициализации компонента, мы подписываемся (subscribe) на поток данных и присваиваем атрибуту items то, что нам будет возвращено. А в наше представление мы добавим SlicePipe для вывода только 30 элементов списка из 500, которые нам возвращает запрос.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- stories.component.html --&gt;

&lt;div class=&#34;main-content&#34;&gt;
  &lt;ol&gt;
    &lt;li *ngFor=&#34;let item of items | slice:0:30&#34; class=&#34;post&#34;&gt;
      &lt;item class=&#34;item-block&#34; itemID=&#34;{{ item }}&#34;&gt;&lt;/item&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  &lt;!-- ... --&gt;
&lt;/div&gt;</pre></div>
<p>Запустив приложение, увидим список элементов с их id:</p>

<p><img src="img/xd8829798b1.png.pagespeed.ic.EY0U_aaLWZ.png" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 2" /><br />
Итак, мы получаем идентификатор каждого item, теперь добавим подписку на детали каждого элемента и для этого напишем новый метод:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// hackernews-api.service.ts

//...

fetchItem(id: number): Observable&lt;any&gt; {
  return this.http.get(`${this.baseUrl}/item/${id}.json`)
                  .map(response =&gt; response.json());
}</pre></div>
<p>Немного доработаем компонент item:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// item.component.ts

import { Component, Input, OnInit } from &#39;@angular/core&#39;;

import { HackerNewsAPIService } from &#39;../hackernews-api.service&#39;;

@Component({
  selector: &#39;item&#39;,
  templateUrl: &#39;./item.component.html&#39;,
  styleUrls: [&#39;./item.component.scss&#39;]
})
export class ItemComponent implements OnInit {
  @Input() itemID: number;
  item;

  constructor(private _hackerNewsAPIService: HackerNewsAPIService) {}

  ngOnInit() {
    this._hackerNewsAPIService.fetchItem(this.itemID).subscribe(data =&gt; {
      this.item = data;
    }, error =&gt; console.log(&#39;Could not load item&#39; + this.itemID));
  }
}</pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- item.component.html --&gt;

&lt;div *ngIf=&#34;!item&#34; class=&#34;loading-section&#34;&gt;
  &lt;!-- Сюда можно добавить индикатор загрузки, если очень надо :) &lt;/i&gt; --&gt;
&lt;/div&gt;
&lt;div *ngIf=&#34;item&#34;&gt;
  &lt;div class=&#34;item-laptop&#34;&gt;
    &lt;p&gt;
      &lt;a class=&#34;title&#34; href=&#34;{{item.url}}&#34;&gt;
        {{item.title}}
      &lt;/a&gt;
      &lt;span class=&#34;domain&#34;&gt;{{item.url | domain}}&lt;/span&gt;
    &lt;/p&gt;
    &lt;div class=&#34;subtext-laptop&#34;&gt;
      {{item.score}} points by
      &lt;a href=&#34;&#34;&gt;{{item.by}}&lt;/a&gt;
      {{ (item.time | amFromUnix) | amTimeAgo }}
      &lt;a href=&#34;&#34;&gt;
        &lt;span *ngIf=&#34;item.descendants !== 0&#34;&gt;
          {{item.descendants}}
          &lt;span *ngIf=&#34;item.descendants === 1&#34;&gt;comment&lt;/span&gt;
          &lt;span *ngIf=&#34;item.descendants &gt; 1&#34;&gt;comments&lt;/span&gt;
        &lt;/span&gt;
        &lt;span *ngIf=&#34;item.descendants === 0&#34;&gt;discuss&lt;/span&gt;
      &lt;/a&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&#34;item-mobile&#34;&gt;
    &lt;!-- Разметка только для мобильных устройств --&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div>
<p>Здесь всё просто: мы подписываемся на соответствующий поток для каждого элемента. В разметке у нас есть индикатор загрузки, который виден до получения данных с сервера. При загрузке элемента из Observable будут показаны его детали. <a href="https://github.com/housseindjirdeh/angular2-hn/tree/first-page/src/app/item">Здесь</a> можно скачать файлы стилей компонента.</p>

<p>Код приложения на текущем этапе можно скачать <a href="https://github.com/housseindjirdeh/angular2-hn/tree/first-page">здесь</a>. Перезапустите приложение и увидим такую картину:</p>

<p><img src="img/xabc2f5e35b.png.pagespeed.ic.gKiVQYiXYG.png" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 2" /></p>

<h6 id="скорость-работы">Скорость работы</h6>

<p>А теперь взглянем на страничку запросов, которые приходят при загрузке главной страницы приложения.</p>

<p><img src="https://tehnojam.pro/uploads/images/00/00/24/2017/03/16/xa43251c42c.png.pagespeed.ic.YnIc8w4g2q.png" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 3" /></p>

<p>Ух ты, 31 запрос и 20.8КБ передано за 546 мс. Это почти в пять раз медленне загрузки главной страницы Hacker News и вдвое больший объём данных при загрузке топиков. Это очень медленно. Даже приняв во внимание, что мы грузим главную страницу один раз и можем смириться с полусекундной задержкой, то загрузка комментариев к популярной новости займёт очень много времени!<br />
Вы можете увидеть как я загружаю новость с 2000 комментариев <a href="https://media.giphy.com/media/3o6Zt9ZBEDjwiPDjz2/giphy.gif">тут</a>. Если вам лень смотреть гифку, то вот статистика: там 741 запрос, 1,5 МБ и 90 сек для загрузки примерно 700 комментариев (я не стал ждать пока все комментарии загрузятся).</p>

<h6 id="вносим-коррективы">Вносим коррективы</h6>

<p>Теперь мы видим, что выбрали не лучшее решение, используя множественные сетевые запросы для загрузки элементов и их содержимого. После недолгого поиска, я нашёл <a href="https://github.com/cheeaun/node-hnapi">неофициальный API</a>, возвращающий элемент и его детали одним запросом.</p>

<p>Вот пример ответа по запросу списка популярных историй:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// https://node-hnapi.herokuapp.com/news?page=1

[
  {
    &#34;id&#34;: 12469856,
    &#34;title&#34;: &#34;Owl Lisp -- A purely functional Scheme that compiles to C&#34;,
    &#34;points&#34;: 57,
    &#34;user&#34;: &#34;rcarmo&#34;,
    &#34;time&#34;: 1473524669,
    &#34;time_ago&#34;: &#34;2 hours ago&#34;,
    &#34;comments_count&#34;: 9,
    &#34;type&#34;: &#34;link&#34;,
    &#34;url&#34;: &#34;https://github.com/aoh/owl-lisp&#34;,
    &#34;domain&#34;: &#34;github.com&#34;
  },
  {
    &#34;id&#34;: 12469823,
    &#34;title&#34;: &#34;How to Write Articles and Essays Quickly and Expertly&#34;,
    &#34;points&#34;: 52,
    &#34;user&#34;: &#34;bemmu&#34;,
    &#34;time&#34;: 1473524142,
    &#34;time_ago&#34;: &#34;2 hours ago&#34;,
    &#34;comments_count&#34;: 6,
    &#34;type&#34;: &#34;link&#34;,
    &#34;url&#34;: &#34;https://www.downes.ca/post/38526&#34;,
    &#34;domain&#34;: &#34;downes.ca&#34;
  },
  ...
]</pre></div>
<p>Мы видим, что здесь есть и такие атрибуты, как domain и time_ago, это очень круто. И это значит, что мы можем выкинуть файл domain.pipe.ts, созданный ранее, а также удалить библиотеку angular2-moment. И доработаем нашу службу:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// hackernews-api.service.ts

export class HackerNewsAPIService {
  baseUrl: string;

  constructor(private http: Http) {
    this.baseUrl = &#39;https://node-hnapi.herokuapp.com&#39;;
  }

  fetchStories(storyType: string, page: number): Observable&lt;any&gt; {
    return this.http.get(`${this.baseUrl}/${storyType}?page=${page}`)
                    .map(response =&gt; response.json());
  }
}</pre></div>
<p>Так как API не загружает все 500 топиков, нам необходимо будет добавить номер страницы как аргумент. Обратите внимание также на то, как мы передаём storyType &mdash; это позволит нам показывать разные типы топиков, в зависимости от запроса пользователя.</p>

<p>Доработаем компонент stories. Можно начать лишь передав <strong>&lsquo;news&rsquo;</strong> и номер страницы <strong>1</strong> в вызов службы для получения топа:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// stories.component.ts

export class StoriesComponent implements OnInit {
  items;

  constructor(private _hackerNewsAPIService: HackerNewsAPIService) {}

  ngOnInit() {
    this._hackerNewsAPIService.fetchStories(&#39;news&#39;, 1)
                              .subscribe(
                                items =&gt; this.items = items,
                                error =&gt; console.log(&#39;Error fetching stories&#39;));
  }
}</pre></div>
<p>Соответствующая разметка:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- stories.component.html --&gt;

&lt;div class=&#34;loading-section&#34; *ngIf=&#34;!items&#34;&gt;
  &lt;!-- You can add a loading indicator here if you want to :) --&gt;
&lt;/div&gt;
&lt;div *ngIf=&#34;items&#34;&gt;
  &lt;ol&gt;
    &lt;li *ngFor=&#34;let item of items&#34; class=&#34;post&#34;&gt;
      &lt;item class=&#34;item-block&#34; [item]=&#34;item&#34;&gt;&lt;/item&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  &lt;div class=&#34;nav&#34;&gt;
    &lt;a class=&#34;prev&#34;&gt;
      ‹ Prev
    &lt;/a&gt;
    &lt;a class=&#34;more&#34;&gt;
      More ›
    &lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div>
<p>И нам нужно ещё добавить индикатор загрузки.</p>

<p>Доработаем ItemComponent &mdash; в файле item.component.ts уже не нужен HackerNewsService:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// item.component.ts

export class ItemComponent implements OnInit {
  @Input() item;

  constructor() {}

  ngOnInit() {

  }
}</pre></div>
<p>Разметка:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- item.component.html --&gt;

&lt;div class=&#34;item-laptop&#34;&gt;
  &lt;p&gt;
    &lt;a class=&#34;title&#34; href=&#34;&#34;&gt;
      {{item.title}}
    &lt;/a&gt;
    &lt;span *ngIf=&#34;item.domain&#34; class=&#34;domain&#34;&gt;({{item.domain}})&lt;/span&gt;
  &lt;/p&gt;
  &lt;div class=&#34;subtext-laptop&#34;&gt;
    &lt;span&gt;
      {{item.points}} points by
      &lt;a href=&#34;&#34;&gt;{{item.user}}&lt;/a&gt;
    &lt;/span&gt;
    &lt;span&gt;
      {{item.time_ago}}
      &lt;span&gt; |
        &lt;a href=&#34;&#34;&gt;
          &lt;span *ngIf=&#34;item.comments_count !== 0&#34;&gt;
            {{item.comments_count}}
            &lt;span *ngIf=&#34;item.comments_count === 1&#34;&gt;comment&lt;/span&gt;
            &lt;span *ngIf=&#34;item.comments_count &gt; 1&#34;&gt;comments&lt;/span&gt;
          &lt;/span&gt;
          &lt;span *ngIf=&#34;item.comments_count === 0&#34;&gt;discuss&lt;/span&gt;
        &lt;/a&gt;
      &lt;/span&gt;
    &lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;item-mobile&#34;&gt;
  &lt;!-- Markup that shows only on mobile (to give the app a
    responsive mobile feel). Same attributes as above
    nothing really new here (but refer to the source
    file if you&#39;re interested) --&gt;
&lt;/div&gt;</pre></div>
<p>И посмотрим что у нас получилось:</p>

<p><img src="https://tehnojam.pro/uploads/images/00/00/24/2017/03/16/x28021eeb0c.png.pagespeed.ic.gKiVQYiXYG.png" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 3" /><br />
Всё работает намного быстрее! Исходный код этого этапа можно скачать <a href="https://github.com/housseindjirdeh/angular2-hn/tree/first-page-final">здесь</a>.</p>

<h6 id="роутинг">Роутинг</h6>

<p>Мы уже много сделали, но сделаем паузу и нарисуем структуру компонентов нашего приложения. Простите за моё неумение работать в Powerpoint.</p>

<p>Начнём с того, что мы уже сделали:</p>

<p><img src="https://tehnojam.pro/uploads/images/00/00/24/2017/03/16/x18ad833084.png.pagespeed.ic.AFW-zJO3Pt.png" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 3" /><br />
Также обрисуем компоненты, показывающие переход к странице комментариев:</p>

<p><img src="https://tehnojam.pro/uploads/images/00/00/24/2017/03/16/x7ab850a47b.png.pagespeed.ic.YAVBzTUVhY.png" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 3" /><br />
Чтобы пользователь мог переходить между этими страницами, нам нужен небольшой роутинг. Создадим компонент:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">ng g component ItemComments</pre></div>
<p>А теперь создадим файл app.routes.ts в папке app.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app.routes.ts

import { Routes, RouterModule } from &#39;@angular/router&#39;;

import { StoriesComponent } from &#39;./stories/stories.component&#39;;
import { ItemCommentsComponent } from &#39;./item-comments/item-comments.component&#39;;

const routes: Routes = [
  {path: &#39;&#39;, redirectTo: &#39;news/1&#39;, pathMatch : &#39;full&#39;},
  {path: &#39;news/:page&#39;, component: StoriesComponent, data: {storiesType: &#39;news&#39;}},
  {path: &#39;newest/:page&#39;, component: StoriesComponent, data: {storiesType: &#39;newest&#39;}},
  {path: &#39;show/:page&#39;, component: StoriesComponent, data: {storiesType: &#39;show&#39;}},
  {path: &#39;ask/:page&#39;, component: StoriesComponent, data: {storiesType: &#39;ask&#39;}},
  {path: &#39;jobs/:page&#39;, component: StoriesComponent, data: {storiesType: &#39;jobs&#39;}},
  {path: &#39;item/:id&#39;, component: ItemCommentsComponent}
];

export const routing = RouterModule.forRoot(routes);</pre></div>
<p>Вот что мы сделали:</p>

<ol>
<li>Мы создали массив роутов, с указанием относительного пути и привязкой к конкретному компоненту</li>
<li>Ссылки в шапке страницы будут указывать на разные пути: news, newest, show, ask и jobs. Все эти пути привязаны к StoriesComponent</li>
<li>С корневого пути мы сделаем редирект на news, возвращающий топ историй</li>
<li>При привязке StoriesComponent мы передаём storiesType как параметр свойства data.</li>
<li>:page используем как токен, поэтому StoriesComponent может получать список топиков определённой страницы</li>
<li>:id используется также, поэтому ItemCommentsComponent получает все комментарии к нужному топику</li>
</ol>

<p>С роутингом можно сделать ещё много интересного, но этой основы нам пока достаточно. Откроем app.module.ts и зарегистрируем наш роутинг:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app.module.ts

// ...
import { routing } from &#39;./app.routes&#39;;

@NgModule({
  declarations: [
    //...
  ],
  imports: [
    //...
    routing
  ],
  providers: [HackerNewsAPIService],
  bootstrap: [AppComponent]
})
export class AppModule { }</pre></div>
<p>Чтобы Angular знал, куда загружать нужный компонент, нам нужен RouterOutlet.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app.component.html --&gt;

&lt;div id=&#34;wrapper&#34;&gt;
  &lt;app-header&gt;&lt;/app-header&gt;
  &lt;router-outlet&gt;&lt;/router-outlet&gt;
  &lt;app-footer&gt;&lt;/app-footer&gt;
&lt;/div&gt;</pre></div>
<h6 id="навигация-по-топикам">Навигация по топикам</h6>

<p>Привяжем навигационные ссылки в HeaderComponent к соответствующим роутам:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- header.component.html --&gt;

&lt;header&gt;
  &lt;div id=&#34;header&#34;&gt;
    &lt;a class=&#34;home-link&#34; routerLink=&#34;/news/1&#34;&gt;
      &lt;img class=&#34;logo&#34; src=&#34;https://i.imgur.com/J303pQ4.png&#34; alt=&#34;Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 3&#34; /&gt;
    &lt;/a&gt;
    &lt;div class=&#34;header-text&#34;&gt;
      &lt;div class=&#34;left&#34;&gt;
        &lt;h1 class=&#34;name&#34;&gt;
          &lt;a routerLink=&#34;/news/1&#34; class=&#34;app-title&#34;&gt;Angular 2 HN&lt;/a&gt;
        &lt;/h1&gt;
        &lt;span class=&#34;header-nav&#34;&gt;
          &lt;a routerLink=&#34;/newest/1&#34;&gt;new&lt;/a&gt;
          &lt;span class=&#34;divider&#34;&gt;
            |
          &lt;/span&gt;
          &lt;a routerLink=&#34;/show/1&#34;&gt;show&lt;/a&gt;
          &lt;span class=&#34;divider&#34;&gt;
            |
          &lt;/span&gt;
          &lt;a routerLink=&#34;/ask/1&#34;&gt;ask&lt;/a&gt;
          &lt;span class=&#34;divider&#34;&gt;
            |
          &lt;/span&gt;
          &lt;a routerLink=&#34;/jobs/1&#34;&gt;jobs&lt;/a&gt;
        &lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&#34;info&#34;&gt;
        Built with &lt;a href=&#34;https://cli.angular.io/&#34; target=&#34;_blank&#34;&gt;Angular CLI&lt;/a&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/header&gt;</pre></div>
<p>Директива RouterLink ответственна за привязку определённого элемента к роуту. Теперь обновим StoriesComponent:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// stories.component.ts

import { Component, OnInit } from &#39;@angular/core&#39;;
import { Observable } from &#39;rxjs/Observable&#39;;
import { ActivatedRoute } from &#39;@angular/router&#39;;

import { HackerNewsAPIService } from &#39;../hackernews-api.service&#39;;

@Component({
  selector: &#39;app-stories&#39;,
  templateUrl: &#39;./stories.component.html&#39;,
  styleUrls: [&#39;./stories.component.scss&#39;]
})

export class StoriesComponent implements OnInit {
  typeSub: any;
  pageSub: any;
  items;
  storiesType;
  pageNum: number;
  listStart: number;

  constructor(
    private _hackerNewsAPIService: HackerNewsAPIService,
    private route: ActivatedRoute
  ) {}

  ngOnInit() {
    this.typeSub = this.route
      .data
      .subscribe(data =&gt; this.storiesType = (data as any).storiesType);

    this.pageSub = this.route.params.subscribe(params =&gt; {
      this.pageNum = +params[&#39;page&#39;] ? +params[&#39;page&#39;] : 1;
      this._hackerNewsAPIService.fetchStories(this.storiesType, this.pageNum)
                              .subscribe(
                                items =&gt; this.items = items,
                                error =&gt; console.log(&#39;Error fetching&#39; + this.storiesType + &#39;stories&#39;),
                                () =&gt; this.listStart = ((this.pageNum - 1) * 30) + 1);
    });
  }
}</pre></div>
<p>Опишем вкратце, что мы сделали. Вначале мы импортировали ActivatedRoute &mdash; это служба, обеспечивающая доступ к информации в роуте.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">import { ActivatedRoute } from &#39;@angular/router&#39;;

@Component({
  //...
})

export class StoriesComponent implements OnInit {
//..

constructor(
  private route: ActivatedRoute
) {}
//...
}</pre></div>
<p>Затем мы подписываемся на свойства данных роута и сохраняем storiesType в переменной компонента в хуке ngOnInit.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">ngOnInit() {
  this.typeSub = this.route
    .data
    .subscribe(data =&gt; this.storiesType = (data as any).storiesType);

// ...
}</pre></div>
<p>И, наконец, мы подписываемся на параметры роута и получаем номер страницы. Затем получаем список топиков:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">ngOnInit() {
// ...

this.pageSub = this.route.params.subscribe(params =&gt; {
    this.pageNum = +params[&#39;page&#39;] ? +params[&#39;page&#39;] : 1;
    this._hackerNewsAPIService.fetchStories(this.storiesType, this.pageNum)
                            .subscribe(
                              items =&gt; this.items = items,
                              error =&gt; console.log(&#39;Error fetching&#39; + this.storiesType + &#39;stories&#39;),
                              () =&gt; {
                                this.listStart = ((this.pageNum - 1) * 30) + 1;
                                window.scrollTo(0, 0);
                              });
  });
}</pre></div>
<p>Для подтверждения завершения, мы используем onCompleted() для обновления переменной listStart, которую используем как начальное значение для нашего упорядоченного списка (его вы увидите в разметке ниже). Также мы прокручиваем страницу вверх, чтобы пользователь не застрял внизу страницы при переходе на другую страницу.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- stories.component.html --&gt;

&lt;div class=&#34;main-content&#34;&gt;
  &lt;div class=&#34;loading-section&#34; *ngIf=&#34;!items&#34;&gt;
    &lt;!-- You can add a loading indicator here if you want to :) --&gt;
  &lt;/div&gt;
  &lt;div *ngIf=&#34;items&#34;&gt;
    &lt;ol start=&#34;{{ listStart }}&#34;&gt;
      &lt;li *ngFor=&#34;let item of items&#34; class=&#34;post&#34;&gt;
        &lt;item class=&#34;item-block&#34; [item]=&#34;item&#34;&gt;&lt;/item&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
    &lt;div class=&#34;nav&#34;&gt;
      &lt;a *ngIf=&#34;listStart !== 1&#34; [routerLink]=&#34;[&#39;/&#39; + storiesType, pageNum - 1]&#34; class=&#34;prev&#34;&gt;
        ‹ Prev
      &lt;/a&gt;
      &lt;a *ngIf=&#34;items.length === 30&#34; [routerLink]=&#34;[&#39;/&#39; + storiesType, pageNum + 1]&#34; class=&#34;more&#34;&gt;
        More ›
      &lt;/a&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div>
<p>Главная страница готова, у нас есть <a href="https://media.giphy.com/media/l3vR4zR3rCMX76Pm0/giphy.gif">навигация и пагинация</a>. А лучше сами проверьте как работает приложение.</p>

<h6 id="комментарии">Комментарии</h6>

<p>Мы почти закончили! Перед тем, как начать добавлять компоненты комментариев, обновим ссылки в ItemComponent для работы роутинга:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- item.component.html --&gt;

&lt;div class=&#34;item-laptop&#34;&gt;
  &lt;p&gt;
    &lt;a class=&#34;title&#34; href=&#34;{{item.url}}&#34;&gt;
      {{item.title}}
    &lt;/a&gt;
    &lt;span *ngIf=&#34;item.domain&#34; class=&#34;domain&#34;&gt;({{item.domain}})&lt;/span&gt;
  &lt;/p&gt;
  &lt;div class=&#34;subtext-laptop&#34;&gt;
    &lt;span&gt;
      {{item.points}} points by
      &lt;a href=&#34;&#34;&gt;{{item.user}}&lt;/a&gt;
    &lt;/span&gt;
    &lt;span&gt;
      {{item.time_ago}}
      &lt;span&gt; |
         &lt;a [routerLink]=&#34;[&#39;/item&#39;, item.id]&#34;&gt;
          &lt;span *ngIf=&#34;item.comments_count !== 0&#34;&gt;
            {{item.comments_count}}
            &lt;span *ngIf=&#34;item.comments_count === 1&#34;&gt;comment&lt;/span&gt;
            &lt;span *ngIf=&#34;item.comments_count &gt; 1&#34;&gt;comments&lt;/span&gt;
          &lt;/span&gt;
          &lt;span *ngIf=&#34;item.comments_count === 0&#34;&gt;discuss&lt;/span&gt;
        &lt;/a&gt;
      &lt;/span&gt;
    &lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;item-mobile&#34;&gt;
  &lt;!-- Markup that shows only on mobile (to give the app a
    responsive mobile feel). Same attributes as above,
    nothing really new here (but refer to the source
    file if you&#39;re interested) --&gt;
&lt;/div&gt;</pre></div>
<p>Запустите приложение и кликните на комментарии топика:</p>

<p><img src="img/x4860a550bb.png.pagespeed.ic.xG_4QmvnQF.png" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 3" /><br />
Красота. Роутинг к ItemCommentsComponent работает. Теперь создадим остальные компоненты.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">ng g component CommentTree
ng g component Comment</pre></div>
<p>Добавим новый GET-запрос в нашу службу для получения комментариев.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// hackernews.api.service.ts

//...

fetchComments(id: number): Observable&lt;any&gt; {
  return this.http.get(`${this.baseUrl}/item/${id}`)
                  .map(response =&gt; response.json());
}</pre></div>
<p>И заполним наши компоненты</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// item-comments.component.ts

import { Component, OnInit } from &#39;@angular/core&#39;;
import { ActivatedRoute } from &#39;@angular/router&#39;;

import { HackerNewsAPIService } from &#39;../hackernews-api.service&#39;;

@Component({
  selector: &#39;app-item-comments&#39;,
  templateUrl: &#39;./item-comments.component.html&#39;,
  styleUrls: [&#39;./item-comments.component.scss&#39;]
})
export class ItemCommentsComponent implements OnInit {
  sub: any;
  item;

  constructor(
    private _hackerNewsAPIService: HackerNewsAPIService,
    private route: ActivatedRoute
  ) {}

  ngOnInit() {
    this.sub = this.route.params.subscribe(params =&gt; {
      let itemID = +params[&#39;id&#39;];
      this._hackerNewsAPIService.fetchComments(itemID).subscribe(data =&gt; {
        this.item = data;
      }, error =&gt; console.log(&#39;Could not load item&#39; + itemID));
    });
  }
}</pre></div>
<p>Также как в StoriesComponent, мы сделаем подписку к параметрам роута, получим id элемента и по нему получим нужные комментарии.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- item-comments.component.html --&gt;

&lt;div class=&#34;main-content&#34;&gt;
  &lt;div class=&#34;loading-section&#34; *ngIf=&#34;!item&#34;&gt;
    &lt;!-- You can add a loading indicator here if you want to :) --&gt;
  &lt;/div&gt;
  &lt;div *ngIf=&#34;item&#34; class=&#34;item&#34;&gt;
    &lt;div class=&#34;mobile item-header&#34;&gt;
     &lt;!-- Markup that shows only on mobile (to give the app a
    responsive mobile feel). Same attributes as below,
    nothing really new here (but refer to the source
    file if you&#39;re interested) --&gt;
    &lt;/div&gt;
    &lt;div class=&#34;laptop&#34; [class.item-header]=&#34;item.comments_count &gt; 0 || item.type === &#39;job&#39;&#34; [class.head-margin]=&#34;item.text&#34;&gt;
      &lt;p&gt;
        &lt;a class=&#34;title&#34; href=&#34;{{item.url}}&#34;&gt;
        {{item.title}}
        &lt;/a&gt;
        &lt;span *ngIf=&#34;item.domain&#34; class=&#34;domain&#34;&gt;({{item.domain}})&lt;/span&gt;
      &lt;/p&gt;
      &lt;div class=&#34;subtext&#34;&gt;
        &lt;span&gt;
        {{item.points}} points by
          &lt;a href=&#34;&#34;&gt;{{item.user}}&lt;/a&gt;
        &lt;/span&gt;
        &lt;span&gt;
          {{item.time_ago}}
          &lt;span&gt; |
            &lt;a [routerLink]=&#34;[&#39;/item&#39;, item.id]&#34;&gt;
              &lt;span *ngIf=&#34;item.comments_count !== 0&#34;&gt;
                {{item.comments_count}}
                &lt;span *ngIf=&#34;item.comments_count === 1&#34;&gt;comment&lt;/span&gt;
                &lt;span *ngIf=&#34;item.comments_count &gt; 1&#34;&gt;comments&lt;/span&gt;
              &lt;/span&gt;
              &lt;span *ngIf=&#34;item.comments_count === 0&#34;&gt;discuss&lt;/span&gt;
            &lt;/a&gt;
          &lt;/span&gt;
        &lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;p class=&#34;subject&#34; [innerHTML]=&#34;item.content&#34;&gt;&lt;/p&gt;
    &lt;app-comment-tree [commentTree]=&#34;item.comments&#34;&gt;&lt;/app-comment-tree&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div>
<p>В начале компонента мы выводим детали элемента, идущие за его описанием (item.content). Затем вводим объект комментариев (item.comments) в app-comment-tree, селектор для CommentTreeComponent. Стили для этого компонента можно скачать <a href="https://github.com/housseindjirdeh/angular2-hn/blob/item-comments/src/app/item-comments/item-comments.component.scss">здесь</a>.</p>

<p>Теперь доработаем CommentTreeComponent.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// comment-tree.component.ts

import { Component, Input, OnInit } from &#39;@angular/core&#39;;

@Component({
  selector: &#39;app-comment-tree&#39;,
  templateUrl: &#39;./comment-tree.component.html&#39;,
  styleUrls: [&#39;./comment-tree.component.scss&#39;]
})
export class CommentTreeComponent implements OnInit {
  @Input() commentTree;

  constructor() {}

  ngOnInit() {

  }
}</pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- comment-tree.component.html --&gt;

&lt;ul class=&#34;comment-list&#34;&gt;
   &lt;li *ngFor=&#34;let comment of commentTree&#34; &gt;
      &lt;app-comment [comment]=&#34;comment&#34;&gt;&lt;/app-comment&gt;
   &lt;/li&gt;
&lt;/ul&gt;</pre></div>
<p>Мы выводим список комментариев директивой ngFor. <a href="https://github.com/housseindjirdeh/angular2-hn/blob/item-comments/src/app/comment-tree/comment-tree.component.scss">Здесь</a> можно скачать стили.</p>

<p>Доработаем CommentComponent, отвечающий за конкретный комментарий:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// comment.component.ts

import { Component, Input, OnInit } from &#39;@angular/core&#39;;

@Component({
  selector: &#39;app-comment&#39;,
  templateUrl: &#39;./comment.component.html&#39;,
  styleUrls: [&#39;./comment.component.scss&#39;]
})
export class CommentComponent implements OnInit {
  @Input() comment;
  collapse: boolean;

  constructor() {}

  ngOnInit() {
    this.collapse = false;
  }
}</pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- comment.component.html --&gt;

&lt;div *ngIf=&#34;!comment.deleted&#34;&gt;
  &lt;div class=&#34;meta&#34; [class.meta-collapse]=&#34;collapse&#34;&gt;
    &lt;span class=&#34;collapse&#34; (click)=&#34;collapse = !collapse&#34;&gt;[{{collapse ? &#39;+&#39; : &#39;-&#39;}}]&lt;/span&gt;
    &lt;a [routerLink]=&#34;[&#39;/user&#39;, comment.user]&#34; routerLinkActive=&#34;active&#34;&gt;{{comment.user}}&lt;/a&gt;
    &lt;span class=&#34;time&#34;&gt;{{comment.time_ago}}&lt;/span&gt;
  &lt;/div&gt;
  &lt;div class=&#34;comment-tree&#34;&gt;
    &lt;div [hidden]=&#34;collapse&#34;&gt;
      &lt;p class=&#34;comment-text&#34; [innerHTML]=&#34;comment.content&#34;&gt;&lt;/p&gt;
      &lt;ul class=&#34;subtree&#34;&gt;
        &lt;li *ngFor=&#34;let subComment of comment.comments&#34;&gt;
          &lt;app-comment [comment]=&#34;subComment&#34;&gt;&lt;/app-comment&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div *ngIf=&#34;comment.deleted&#34;&gt;
  &lt;div class=&#34;deleted-meta&#34;&gt;
    &lt;span class=&#34;collapse&#34;&gt;[deleted]&lt;/span&gt; | Comment Deleted
  &lt;/div&gt;
&lt;/div&gt;</pre></div>
<p>Запустим приложение и сможем увидеть комментарии где и положено:</p>

<p><img src="img/x97bd8cf2b4.png.pagespeed.ic.FfUbSHtupq.png" alt="Разработка: Создание hacker news с angular 2 cli, rxjs и webpack, часть 3" /><br />
Исходный код этого этапа можно взять <a href="https://github.com/housseindjirdeh/angular2-hn/tree/item-comments">здесь</a>.</p>

<h6 id="профили-пользователей">Профили пользователей</h6>

<p>Остались только профили пользователей. Их мы сделаем абсолютно так же, как и предыдущие элементы, поэтому описание этого этапа мы пропустим. Вот что нужно сделать:</p>

<ol>
<li>Добавить ещё один запрос в службу данных, работающий конечную точку по пользователям.</li>
<li>Создать компонент для этого.</li>
<li>Добавить поле в файл с роутами.</li>
<li>Обновить во всех компонентах ссылки, указывающие на пользователя.</li>
</ol>

<p>Вот <a href="https://github.com/housseindjirdeh/angular2-hn/tree/version-1/src/app/user">готовый код</a> этой части.</p>

<h6 id="заключение">Заключение</h6>

<p>Мы закончили. Для сборки приложения можно запустить</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">ng build --prod</pre></div>
<p>или</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">ng serve --prod</pre></div>
<p>Источник: <a href="https://houssein.me/angular2-hacker-news">«building hacker news with angular 2 cli, rxjs and webpack»</a></p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Генерируем Identicon в Go</turbo:topic>
      <link>https://fokusov.com/posts/generiruem-identicon-v-go/</link>
      <pubDate>Fri, 10 Mar 2017 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ <p><img src="img/x8cae87.jpg.pagespeed.ic.8dj3cIz3eb.jpg" alt="Разработка: Генерируем Identicon в Go" /></p>

<p>В этой статье мы разработаем простой генератор идентиконов на языке Go. Исходный код вы можете взять <a href="https://www.github.com/barthr/Identicon">здесь</a>.</p>

<p>Но что такое идентикон? Думаю, все видели стандартную аватарку при регистрации на Github. Вот пример:
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAaQAAAGkAQMAAABEgsN2AAAABlBMVEV+RYHw8PBNfLNoAAAAk0lEQVR42u3cwQmAMAwF0IADOFJX70gOIOjF6qFIi4gUfP8YePCvIZDYHmQJiqIoivqpitvMFEVRFEVRFEVRFDWCytGf9JZKR4W1DKZSKlMURVEURVEURVFUU325w5659mmKoiiKoiiKoiiKGknVl+JKdd2XKYqiKIqiKIqiKIqiKIqiKIqiKIqiKN+0KIqiKKqhdqg2AiWw8tgnAAAAAElFTkSuQmCC" alt="Разработка: Генерируем Identicon в Go" /></p>

<p>Вы видите визуальное представление значения хэш-функции. То есть с помощью специального алгоритма (md5 или sha256 и т.п.) захэшировано какое-то слово, при этом вывод этого алгоритма используется для генерации картинки. Поэтому идентикон будет всегда один и тот же при одинаковых входных данных.</p>

<p><strong>Но хватит болтать, пора программировать!</strong></p>

<p>Начнём с описания структуры идентикона:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">type Identicon struct {
  name       string
  hash       [16]byte
  color      [3]byte
}</pre></div>
<p>Структура имеет три поля:</p>

<ul>
<li>name: Переданное имя для генерации идентикона.</li>
<li>hash: 16 байтовый массив, содержащий хэшированное значение имени, мы используем [16]byte из-за того, что наши хэширующие функции возвращают байтовый массив с 16 значениями.</li>
<li>color: 3 байтовый массив, содержащий цвета Red,Green,Blue<br />
Итак, мы описали базовый контейнер для хранения значений. Остаётся слушать пользовательский ввод и хэшировать введённые значения.<br />
Мы используем метод Sum из пакета «crypto/md5», этот метод возвращает [16]byte контрольную сумму от переданного параметра:</li>
</ul>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">func hashInput(input []byte) Identicon {
    // генерируем контрольную сумму из ввода
    checkSum := md5.Sum(input)
    // возвращаем identicon
    return Identicon{
        name: string(input),
        hash: checkSum,
    }
}</pre></div>
<p>Мы можем использовать метод так:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// конвертируем строку в массив байтов
data := []byte(&#34;bart&#34;)
// вызываем метод hashinput для этого массива байтов
hashInput(data)
// на выходе: [245 65 70 163 252 130 171 23 229 38 86 149 178 63 100 107]</pre></div>
<p>Теперь необходимо задать цвет идентикона, ведь мы хотим, чтобы он был всегда одинаковым при одном и том же вводе. Трюк в том, что мы возьмём первые 3 байта контрольной суммы и, соответственно, цвет всегда будет одинаковым. Первый будет отвечать за Красный (Red), второй за Зелёный (Green), а третий за Синий (Blue). Так у нас получится валидное значение RGB и мы сможем его использовать вместе с библиотекой color в go.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">func pickColor(identicon Identicon) Identicon {
    // сначала создадим массив байтов, размером 3 элемента
    rgb := [3]byte{}
    // затем скопируем первые 3 элемента хэша в массив rgb
    copy(rgb[:], identicon.hash[:3])
    // затем присвоим его полю color
    identicon.color = rgb
    // вернём изменённый identicon
    return identicon
}</pre></div>
<p>Сейчас в нашем идентиконе есть имя, цвет и хэш. И нюанс в том, что его левая сторона зеркально копирует правую. Нам нужно создать сетку размером 5х5 и если мы возьмём наш массив байтов [245 65 70 163 252 130 171 23 229 38 86 149 178 63 100 107] для примера, то после создания сетки получим</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[ 245, 65, 70, 65, 245,
  163, 252, 130, 252, 163,
  171, 23, 229, 23, 171,
  38, 86, 149, 86, 38,
  178, 63, 100, 63, 178 ]</pre></div>
<p>Как видите, левая сторона массива зеркально отражает правую. Можно было бы использовать матрицу, но для нашего примера достаточно и простого массива. Добавим ещё одно поле в структуру идентикона, в котором будем хранить значение сетки.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">type Identicon struct {
    name       string
    hash       [16]byte
    color      [3]byte
    grid       []byte // новое поле для сетки
}</pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">func buildGrid(identicon Identicon) Identicon {
    // Создадим пустую сетку
    grid := []byte{}
    // Обходим в цикле весь хэш идентикона с шагом 3,
    // соответственно мы исключим ситуацию обращения за границами массива
    // и получим 5 чанков по 3 элемента
    for i := 0; i &lt; len(identicon.hash) &amp;&amp; i+3 &lt;= len(identicon.hash)-1; i += 3 {
        // создадим пустой chunk
        chunk := make([]byte, 5)
        // Скопируем элементы из старого массива в новый
        copy(chunk, identicon.hash[i:i+3])
        chunk[3] = chunk[1] // зеркалируем второй элемент
        chunk[4] = chunk[0] // зеркалируем первый элемент
        grid = append(grid, chunk...) // добавляем chunk в сетку
    }
    identicon.grid = grid // заполняем поле grid в идентиконе
    return identicon // возвращаем изменённый identicon
}</pre></div>
<p>Итак, наша сетка для рисования реальной картинки почти готова, но вначале определим какие её ячейки следует закрасить цветом.<br />
Посмотрим ещё раз на получившуюся сетку &mdash; будет хорошим вариантом закрасить только нечётные ячейки. Для этого создадим ещё одну структуру, в которой будут значения и индекс элементов нашей сетки.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">type GridPoint struct {
    value byte
    index int
}</pre></div>
<p>Добавим её в структуру идентикона для удобства.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">type Identicon struct {
    name       string
    hash       [16]byte
    color      [3]byte
    grid       []byte
        gridPoints []GridPoint // Отфильтрованные ячейки сетки
}</pre></div>
<p>В GridPoints будут храниться значения, которые мы закрасим рассчитанным ранее цветом. Напишем метод фильтрации сетки:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">func filterOddSquares(identicon Identicon) Identicon {
    grid := []GridPoint{} // создадим пустую сетку, будем заполнять её в цикле
    for i, code := range identicon.grid { // идём в цикле по нашей сетке
    if code%2 == 0 { // проверяем - нечётное ли число
            // создадим новую Gridpoint, куда положим значение и индекс элементов
        point := GridPoint{
        value: code,
        index: i,
        }
                // добавим элемент к новой сетке
        grid = append(grid, point)
    }
    }
    // присвоим значение
    identicon.gridPoints = grid
    return identicon // возвращаем изменённый идентикон
}</pre></div>
<p>Теперь в нашем идентиконе заполнены значения, которые нужно закрасить цветом, однако мы не можем нарисовать картинку только по этим значениям &mdash; мы должны преобразовать их в пиксельную карту. Так как мы хотим нарисовать прямоугольник, необходимо рассчитать верхнюю левую и нижнюю правую координаты для каждой нечётной точки, а затем по этим значениям нарисуем прямоугольник.</p>

<p>Создадим структуру для хранения размеров.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">type Point struct {
    x, y int
}

type DrawingPoint struct {
    topLeft     Point
    bottomRight Point
}</pre></div>
<p>Но как нам связать ячейки сетки с пикселями на пиксельной карте? Вначале определимся с размером изображения &mdash; оно будет размером 250 на 250 пикселей. Так как сетка у нас 5х5, то 1 ячейка сетки будет размером 50 на 50 пикселей, ибо <sup>250</sup>&frasl;<sub>5</sub> = 50.<br />
Теперь рассчитаем границы по таким формулам:</p>

<ul>
<li>горизонтальная: (x % 5) * 50</li>
<li>вертикальная: (x / 50) * 50</li>
</ul>

<p>где x = индекс ячейки в сетке</p>

<p>Теперь посмотрим как с этими формулами мы можем рассчитать размеры нашего прямоугольника. Сперва изменим структуру идентикона и добавим поле pixelMap, в нём будут размеры для рисования в png.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">type Identicon struct {
    name       string
    hash       [16]byte
    color      [3]byte
    grid       []byte
    gridPoints []GridPoint
    pixelMap   []DrawingPoint // пиксельная карта для рисования
}</pre></div>
<p>И сохраним карту в структуре идентикона:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">func buildPixelMap(identicon Identicon) Identicon {
    drawingPoints := []DrawingPoint{}

    pixelFunc := func(p GridPoint) DrawingPoint {
        horizontal := (p.index % 5) * 50
        vertical := (p.index / 5) * 50
        topLeft := Point{horizontal, vertical}
        bottomRight := Point{horizontal + 50, vertical + 50}

        return DrawingPoint{
        topLeft,
        bottomRight,
        }
    }

    for _, gridPoint := range identicon.gridPoints {
        drawingPoints = append(drawingPoints, pixelFunc(gridPoint))
    }
    identicon.pixelMap = drawingPoints
    return identicon
}</pre></div>
<p>Для рисования прямоугольника нужно взять 4 размера из структуры DrawingPoint и передать их функции рисования. Для отрисовки прямоугольников мы будем использовать внешнюю библиотеку <a href="https://github.com/llgcode/draw2d">draw2dRepo</a> &mdash; рисовать прямоугольник с ней намного легче. Мы передадим нашей функции рисования изображение, цвет и размеры, а она создаст готовый прямоугольник для нас.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">func rect(img *image.RGBA, col color.Color, x1, y1, x2, y2 float64) {
    gc := draw2dimg.NewGraphicContext(img) // подготовим новый контекст изображения
    gc.SetFillColor(col) // зададим цвет
    gc.MoveTo(x1, y1) // перенесёмся в левый верхний край картинки
    // нарисуем габаритные линии
    gc.LineTo(x1, y1)
    gc.LineTo(x1, y2)
    gc.MoveTo(x2, y1) // передвинемся вправый край изображения
    // нарисуем габаритные линии
    gc.LineTo(x2, y1)
    gc.LineTo(x2, y2)
    // сделаем ширину линии в ноль
    gc.SetLineWidth(0)
    // Заполним ячейку
    gc.FillStroke()
}</pre></div>
<p>Итак, рисовать разукрашенные прямоугольники мы умеем. Осталось пройтись по всей карте пикселей и на каждом шаге вызывать эту функцию:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">func drawRectangle(identicon Identicon) error {
    // создадим пустую картинку размером 250x250
    var img = image.NewRGBA(image.Rect(0, 0, 250, 250))
    // получим цвет из соответствующего поля идентикона
    col := color.RGBA{identicon.color[0], identicon.color[1], identicon.color[2], 255}

    // обойдём в цикле pixelmap вызывая функцию rect с передачей ей картинки, цвета и размеров
    for _, pixel := range identicon.pixelMap {
    rect(
            img,
            col,
            float64(pixel.topLeft.x),
            float64(pixel.topLeft.y),
            float64(pixel.bottomRight.x),
            float64(pixel.bottomRight.y)
        )
    }
    // Сохраним изображение на диск
    return draw2dimg.SaveToPngFile(identicon.name+&#34;.png&#34;, img)
}</pre></div>
<p>Готово! Генератор идентикона сделан, осталось одна вещь. Вы видели, что большинство наших функций изменяют идентикон и возвращают идентикон. Это хорошая работа для конвейерной функции. Сделаем её набросок:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">type Apply func(Identicon) Identicon</pre></div>
<p>И определим функцию, принимающую x количество типов Apply и применяющих их к идентикону:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">func pipe(identicon Identicon, funcs ...Apply) Identicon {
    for _, applyer := range funcs {
    identicon = applyer(identicon)
    }
    return identicon
}</pre></div>
<p>Теперь пропишем весь функционал в методе main() и создадим флаг определения ввода имени в функцию:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">func main() {
    var (
    name = flag.String(&#34;name&#34;, &#34;&#34;, &#34;Set the name where you want to generate an Identicon for&#34;)
    )
    flag.Parse()

    if *name == &#34;&#34; {
    flag.Usage()
    os.Exit(0)
    }

    data := []byte(*name)
    identicon := hashInput(data)

    // Передадим идентикон, вызывая методы для его обработки
    identicon = pipe(identicon, pickColor, buildGrid, filterOddSquares, buildPixelMap)

    // Передадим идентикон в функцию drawRectangle
    if err := drawRectangle(identicon); err != nil {
    log.Fatalln(err)
    }
}</pre></div>
<p>Выполнив этот код с именем «bart» мы получим:</p>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAAD6AQMAAACyIsh+AAAABlBMVEUAAAD1QUZgtZIVAAAAAXRSTlMAQObYZgAAAFZJREFUaN7t2LEJwCAQhtEDB8hIWd2RHCBg0OpAUkW795U/rz+4iNTVR098BgAAAAA/wd2XAAAAAOAAkCTpdPkKtbmUPFUAAAAA2Anq+nYDAAAAgJ3gBQdAiNR+k1CAAAAAAElFTkSuQmCC" alt="Разработка: Генерируем Identicon в Go" /></p>

<p>Поздравляем, вы создали генератор идентиконов!</p>

<p>Источник: <a href="https://blog.bartfokker.nl/identicon/">«Tutorial: Identicon generator in Go»</a> by Bart Fokker</p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Создание списка задач с Vue.js</turbo:topic>
      <link>https://fokusov.com/posts/sozdanie-spiska-zadach-s-vue_js/</link>
      <pubDate>Thu, 09 Mar 2017 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ 

<p><img src="img/x8a1b4c19e6.jpg.pagespeed.ic.kCUg9wvLBj.jpg" alt="Разработка: Создание списка задач с Vue.js" /></p>

<p>Се­год­ня мы со­зда­дим при­ло­же­ние &mdash; спи­сок за­дач с Vue.​js, а та­к­же рас­смот­рим и дру­гие удоб­ные ин­стру­мен­ты для со­зда­ния со­вре­мен­ных веб-при­ло­же­ний.</p>

<p>Убе­ди­тесь, что у вас уста­нов­ле­на Vue CLI! Ес­ли нет, то уста­но­ви­те её ко­ман­дой</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ npm install --global vue-cli</pre></div>
<p>С Vue CLI идут несколь­ко шаб­ло­нов го­то­вых при­ло­же­ний:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">webpack - Полнофункциональная установка Webpack + Vue-loader с hot reload, linting, testing &amp; CSS extraction.

webpack-simple - Упрощённая установка Webpack + Vue-loader.

browserify - Полнофункциональная установка Browserify + vueify с hot-reload, linting &amp; unit testing.

browserify-simple - Упрощённая установка Browserify + vueify.

simple - Простенькая установка Vue всего в одном файле HTML</pre></div>
<p>Со­зда­дим при­ло­же­ние:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ vue init webpack todo-app</pre></div>
<p>Вас спро­сят на­зва­ние для про­ек­та, опи­са­ние, ав­то­ра и сбор­ку Vue. Мы бу­дем ра­бо­тать не уста­нав­ли­вая Vue-router.</p>

<p>Уста­но­вим за­ви­си­мо­сти:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ cd my-project
$ npm install</pre></div>
<p>Для за­пус­ка при­ло­же­ния вы­пол­ни­те ко­ман­ду:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ npm run dev</pre></div>
<p>От­кро­ет­ся бра­у­зер на стра­ни­це <a href="http://localhost:8080">localhost:8080</a></p>

<p><img src="img/xd1e0cd5152.png.pagespeed.ic.B8IPjCwvtL.png" alt="Разработка: Создание списка задач с Vue.js" /></p>

<p>Для сти­ли­за­ции при­ло­же­ния бу­дем ис­поль­зо­вать Semantic.</p>

<h5 id="струк-ту-ра-ком-по-нен-та">Струк­ту­ра ком­по­нен­та</h5>

<p>Каж­дое при­ло­же­ние Vue име­ет ком­по­нент верх­не­го уров­ня, у нас та­ким ком­по­нен­том бу­дет TodoList.</p>

<p>У нас уже есть го­то­вый ком­по­нент Hello (сге­не­ри­ро­ван­ный Vue CLI) в пап­ке src/App.​vue, оста­лось со­здать недо­ста­ю­щие ком­по­нен­ты ниж­не­го уров­ня.<br />
Со­зда­дим про­стень­кий ком­по­нент TodoList.vue:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;template&gt;
  &lt;div&gt;
    &lt;ul&gt;
        &lt;li&gt; Todo A &lt;/li&gt;
        &lt;li&gt; Todo B &lt;/li&gt;
        &lt;li&gt; Todo C &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script type = &#34;text/javascript&#34; &gt;

export default {
};
&lt;/script&gt;
&lt;style&gt;
&lt;/style&gt;</pre></div>
<p>Это обыч­ная за­го­тов­ка, ко­то­рую мы за­пол­ним позд­нее.</p>

<p>Им­пор­ти­ру­ем наш ком­по­нент в глав­ный эк­зем­пляр Vue, что­бы мож­но бы­ло с ним ра­бо­тать. От­крой­те файл src/App.​vue и от­ре­дак­ти­руй­те его:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;script&gt;
import TodoList from &#39;./components/TodoList&#39;;

export default {
  components: {
    // добавим ссылку на компонент TodoList
    TodoList,
  },
};
&lt;/script&gt;</pre></div>
<p>Для об­ра­бот­ки ком­по­нен­та необ­хо­ди­мо его вклю­чить в HTML:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;template&gt;
  &lt;div&gt;
    // Обработка компонента TodoList
    // он будет здесь:
    &lt;todo-list&gt;&lt;/todo-list&gt;
  &lt;/div&gt;
&lt;/template&gt;</pre></div>
<p>Те­перь на­ше при­ло­же­ние вы­гля­дит так:</p>

<p><img src="img/xb727db6750.png.pagespeed.ic.RRxQHJU9_R.png" alt="Разработка: Создание списка задач с Vue.js" /></p>

<p>Мы долж­ны пе­ре­да­вать дан­ные глав­но­му ком­по­нен­ту для вы­во­да спис­ка за­дач. За­да­чи бу­дут иметь три свой­ства: На­зва­ние, Про­ект и Вы­пол­не­но.</p>

<p>До­ба­вим дан­ных в наш ком­по­нент:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">export default {
  name: &#39;app&#39;,
  components: {
    TodoList,
  },
  // data function avails data to the template
  data() {
    return {
      todos: [{
        title: &#39;Todo A&#39;,
        project: &#39;Project A&#39;,
        done: false,
      }, {
        title: &#39;Todo B&#39;,
        project: &#39;Project B&#39;,
        done: true,
      }, {
        title: &#39;Todo C&#39;,
        project: &#39;Project C&#39;,
        done: false,
      }, {
        title: &#39;Todo D&#39;,
        project: &#39;Project D&#39;,
        done: false,
      }],
    };
  },
};</pre></div>
<p>Нам нуж­но пе­ре­дать дан­ные из глав­но­го ком­по­нен­та в TodoList и для это­го мы бу­дем ис­поль­зо­вать ди­рек­ти­ву v-bind. Она при­ни­ма­ет ар­гу­мент (он от­де­ля­ет­ся двое­то­чи­ем от име­ни ди­рек­ти­вы), в на­шем слу­чае это бу­дет todos; это по­ка­зы­ва­ет ди­рек­ти­ве v-bind свя­зать эле­мент todos с тем, что идёт в нём.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;todo-list v-bind:todos=&#34;todos&#34;&gt;&lt;/todo-list&gt;</pre></div>
<p>Те­перь нуж­но до­ра­бо­тать ком­по­нент TodoList для до­сту­па к этим дан­ным. До­ба­вим свой­ство к клас­су ком­по­нен­та:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">export default {
    props: [&#39;todos&#39;],
}</pre></div>
<h5 id="об-ра-бот-ка-дан-ных">Об­ра­бот­ка дан­ных</h5>

<p>Прой­дём­ся в цик­ле по спис­ку за­дач в шаб­лоне TodoList и вы­ве­дем ко­ли­че­ство за­вер­шён­ных и неза­вер­шён­ных за­дач:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;template&gt;
  &lt;div&gt;
    // JavaScript expressions in Vue are enclosed in double curly brackets.
    &lt;p&gt;Completed Tasks: {{todos.filter(todo =&gt; {return todo.done === true}).length}}&lt;/p&gt;
    &lt;p&gt;Pending Tasks: {{todos.filter(todo =&gt; {return todo.done === false}).length}}&lt;/p&gt;
    &lt;div class=&#39;ui centered card&#39; v-for=&#34;todo in todos&#34;&gt;
      &lt;div class=&#39;content&#39;&gt;
        &lt;div class=&#39;header&#39;&gt;
          {{ todo.title }}
        &lt;/div&gt;
        &lt;div class=&#39;meta&#39;&gt;
          {{ todo.project }}
        &lt;/div&gt;
        &lt;div class=&#39;extra content&#39;&gt;
          &lt;span class=&#39;right floated edit icon&#39;&gt;
            &lt;i class=&#39;edit icon&#39;&gt;&lt;/i&gt;
          &lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&#39;ui bottom attached green basic button&#39; v-show=&#34;todo.done&#34;&gt;
        Completed
      &lt;/div&gt;
      &lt;div class=&#39;ui bottom attached red basic button&#39; v-show=&#34;!todo.done&#34;&gt;
        Complete
      &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script type = &#34;text/javascript&#34; &gt;

export default {
  props: [&#39;todos&#39;],
};
&lt;/script&gt;</pre></div>
<h5 id="ре-дак-ти-ро-ва-ние-за-дач">Ре­дак­ти­ро­ва­ние за­дач</h5>

<p>Раз­де­лим шаб­лон за­да­чи для улуч­ше­ния чи­та­бель­но­сти ко­да. Со­здай­те но­вый ком­по­нент Todo.vue в пап­ке src/components и пе­ре­не­си­те в него шаб­лон за­да­чи:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;template&gt;
  &lt;div class=&#39;ui centered card&#39;&gt;
    &lt;div class=&#39;content&#39;&gt;
        &lt;div class=&#39;header&#39;&gt;
            {{ todo.title }}
        &lt;/div&gt;
        &lt;div class=&#39;meta&#39;&gt;
            {{ todo.project }}
        &lt;/div&gt;
        &lt;div class=&#39;extra content&#39;&gt;
            &lt;span class=&#39;right floated edit icon&#39;&gt;
            &lt;i class=&#39;edit icon&#39;&gt;&lt;/i&gt;
          &lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&#39;ui bottom attached green basic button&#39; v-show=&#34;todo.done&#34;&gt;
        Completed
    &lt;/div&gt;
    &lt;div class=&#39;ui bottom attached red basic button&#39; v-show=&#34;!todo.done&#34;&gt;
        Complete
    &lt;/div&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;script type=&#34;text/javascript&#34;&gt;
  export default {
    props: [&#39;todo&#39;],
  };
&lt;/script&gt;</pre></div>
<p>Пе­ре­ра­бо­та­ем ком­по­нент TodoList для ра­бо­ты с ком­по­нен­том Todo:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Completed Tasks: {{todos.filter(todo =&gt; {return todo.done === true}).length}}&lt;/p&gt;
    &lt;p&gt;Pending Tasks: {{todos.filter(todo =&gt; {return todo.done === false}).length}}&lt;/p&gt;
   // we are now passing the data to the todo component to render the todo list
    &lt;todo  v-for=&#34;todo in todos&#34; :todo.sync=&#34;todo&#34;&gt;&lt;/todo&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script type = &#34;text/javascript&#34; &gt;

import Todo from &#39;./Todo&#39;;

export default {
  props: [&#39;todos&#39;],
  components: {
    Todo,
  },
};
&lt;/script&gt;</pre></div>
<p>До­ба­вим свой­ство isEditing в класс ком­по­нен­та Todo, это свой­ство по­ка­жет ре­дак­ти­ру­ет­ся ли в дан­ный мо­мент за­да­ча или нет. По­ве­сим об­ра­бот­чик со­бы­тия на эле­мент Edit и бу­дем по­ка­зы­вать фор­му ре­дак­ти­ро­ва­ния, при этом из­ме­ним зна­че­ние свой­ства isEditing в true. Оста­лось до­ба­вить фор­му и уста­но­вить на­чаль­ное зна­че­ние свой­ства. Наш шаб­лон те­перь вы­гля­дит так:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;template&gt;
  &lt;div class=&#39;ui centered card&#39;&gt;
    // Todo shown when we are not in editing mode.
    &lt;div class=&#34;content&#34; v-show=&#34;!isEditing&#34;&gt;
      &lt;div class=&#39;header&#39;&gt;
          {{ todo.title }}
      &lt;/div&gt;
      &lt;div class=&#39;meta&#39;&gt;
          {{ todo.project }}
      &lt;/div&gt;
      &lt;div class=&#39;extra content&#39;&gt;
          &lt;span class=&#39;right floated edit icon&#39; v-on:click=&#34;showForm&#34;&gt;
          &lt;i class=&#39;edit icon&#39;&gt;&lt;/i&gt;
        &lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    // form is visible when we are in editing mode
    &lt;div class=&#34;content&#34; v-show=&#34;isEditing&#34;&gt;
      &lt;div class=&#39;ui form&#39;&gt;
        &lt;div class=&#39;field&#39;&gt;
          &lt;label&gt;Title&lt;/label&gt;
          &lt;input type=&#39;text&#39; v-model=&#34;todo.title&#34; &gt;
        &lt;/div&gt;
        &lt;div class=&#39;field&#39;&gt;
          &lt;label&gt;Project&lt;/label&gt;
          &lt;input type=&#39;text&#39; v-model=&#34;todo.project&#34; &gt;
        &lt;/div&gt;
        &lt;div class=&#39;ui two button attached buttons&#39;&gt;
          &lt;button class=&#39;ui basic blue button&#39; v-on:click=&#34;hideForm&#34;&gt;
            Close X
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&#39;ui bottom attached green basic button&#39; v-show=&#34;!isEditing &amp;&amp;todo.done&#34; disabled&gt;
        Completed
    &lt;/div&gt;
    &lt;div class=&#39;ui bottom attached red basic button&#39; v-show=&#34;!isEditing &amp;&amp; !todo.done&#34;&gt;
        Pending
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;/template&gt;</pre></div>
<p>У нас есть ме­тод showForm, от­кры­ва­ю­щий фор­му прав­ки, те­перь до­ба­вим ме­тод hideForm для её за­кры­тия при на­жа­тии на кноп­ку от­ме­ны:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;script&gt;
export default {
  props: [&#39;todo&#39;],
  data() {
    return {
      isEditing: false,
    };
  },
  methods: {
    showForm() {
      this.isEditing = true;
    },
    hideForm() {
      this.isEditing = false;
    },
  },
};
&lt;/script&gt;</pre></div>
<p>Дан­ные в фор­ме уже при­вя­за­ны к спис­ку за­дач и их ре­дак­ти­ро­ва­ние ав­то­ма­ти­че­ски со­хра­ня­ет об­нов­лён­ные дан­ные. По на­жа­тию кноп­ки Close уви­дим об­нов­лён­ную за­да­чу:</p>

<p><img src="img/x9ce8021f52.png.pagespeed.ic.BctLI9cQW2.png" alt="Разработка: Создание списка задач с Vue.js" /></p>

<h5 id="уда-ле-ние-за-да-чи">Уда­ле­ние за­да­чи</h5>

<p>До­ба­вим икон­ку уда­ле­ния за­да­чи:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;template&gt;
    &lt;span class=&#39;right floated edit icon&#39; v-on:click=&#34;showForm&#34;&gt;
      &lt;i class=&#39;edit icon&#39;&gt;&lt;/i&gt;
    &lt;/span&gt;
    /* add the trash icon in below the edit icon in the template */
    &lt;span class=&#39;right floated trash icon&#39; v-on:click=&#34;deleteTodo(todo)&#34;&gt;
      &lt;i class=&#39;trash icon&#39;&gt;&lt;/i&gt;
    &lt;/span&gt;
&lt;/template&gt;</pre></div>
<p>До­ба­вим ме­тод в класс ком­по­нен­та, вы­зы­ва­е­мый по со­бы­тию delete-todo, и пе­ре­да­ю­щий ком­по­нен­ту те­ку­щую за­да­чу к уда­ле­нию.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;span class=&#39;right floated trash icon&#39; v-on:click=&#34;deleteTodo(todo)&#34;&gt;</pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// Todo component
methods: {
    deleteTodo(todo) {
      this.$emit(&#39;delete-todo&#39;, todo);
    },
  },</pre></div>
<p>Те­перь нуж­но до­ба­вить об­ра­бот­чик со­бы­тия уда­ле­ния в ро­ди­тель­ский ком­по­нент (TodoList):</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// TodoList component
methods: {
    deleteTodo(todo) {
      const todoIndex = this.todos.indexOf(todo);
      this.todos.splice(todoIndex, 1);
    },
  },</pre></div>
<p>Пе­ре­да­ём ме­тод deleteTodo в ком­по­нент Todo:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// шаблон TodoList
&lt;todo  v-on:remove-todo=&#34;deleteTodo&#34; v-for=&#34;todo in todos&#34; :todo.sync=&#34;todo&#34;&gt;&lt;/todo&gt;</pre></div>
<h5 id="до-бав-ле-ние-но-вой-за-да-чи">До­бав­ле­ние но­вой за­да­чи</h5>

<p>Для со­зда­ния но­вой за­да­чи сде­ла­ем но­вый ком­по­нент CreateTodo в пап­ке src/components. Он вы­ве­дет кноп­ку со зна­ком плюс, она при на­жа­тии от­кро­ет фор­му до­бав­ле­ния за­да­чи:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;template&gt;
  &lt;div class=&#39;ui basic content center aligned segment&#39;&gt;
    &lt;button class=&#39;ui basic button icon&#39; v-on:click=&#34;openForm&#34; v-show=&#34;!isCreating&#34;&gt;
      &lt;i class=&#39;plus icon&#39;&gt;&lt;/i&gt;
    &lt;/button&gt;
    &lt;div class=&#39;ui centered card&#39; v-show=&#34;isCreating&#34;&gt;
      &lt;div class=&#39;content&#39;&gt;
        &lt;div class=&#39;ui form&#39;&gt;
          &lt;div class=&#39;field&#39;&gt;
            &lt;label&gt;Title&lt;/label&gt;
            &lt;input v-model=&#34;titleText&#34; type=&#39;text&#39; ref=&#39;title&#39; defaultValue=&#34;&#34;&gt;
          &lt;/div&gt;
          &lt;div class=&#39;field&#39;&gt;
            &lt;label&gt;Project&lt;/label&gt;
            &lt;input type=&#39;text&#39; ref=&#39;project&#39; defaultValue=&#34;&#34;&gt;
          &lt;/div&gt;
          &lt;div class=&#39;ui two button attached buttons&#39;&gt;
            &lt;button class=&#39;ui basic blue button&#39; v-on:click=&#34;sendForm()&#34;&gt;
              Create
            &lt;/button&gt;
            &lt;button class=&#39;ui basic red button&#39; v-on:click=&#34;closeForm&#34;&gt;
              Cancel
            &lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      titleText: &#39;&#39;,
      projectText: &#39;&#39;,
      isCreating: false,
    };
  },
  methods: {
    openForm() {
      this.isCreating = true;
    },
    closeForm() {
      this.isCreating = false;
    },
    sendForm() {
      if (this.titleText.length &gt; 0 &amp;&amp; this.projectText.length &gt; 0) {
        const title = this.titleText;
        const project = this.projectText;
        this.$emit(&#39;create-todo&#39;, {
          title,
          project,
          done: false,
        });
        this.newTodoText = &#39;&#39;;
      }
      this.isCreating = false;
    },
  },
};
&lt;/script&gt;</pre></div>
<p>До­ба­вим но­вый ком­по­нент в глав­ный ком­по­нент:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// главный компонент в App.vue
components: {
    TodoList,
    CreateTodo,
  },</pre></div>
<p>А та­к­же до­ба­вим ме­тод для со­зда­ния но­вой за­да­чи:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// в App.vue
methods: {
    addTodo(title) {
      this.todos.push({
        title,
        done: false,
      });
    },
  },</pre></div>
<p>Вы­зов ком­по­нен­та CreateTodo из шаб­ло­на App.​vue:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;create-form v-on:add-todo=&#34;addTodo&#34;&gt;</pre></div>
<p><img src="img/x76f6fe76dc.png.pagespeed.ic.OjCTKwk-dt.png" alt="Разработка: Создание списка задач с Vue.js" /></p>

<h5 id="вы-пол-не-ние-за-да-чи">Вы­пол­не­ние за­да­чи</h5>

<p>Оста­лось до­ба­вить ме­тод для уста­нов­ки от­мет­ки о вы­пол­не­нии за­да­чи.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// компонент Todo
methods: {
      completeTodo(todo) {
        this.$emit(&#39;complete-todo&#39;, todo);
      },
}</pre></div>
<p>Об­ра­бот­чик со­бы­тия бу­дет до­бав­лен в TodoList:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">methods: {
    completeTodo(todo) {
      const todoIndex = this.todos.indexOf(todo);
      this.todos[todoIndex].done = true;
    },
  },</pre></div>
<p>И до­ба­вим вы­зов ме­то­да в шаб­лоне:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;todo v-on:delete-todo=&#34;deleteTodo&#34; v-on:complete-todo=&#34;completeTodo&#34; v-for=&#34;todo in todos&#34; :todo.sync=&#34;todo&#34;&gt;&lt;/todo&gt;</pre></div>
<p>Го­то­во! Ни­же по ссыл­кам мож­но уви­деть пол­ный код при­ло­же­ния или по­щу­пать де­мон­стра­ци­он­ную вер­сию.</p>

<p><a href="https://github.com/scotch-io/vue-todo">Пол­ный код при­ме­ра.</a> <a href="https://todo-vue.herokuapp.com/">Де­мо-вер­сия.</a></p>

<p>По ма­те­ри­а­лам <a href="https://scotch.io/tutorials/build-a-to-do-app-with-vue-js-2">«Build a To-Do App with Vue.​js 2»</a> by Jeremy Kithome</p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Как сделать &#34;Избранное&#34; средствами Laravel и Vue.js</turbo:topic>
      <link>https://fokusov.com/posts/kak-sdelat-izbrannoe-sredstvami-laravel-i-vue_js/</link>
      <pubDate>Wed, 08 Mar 2017 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ 

<p><img src="img/x8d43c44b6d.jpg.pagespeed.ic.hMEwBRF9Rq.jpg" alt="Разработка: Как сделать Избранное средствами Laravel и Vue.js" /></p>

<p>В наше время большинство сайтов используют функционал избранного/лайков/рекомендаций. В том числе такие крупные ресурсы, как Medium, Facebook, Вконтакте и т.д.</p>

<p>Мы рассмотрим как реализовать такой функционал с Vue.js в приложении Laravel. Это приложение будет типа персонального блога, в нём будут пользователи и статьи. Пользователи смогут создавать статьи и добавлять их в избранное. А также пользователи смогут видеть полный список избранных статей.</p>

<p>В приложении будут модель User (Пользователь) и модель Post (Статья), в нём будет система авторизации, которая позволит добавлять статьи в Избранное (и удалять из него) только авторизованным пользователям. Мы сделаем динамическую пометку в избранное средствами VueJs и Axios, т.е. без перезагрузки страницы.</p>

<p>Перед началом работы посмотрите как это будет выглядеть:</p>

<p><img src="https://cdn.scotch.io/1965/LxHBEWRzSIyhY3j9FP06_ezgif.com-optimize%20(1).gif" alt="Разработка: Как сделать Избранное средствами Laravel и Vue.js" /></p>

<p>Итак, приступим.</p>

<p>Мы начнём с создания нового проекта Laravel:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">laravel new laravel-vue-favorite</pre></div>
<p>В результате будет создан проект с именем «laravel-vue-favorite»</p>

<p>С Laravel идут дополнительные библиотеки, такие как Bootstrap, VueJs и Axios, однако нужно их установить с помощью npm:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">npm install</pre></div>
<p>Также эта команда установит Laravel Mix, с помощью которого мы будем компилировать и собирать наши CSS и JavaScript.</p>

<h5 id="модели-миграции">Модели, миграции</h5>

<p>Итак, нам необходима модель User (она идёт с Laravel), модель Post и модель Favorite, а также файлы миграции для них.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">php artisan make:model Post -m
php artisan make:model Favorite -m</pre></div>
<p>Эти команды создадут нужные нам модели вместе с миграциями. Откроем файл миграции таблицы posts и обновим метод up():</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">/**
 * Define posts table schema
 */
public function up()
{
    Schema::create(&#39;posts&#39;, function (Blueprint $table) {
        $table-&gt;increments(&#39;id&#39;);
        $table-&gt;integer(&#39;user_id&#39;)-&gt;unsigned();
        $table-&gt;string(&#39;title&#39;);
        $table-&gt;text(&#39;body&#39;);
        $table-&gt;timestamps();
    });
}</pre></div>
<p>Таблица posts будет содержать id, user_id (ID пользователя, создавшего статью), title, body и колонки с отметками времени.</p>

<p>Теперь откроем файл миграций таблицы favorites и обновим up():</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">/**
 * Define favorites table schema
 */
public function up()
{
    Schema::create(&#39;favorites&#39;, function (Blueprint $table) {
        $table-&gt;increments(&#39;id&#39;);
        $table-&gt;integer(&#39;user_id&#39;)-&gt;unsigned();
        $table-&gt;integer(&#39;post_id&#39;)-&gt;unsigned();
        $table-&gt;timestamps();
    });
}</pre></div>
<p>Таблица favorites будет сводной. В ней будет две колонки:<br />
user_id, в которой будет храниться ID пользователя, добавившего статью в избранное и post_id, в которой будет ID отмеченной статьи.</p>

<p>Файл миграции таблицы users оставим без изменений.</p>

<p>Перед запуском миграций настроим базу данных. Для этого добавим соответствующие настройки в файл .env:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">DB_DATABASE=laravue
DB_USERNAME=root
DB_PASSWORD=root</pre></div>
<p>Здесь нужно указать свои параметры базы.</p>

<p>Теперь запустим миграции:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">php artisan migrate</pre></div>
<p>Для тестирования работы приложения нам необходимо внести в него какие-либо данные. Для их генерации воспользуемся Laravel Model Factories, они же в свою очередь используют Faker PHP library.</p>

<p>Сгенерируем данные по Пользователям и Статьям. Добавим немного кода в конец файла database/factories/ModelFactory.php:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// database/factories/ModelFactory.php

$factory-&gt;define(App\Post::class, function (Faker\Generator $faker) {
    // Get a random user
    $user = \App\User::inRandomOrder()-&gt;first();

    // generate fake data for post
    return [
        &#39;user_id&#39; =&gt; $user-&gt;id,
        &#39;title&#39; =&gt; $faker-&gt;sentence,
        &#39;body&#39; =&gt; $faker-&gt;text,
    ];
});</pre></div>
<p>После этого перейдём к созданию классов заполнения базы:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">php artisan make:seeder UsersTableSeeder
php artisan make:seeder PostsTableSeeder</pre></div>
<p>Теперь откроем database/seeds/UsersTableSeeder.php и обновим метод run():</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// database/seeds/UsersTableSeeder.php

/**
 * Run the database seeds to create users.
 *
 * @return void
 */
public function run()
{
    factory(App\User::class, 5)-&gt;create();
}</pre></div>
<p>В результате будут созданы 5 различных пользователей. Сделаем то же самое со статьями. Откроем database/seeds/PostsTableSeeder.php и обновим run():</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// database/seeds/PostsTableSeeder.php

/**
 * Run the database seeds to create posts.
 *
 * @return void
 */
public function run()
{
    factory(App\Post::class, 10)-&gt;create();
}</pre></div>
<p>В результате будут созданы 10 различных статей по окончании работы скрипта.</p>

<p>Перед запуском генераторов данных обновим файл database/seeds/DatabaseSeeder.php:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// database/seeds/DatabaseSeeder.php

/**
 * Run the database seeds.
 *
 * @return void
 */
public function run()
{
    $this-&gt;call(UsersTableSeeder::class);
    $this-&gt;call(PostsTableSeeder::class);
}</pre></div>
<p>И запустим генерацию данных:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">php artisan db:seed</pre></div>
<p>Готово.</p>

<h5 id="авторизация">Авторизация</h5>

<p>К счастью, в Laravel уже есть встроенная система авторизации. Нужно только запустить соответствующего мастера:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">php artisan make:auth</pre></div>
<p>Будут созданы необходимые роуты и представления для авторизации и нам остаётся только зарегистрироваться в системе.</p>

<h5 id="роуты">Роуты</h5>

<p>Откроем файл routes/web.php и изменим маршруты:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// routes/web.php

Auth::routes();

Route::get(&#39;/&#39;, &#39;PostsController@index&#39;);

Route::post(&#39;favorite/{post}&#39;, &#39;PostsController@favoritePost&#39;);
Route::post(&#39;unfavorite/{post}&#39;, &#39;PostsController@unFavoritePost&#39;);

Route::get(&#39;my_favorites&#39;, &#39;UsersController@myFavorites&#39;)-&gt;middleware(&#39;auth&#39;);</pre></div>
<p>После регистрации или авторизации пользователя Laravel перенаправит его на роут /home по-умолчанию. Мы удалили роут /home, созданный при запуске make:auth и поэтому нужно обновить свойство redirectTo в обоих файлах app/Http/Controllers/Auth/LoginController.php и app/Http/Controllers/Auth/RegisterController.php на:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">protected $redirectTo = &#39;/&#39;;</pre></div>
<h5 id="отношения-пользователь-избранное">Отношения Пользователь-Избранное</h5>

<p>Пользователь может добавить много статей в избранное, а статья может быть добавлена в избранное многими пользователями, поэтому отношения между этими таблицами будут многие-ко-многим. Для этого откроем модель User и добавим favorites():</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/User.php

/**
 * Get all of favorite posts for the user.
 */
public function favorites()
{
    return $this-&gt;belongsToMany(Post::class, &#39;favorites&#39;, &#39;user_id&#39;, &#39;post_id&#39;)-&gt;withTimeStamps();
}</pre></div>
<p>Laravel считает сводной таблицей post_user, но так как мы её переименовали (в favorites), нам нужно передать дополнительные параметры. Вторым параметром идёт имя сводной таблицы. Третьим &mdash; внешний ключ (user_id) модели, с которой создаётся связь (User), а четвёртым &mdash; внешний ключ (post_id) модели, к которой мы присоединяем (Post).</p>

<p>Обратите внимание, мы связали withTimeStamps() с belongsToMany(). Это позволит колонкам сводной таблицы с отметками времени (create_at и updated_at) автоматически сработать при добавлении или обновлении строки.</p>

<h5 id="контроллер-статей">Контроллер статей</h5>

<p>Создадим новый контроллер, в котором будут функции вывода статей, пометки в избранное и удаление такой отметки.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">php artisan make:controller PostsController</pre></div>
<p>Откроем app/Http/Controllers/PostsController.php и добавим в конец такой код:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/Http/Controllers/PostsController.php

// remember to use the Post model
use App\Post;

/**
 * Display a paginated list of posts.
 *
 * @return Response
 */
public function index()
{
    $posts = Post::paginate(5);

    return view(&#39;posts.index&#39;, compact(&#39;posts&#39;));
}</pre></div>
<p>Метод index() вернёт все статьи и разделит их по 5 на странице, а затем обработает файл представления (который мы создадим) со всеми статьями.</p>

<p>Добавим в файл resources/views/layouts/app.blade.php (пониже ) такой код:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// resources/views/layouts/app.blade.php

&lt;link rel=&#34;stylesheet&#34; href=&#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css&#34; /&gt;</pre></div>
<p>А затем это перед элементом списка Logout:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// resources/views/layouts/app.blade.php

&lt;li&gt;
    &lt;a href=&#34;{{ url(&#39;my_favorites&#39;) }}&#34;&gt;My Favorites&lt;/a&gt;
&lt;/li&gt;</pre></div>
<p>Теперь создадим представление index. Создайте папку posts внутри views и в ней файл index.blade.php. Получится resources/views/posts/index.blade.php:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// resources/views/posts/index.blade.php

@extends(&#39;layouts.app&#39;)

@section(&#39;content&#39;)
&lt;div class=&#34;container&#34;&gt;
    &lt;div class=&#34;row&#34;&gt;
        &lt;div class=&#34;col-md-8 col-md-offset-2&#34;&gt;
            &lt;div class=&#34;page-header&#34;&gt;
                &lt;h3&gt;All Posts&lt;/h3&gt;
            &lt;/div&gt;
            @forelse ($posts as $post)
                &lt;div class=&#34;panel panel-default&#34;&gt;
                    &lt;div class=&#34;panel-heading&#34;&gt;
                        {{ $post-&gt;title }}
                    &lt;/div&gt;

                    &lt;div class=&#34;panel-body&#34;&gt;
                        {{ $post-&gt;body }}
                    &lt;/div&gt;
                &lt;/div&gt;
            @empty
                &lt;p&gt;No post created.&lt;/p&gt;
            @endforelse

            {{ $posts-&gt;links() }}
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
@endsection</pre></div>
<p>Откройте браузер и увидите такую страничку:</p>

<p><img src="img/xf7e0763e8d.png.pagespeed.ic.f8yPAv6EjV.png" alt="Разработка: Как сделать Избранное средствами Laravel и Vue.js" /></p>

<p>Вернёмся к PostsController и добавим недостающие методы:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/Http/Controllers/PostsController.php

// remember to use
use Illuminate\Support\Facades\Auth;

/**
 * Favorite a particular post
 *
 * @param  Post $post
 * @return Response
 */
public function favoritePost(Post $post)
{
    Auth::user()-&gt;favorites()-&gt;attach($post-&gt;id);

    return back();
}

/**
 * Unfavorite a particular post
 *
 * @param  Post $post
 * @return Response
 */
public function unFavoritePost(Post $post)
{
    Auth::user()-&gt;favorites()-&gt;detach($post-&gt;id);

    return back();
}</pre></div>
<h5 id="добавляем-vuejs">Добавляем VueJs</h5>

<p>С помощью Vue мы сделаем кнопку Избранного. По нажатию на неё, статья добавиться в избранное (или удалится из избранного) без перезагрузки страницы, используя AJAX. Здесь нам пригодится Axios &mdash; основанный на Promise HTTP-клиент для браузера и node.js.</p>

<p>Создадим компонент Vue, для этого создайте файл Favorite.vue в папке resources/assets/js/components с таким содержимым:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// resources/assets/js/components/Favorite.vue

&lt;template&gt;
    &lt;span&gt;
        &lt;a href=&#34;#&#34; v-if=&#34;isFavorited&#34; @click.prevent=&#34;unFavorite(post)&#34;&gt;
            &lt;i  class=&#34;fa fa-heart&#34;&gt;&lt;/i&gt;
        &lt;/a&gt;
        &lt;a href=&#34;#&#34; v-else @click.prevent=&#34;favorite(post)&#34;&gt;
            &lt;i  class=&#34;fa fa-heart-o&#34;&gt;&lt;/i&gt;
        &lt;/a&gt;
    &lt;/span&gt;
&lt;/template&gt;

&lt;script&gt;
    export default {
        props: [&#39;post&#39;, &#39;favorited&#39;],

        data: function() {
            return {
                isFavorited: &#39;&#39;,
            }
        },

        mounted() {
            this.isFavorited = this.isFavorite ? true : false;
        },

        computed: {
            isFavorite() {
                return this.favorited;
            },
        },

        methods: {
            favorite(post) {
                axios.post(&#39;/favorite/&#39;+post)
                    .then(response =&gt; this.isFavorited = true)
                    .catch(response =&gt; console.log(response.data));
            },

            unFavorite(post) {
                axios.post(&#39;/unfavorite/&#39;+post)
                    .then(response =&gt; this.isFavorited = false)
                    .catch(response =&gt; console.log(response.data));
            }
        }
    }
&lt;/script&gt;</pre></div>
<p>В компоненте Favorite есть два раздела: template и script. В template мы задали разметку, которая будет обработана при вызове компонента. Мы используем обработку с условием, она нам должна вывести нужную кнопку. То есть если isFavorited равно true, кнопка должна быть отмечена как избранная и при нажатии вызвать unFavorite(). В противном случае она выглядит как не помеченная и вызывает при клике метод favorite().</p>

<p>В разделе script мы задали свойства компонента &mdash; post (тут будет ID статьи) и favorited (true или false в зависимости от того, в каком он состоянии для текущего авторизованного пользователя). Также мы задали переменную isFavorited для условной обработки шаблона.</p>

<p>При подключении компонента мы задаём значение isFavorited равным рассчитанному свойству isFavorite. То есть свойство isFavorite вернёт значение свойства favorited, которое может быть true или false.</p>

<p>Также мы создали два метода: favorite() и unFavorite(), оба принимающие post как аргумент. С помощью Axios мы делаем POST-запрос к заданным ранее роутам. В favorite(), при успешном POST-запросе, мы задаём isFavorited в true, иначе выводим ошибку в консоль. То же самое и для unFavorite() &mdash; только меняем isFavorited на false.</p>

<h5 id="регистрация-компонента">Регистрация компонента</h5>

<p>Перед использованием компонента необходимо зарегистрировать его в экземпляре Vue. Открыв resources/assets/js/app.js вы увидите, что Laravel зарегистрировал компонент Example. Заменим его на наш Favorite:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// resources/assets/js/app.js

Vue.component(&#39;favorite&#39;, require(&#39;./components/Favorite.vue&#39;));</pre></div>
<p>Теперь скомпилируем и соберём наши стили и скрипты:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">npm run dev</pre></div>
<p>Теперь можно использовать наш компонент. Откроем resources/views/posts/index.blade.php и добавим в конец (после закрывающего div в panel-body) такой код:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// resources/views/posts/index.blade.php

@if (Auth::check())
    &lt;div class=&#34;panel-footer&#34;&gt;
        &lt;favorite
            :post={{ $post-&gt;id }}
            :favorited={{ $post-&gt;favorited() ? &#39;true&#39; : &#39;false&#39; }}
        &gt;&lt;/favorite&gt;
    &lt;/div&gt;
@endif</pre></div>
<p>Теперь кнопка добавления в избранное будет показана только авторизованным пользователям. А чтобы узнать, добавлена ли статья в избранное, нужен метод favorited(), который мы и создадим. Откройте app/Post.php и добавьте код:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/Post.php

// remember to use
use App\Favorite;
use Illuminate\Support\Facades\Auth;

/**
 * Determine whether a post has been marked as favorite by a user.
 *
 * @return boolean
 */
public function favorited()
{
    return (bool) Favorite::where(&#39;user_id&#39;, Auth::id())
                        -&gt;where(&#39;post_id&#39;, $this-&gt;id)
                        -&gt;first();
}</pre></div>
<p>Здесь мы получаем и приводим к булеву первую строку запроса, где user_id это идентификатор текущего пользователя, а post_id это идентификатор статьи, с которой мы работаем сейчас.</p>

<p>Теперь наше приложение будет выглядеть так:</p>

<p><img src="img/x4889091451.png.pagespeed.ic.d-ERjzP7Y3.png" alt="Разработка: Как сделать Избранное средствами Laravel и Vue.js" /></p>

<h5 id="вывод-избранного">Вывод избранного</h5>

<p>Для вывода избранных статей мы создали ранее роут my_favorites, доступный только авторизованным пользователям.</p>

<p>Создадим UsersController, обрабатывающий этот роут:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">php artisan make:controller UsersController</pre></div>
<p>Теперь откроем app/Http/Controllers/UsersController.php и добавим код:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/Http/Controllers/UsersController.php

// remember to use
use Illuminate\Support\Facades\Auth;

/**
 * Get all favorite posts by user
 *
 * @return Response
 */
public function myFavorites()
{
    $myFavorites = Auth::user()-&gt;favorites;

    return view(&#39;users.my_favorites&#39;, compact(&#39;myFavorites&#39;));
}</pre></div>
<p>Теперь создадим представление. Создайте папку users в resources/views, а в ней файл my_favorites.blade.php:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// resources/views/users/my_favorites.blade.php

@extends(&#39;layouts.app&#39;)

@section(&#39;content&#39;)
&lt;div class=&#34;container&#34;&gt;
    &lt;div class=&#34;row&#34;&gt;
        &lt;div class=&#34;col-md-8 col-md-offset-2&#34;&gt;
            &lt;div class=&#34;page-header&#34;&gt;
                &lt;h3&gt;My Favorites&lt;/h3&gt;
            &lt;/div&gt;
            @forelse ($myFavorites as $myFavorite)
                &lt;div class=&#34;panel panel-default&#34;&gt;
                    &lt;div class=&#34;panel-heading&#34;&gt;
                        {{ $myFavorite-&gt;title }}
                    &lt;/div&gt;

                    &lt;div class=&#34;panel-body&#34;&gt;
                        {{ $myFavorite-&gt;body }}
                    &lt;/div&gt;
                    @if (Auth::check())
                        &lt;div class=&#34;panel-footer&#34;&gt;
                            &lt;favorite
                                :post={{ $myFavorite-&gt;id }}
                                :favorited={{ $myFavorite-&gt;favorited() ? &#39;true&#39; : &#39;false&#39; }}
                            &gt;&lt;/favorite&gt;
                        &lt;/div&gt;
                    @endif
                &lt;/div&gt;
            @empty
                &lt;p&gt;You have no favorite posts.&lt;/p&gt;
            @endforelse
         &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
@endsection</pre></div>
<p><img src="https://tehnojam.pro/uploads/images/00/00/24/2017/03/08/x6ee53a54ea.png.pagespeed.ic._5WfxkUJo0.png" alt="Разработка: Как сделать Избранное средствами Laravel и Vue.js" /></p>

<p>Готово!</p>

<p><a href="https://github.com/ammezie/laravel-vue-favorite">Полный код примера.</a></p>

<p>По материалам «Implement a Favoriting Feature Using Laravel and Vue.js» by Chimezie Enyinnaya</p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Создание одностраничного веб-приложения на Go, Echo и Vue</turbo:topic>
      <link>https://fokusov.com/posts/sozdanie-odnostranichnogo-veb-prilozhenija-na-go-echo-i-vue/</link>
      <pubDate>Tue, 28 Feb 2017 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ 

<p><img src="img/x298348afc3.jpg.pagespeed.ic.1CfsQjTWva.jpg" alt="Разработка: Создание одностраничного веб-приложения на Go, Echo и Vue" /></p>

<p>Се­год­ня мы со­зда­дим неслож­ное при­ло­же­ние для ве­де­ния спис­ка за­дач. В нём мож­но бу­дет ука­зы­вать на­име­но­ва­ние за­да­чи, вы­во­дить со­здан­ные за­да­чи на экран и уда­лять за­да­чи.</p>

<p>Бэ­кенд при­ло­же­ния бу­дет на­пи­сан на язы­ке Go. Для луч­ше­го по­ни­ма­ния ма­те­ри­а­ла необ­хо­ди­мы хо­тя бы ми­ни­маль­ные зна­ния син­так­си­са и уста­нов­лен­ный Go.</p>

<p>Что­бы уско­рить со­зда­ние при­ло­же­ния, мы возь­мём мик­ро-фрейм­ворк <a href="https://echo.labstack.com/">Echo</a>. А за­да­чи мы бу­дем хра­нить в ба­зе SQLite.</p>

<p>Фрон­тенд мы со­зда­дим на HTML5 с по­пу­ляр­ным Javascript фрейм­вор­ком <a href="http://vuejs.org/">VueJS</a>.</p>

<h5 id="ро-уты-и-ба-за-дан-ных">Ро­уты и ба­за дан­ных</h5>

<p>Вна­ча­ле уста­но­вим недо­ста­ю­щие биб­лио­те­ки:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ go get github.com/labstack/echo
$ go get github.com/mattn/go-sqlite3</pre></div>
<p>И со­зда­дим ди­рек­то­рию для на­ше­го про­ек­та:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ cd $GOPATH/src
$ mkdir go-echo-vue &amp;&amp; cd go-echo-vue</pre></div>
<p>Нач­нём с со­зда­ния ро­у­тов. Со­здай­те файл <strong>todo.go</strong> в корне со­здан­ной пап­ки с та­ким со­дер­жи­мым:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#007f7f">// todo.go
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">package</span> main

<span style="color:#fff;font-weight:bold">import</span> (
    <span style="color:#0ff;font-weight:bold">&#34;github.com/labstack/echo&#34;</span>
    <span style="color:#0ff;font-weight:bold">&#34;github.com/labstack/echo/engine/standard&#34;</span>
)

<span style="color:#fff;font-weight:bold">func</span> main() {
    <span style="color:#007f7f">// Create a new instance of Echo
</span><span style="color:#007f7f"></span>    e := echo.New()

    e.GET(<span style="color:#0ff;font-weight:bold">&#34;/tasks&#34;</span>, <span style="color:#fff;font-weight:bold">func</span>(c echo.Context) <span style="color:#fff;font-weight:bold">error</span> { <span style="color:#fff;font-weight:bold">return</span> c.JSON(<span style="color:#ff0;font-weight:bold">200</span>, <span style="color:#0ff;font-weight:bold">&#34;GET Tasks&#34;</span>) })
    e.PUT(<span style="color:#0ff;font-weight:bold">&#34;/tasks&#34;</span>, <span style="color:#fff;font-weight:bold">func</span>(c echo.Context) <span style="color:#fff;font-weight:bold">error</span> { <span style="color:#fff;font-weight:bold">return</span> c.JSON(<span style="color:#ff0;font-weight:bold">200</span>, <span style="color:#0ff;font-weight:bold">&#34;PUT Tasks&#34;</span>) })
    e.DELETE(<span style="color:#0ff;font-weight:bold">&#34;/tasks/:id&#34;</span>, <span style="color:#fff;font-weight:bold">func</span>(c echo.Context) <span style="color:#fff;font-weight:bold">error</span> { <span style="color:#fff;font-weight:bold">return</span> c.JSON(<span style="color:#ff0;font-weight:bold">200</span>, <span style="color:#0ff;font-weight:bold">&#34;DELETE Task &#34;</span>+c.Param(<span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>)) })

    <span style="color:#007f7f">// Start as a web server
</span><span style="color:#007f7f"></span>    e.Run(standard.New(<span style="color:#0ff;font-weight:bold">&#34;:8000&#34;</span>))
}</pre></div>
<p>Здесь мы им­пор­ти­ро­ва­ли фрейм­ворк Echo и со­зда­ли обя­за­тель­ный ме­тод <strong>main()</strong>. За­тем в нём со­зда­ли эк­зем­пляр Echo и за­да­ли несколь­ко ро­у­тов. При со­зда­нии ро­у­та ему пе­ре­да­ёт­ся шаб­лон за­про­са пер­вым па­ра­мет­ром и функ­ция-об­ра­бот­чик вто­рым.<br />
На­ши ро­уты по­ка мо­гут толь­ко вы­да­вать ста­ти­че­ский текст, до­ра­бо­та­ем их поз­же. А в кон­це мы за­пус­ка­ем на­ше при­ло­же­ние по ад­ре­су <a href="http://localhost:8000">localhost:8000</a> ис­поль­зуя встро­ен­ный в Go HTTP-сер­вер.</p>

<p>Для те­сти­ро­ва­ния ра­бо­ты ро­у­тов сна­ча­ла ском­пи­ли­ру­ем при­ло­же­ние и за­пу­стим его, а по­том вос­поль­зу­ем­ся рас­ши­ре­ни­ем Chrome под на­зва­ни­ем <a href="https://www.getpostman.com/">Postman</a>.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ go build todo.go
$ ./todo</pre></div>
<p>По­сле за­пус­ка при­ло­же­ния от­кро­ем Postman и под­клю­чим его к ад­ре­су localhost:8000. Нуж­но про­те­сти­ро­вать ро­ут &ldquo;/tasks&rdquo; с по­мо­щью за­про­сов GET, PUT и DELETE, об­ра­бот­чи­ки ко­то­рых мы со­зда­ли ра­нее.<br />
Ес­ли всё ра­бо­та­ет пра­виль­но, мы уви­дим сле­ду­ю­щую кар­ти­ну:<br />
<img src="img/x92ce5c1ed8.png.pagespeed.ic.INFkuflyW6.png" alt="Разработка: Создание одностраничного веб-приложения на Go, Echo и Vue" /><br />
<img src="img/xf26e879ab0.png.pagespeed.ic.gaDUln35En.png" alt="Разработка: Создание одностраничного веб-приложения на Go, Echo и Vue" /><br />
<img src="img/xa7e3a92121.png.pagespeed.ic.RMNQtkXLna.png" alt="Разработка: Создание одностраничного веб-приложения на Go, Echo и Vue" /></p>

<p>Те­перь пе­рей­дём к со­зда­нию ба­зы дан­ных. На­зо­вём файл «storage.db» и ес­ли его нет, драй­вер со­здаст его для нас.<br />
По­сле со­зда­ния ба­зы дан­ных необ­хо­ди­мо бу­дет за­пу­стить ми­гра­ции.</p>

<p>До­ра­бо­та­ем наш файл todo.go:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#007f7f">// todo.go
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">package</span> main
<span style="color:#fff;font-weight:bold">import</span> (
    <span style="color:#0ff;font-weight:bold">&#34;database/sql&#34;</span>

    <span style="color:#0ff;font-weight:bold">&#34;github.com/labstack/echo&#34;</span>
    <span style="color:#0ff;font-weight:bold">&#34;github.com/labstack/echo/engine/standard&#34;</span>
    _ <span style="color:#0ff;font-weight:bold">&#34;github.com/mattn/go-sqlite3&#34;</span>
)</pre></div>
<p>И до­ра­бо­та­ем ме­тод main():</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// todo.go
func main() {

    db := initDB(&#34;storage.db&#34;)
    migrate(db)</pre></div>
<p>До­ба­вим ме­тод ра­бо­ты с ба­зой дан­ных:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// todo.go
func initDB(filepath string) *sql.DB {
    //откроем файл или создадим его
    db, err := sql.Open(&#34;sqlite3&#34;, filepath)

    // проверяем ошибки и выходим при их наличии
    if err != nil {
        panic(err)
    }

    // если ошибок нет, но не можем подключиться к базе данных,
    // то так же выходим
    if db == nil {
        panic(&#34;db nil&#34;)
    }
    return db
}

func migrate(db *sql.DB) {
    sql := `
    CREATE TABLE IF NOT EXISTS tasks(
        id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
        name VARCHAR NOT NULL
    );
    `

    _, err := db.Exec(sql)
    // выходим, если будут ошибки с SQL запросом выше
    if err != nil {
        panic(err)
    }
}</pre></div>
<p>Здесь мы про­сто со­зда­ём таб­ли­цу для на­ших за­дач, ес­ли её ещё нет и за­вер­ша­ем при­ло­же­ние при лю­бой ошиб­ке.</p>

<p>Про­те­сти­ру­ем ещё раз:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ go build todo.go
$ ./todo</pre></div>
<p>Те­перь от­кро­ем тер­ми­нал, пе­рей­дём в пап­ку про­ек­та и за­пу­стим сле­ду­ю­щую ко­ман­ду для про­вер­ки со­здан­но­го фай­ла БД:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ sqlite3 storage.db</pre></div>
<p>Ес­ли у вас не по­лу­чи­лось за­пу­стить ко­ман­ду sqlite, воз­мож­но тре­бу­ет­ся уста­но­вить её с <a href="https://www.sqlite.org/download.html">офи­ци­аль­но­го сай­та</a> или че­рез ме­не­джер па­ке­тов ва­шей ОС.</p>

<p>Ес­ли ко­ман­да за­пу­сти­лась, то вве­ди­те ко­ман­ду <strong>&rdquo;.tables&rdquo;</strong>. Вы долж­ны уви­деть при­мер­но сле­ду­ю­щее:<br />
<img src="img/xe8bccf48fe.png.pagespeed.ic.fw4-hORS58.png" alt="Разработка: Создание одностраничного веб-приложения на Go, Echo и Vue" /><br />
Что­бы вый­ти, вве­ди­те &ldquo;.quit&rdquo;.</p>

<h5 id="об-ра-бот-чи-ки">Об­ра­бот­чи­ки</h5>

<p>Мы со­зда­ли об­ра­бот­чи­ки за­про­сов, те­перь нам нуж­но до­ра­бо­тать их.<br />
От­кро­ем файл <strong>todo.go</strong> и вста­вим в блок им­пор­тов файл с об­ра­бот­чи­ка­ми, ко­то­рый со­зда­дим поз­же:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#fff;font-weight:bold">package</span> main
<span style="color:#fff;font-weight:bold">import</span> (
    <span style="color:#0ff;font-weight:bold">&#34;database/sql&#34;</span>
    <span style="color:#0ff;font-weight:bold">&#34;go-echo-vue/handlers&#34;</span>

    <span style="color:#0ff;font-weight:bold">&#34;github.com/labstack/echo&#34;</span>
    <span style="color:#0ff;font-weight:bold">&#34;github.com/labstack/echo/engine/standard&#34;</span>
    _ <span style="color:#0ff;font-weight:bold">&#34;github.com/mattn/go-sqlite3&#34;</span>
)</pre></div>
<p>Тут же до­ра­бо­та­ем вы­зо­вы об­ра­бот­чи­ков:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// todo.go
    e := echo.New()

    e.File(&#34;/&#34;, &#34;public/index.html&#34;)
    e.GET(&#34;/tasks&#34;, handlers.GetTasks(db))
    e.PUT(&#34;/tasks&#34;, handlers.PutTask(db))
    e.DELETE(&#34;/tasks/:id&#34;, handlers.DeleteTask(db))

    e.Run(standard.New(&#34;:8000&#34;))
}</pre></div>
<p>Здесь мы до­ба­ви­ли к су­ще­ству­ю­щим ро­у­там до­пол­ни­тель­ный. В этом html-фай­ле мы бу­дем хра­нить код VueJS.</p>

<p>Те­перь со­зда­дим ди­рек­то­рию &lsquo;handlers&rsquo;, а в ней файл «tasks.go»:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#007f7f">// handlers/tasks.go
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">package</span> handlers

<span style="color:#fff;font-weight:bold">import</span> (
    <span style="color:#0ff;font-weight:bold">&#34;database/sql&#34;</span>
    <span style="color:#0ff;font-weight:bold">&#34;net/http&#34;</span>
    <span style="color:#0ff;font-weight:bold">&#34;strconv&#34;</span>

    <span style="color:#0ff;font-weight:bold">&#34;github.com/labstack/echo&#34;</span>
)</pre></div>
<p>А в стро­ке ни­же бу­дет неболь­шой трюк, ко­то­рый поз­во­лит воз­вра­щать про­из­воль­ный JSON. Это про­сто map со клю­ча­ми ти­па string и лю­бым ти­пом зна­че­ния.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// handlers/tasks.go
type H map[string]interface{}</pre></div>
<p>Для то­го, что­бы про­сто про­ве­рить ра­бо­ту об­ра­бот­чи­ков, сде­ла­ем вы­вод ле­вых дан­ных, а не из ба­зы дан­ных:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// handlers/tasks.go

// конечная точка GetTasks
func GetTasks(db *sql.DB) echo.HandlerFunc {
    return func(c echo.Context) error {
        return c.JSON(http.StatusOK, &#34;tasks&#34;)
    }
}

// конечная точка PutTask
func PutTask(db *sql.DB) echo.HandlerFunc {
    return func(c echo.Context) error {
        return c.JSON(http.StatusCreated, H{
            &#34;created&#34;: 123,
    }
}

// конечная точка DeleteTask
func DeleteTask(db *sql.DB) echo.HandlerFunc {
    return func(c echo.Context) error {
        id, _ := strconv.Atoi(c.Param(&#34;id&#34;))
        return c.JSON(http.StatusOK, H{
            &#34;deleted&#34;: id,
        })
    }
}</pre></div>
<p>Биб­лио­те­ка http в Go поз­во­ля­ет ра­бо­тать со ста­ту­са­ми HTTP и мы мо­жем от­ве­тить http.StatusCreated для за­про­са PUT.<br />
Функ­ция «DeleteTask» при­ни­ма­ет па­ра­мет­ром id за­да­чи, а мы с по­мо­щью па­ке­та strconv и ме­то­да Atoi (alpha в чис­ло) про­ве­ря­ем, что id это чис­ло. Так мы бо­лее без­опас­но смо­жем пе­ре­дать за­прос к ба­зе дан­ных поз­же.</p>

<p>Пе­ре­со­бе­рём при­ло­же­ние и за­но­во за­пу­стим Postman:</p>

<p><img src="img/x4b02ced590.png.pagespeed.ic.KUqkAJBZnu.png" alt="Разработка: Создание одностраничного веб-приложения на Go, Echo и Vue" /><br />
<img src="img/xc259deaab4.png.pagespeed.ic.IM3fdtQUFr.png" alt="Разработка: Создание одностраничного веб-приложения на Go, Echo и Vue" /><br />
<img src="img/x541afda119.png.pagespeed.ic.lvqUUeV1c8.png" alt="Разработка: Создание одностраничного веб-приложения на Go, Echo и Vue" /></p>

<h5 id="мо-дель">Мо­дель</h5>

<p>Нам оста­лось под­клю­чить при­ло­же­ние к ба­зе дан­ных. Вме­сто то­го, что­бы де­лать пря­мые вы­зо­вы из об­ра­бот­чи­ков, мы со­хра­ним код про­стым, пре­вра­тив ло­ги­ку ба­зы дан­ных в мо­дель.</p>

<p>Но сна­ча­ла вклю­чим ссыл­ки на на­шу мо­дель в со­здан­ный файл об­ра­бот­чи­ков.<br />
Вклю­чим файл мо­де­лей в блок им­пор­та:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#007f7f">// handlers/tasks.go
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">package</span> handlers

<span style="color:#fff;font-weight:bold">import</span> (
    <span style="color:#0ff;font-weight:bold">&#34;database/sql&#34;</span>
    <span style="color:#0ff;font-weight:bold">&#34;net/http&#34;</span>
    <span style="color:#0ff;font-weight:bold">&#34;strconv&#34;</span>

    <span style="color:#0ff;font-weight:bold">&#34;go-echo-vue/models&#34;</span>

    <span style="color:#0ff;font-weight:bold">&#34;github.com/labstack/echo&#34;</span>
)</pre></div>
<p>За­тем до­ба­вим вы­зо­вы к мо­де­ли в ме­тод об­ра­бот­чи­ка:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// handlers/tasks.go

// конечная точка GetTasks
func GetTasks(db *sql.DB) echo.HandlerFunc {
    return func(c echo.Context) error {
        // получаем задачи из модели
        return c.JSON(http.StatusOK, models.GetTasks(db))
    }
}

// конечная точка PutTask
func PutTask(db *sql.DB) echo.HandlerFunc {
    return func(c echo.Context) error {
        // создаём новую задачу
        var task models.Task
        // привязываем пришедший JSON в новую задачу
        c.Bind(&amp;task)
        // добавим задачу с помощью модели
        id, err := models.PutTask(db, task.Name)
        // вернём ответ JSON при успехе
        if err == nil {
            return c.JSON(http.StatusCreated, H{
                &#34;created&#34;: id,
            })
        // обработка ошибок
        } else {
            return err
        }
    }
}

// конечная точка DeleteTask
func DeleteTask(db *sql.DB) echo.HandlerFunc {
    return func(c echo.Context) error {
        id, _ := strconv.Atoi(c.Param(&#34;id&#34;))
        // используем модель для удаления задачи
        _, err := models.DeleteTask(db, id)
        // вернём ответ JSON при успехе
        if err == nil {
            return c.JSON(http.StatusOK, H{
                &#34;deleted&#34;: id,
            })
        // обработка ошибок
        } else {
            return err
        }
    }
}</pre></div>
<p>А те­перь со­зда­дим мо­дель. Со­здай­те ка­та­лог «models», а в нём файл «tasks.go».</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#007f7f">// models/tasks.go
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">package</span> models

<span style="color:#fff;font-weight:bold">import</span> (
    <span style="color:#0ff;font-weight:bold">&#34;database/sql&#34;</span>

    _ <span style="color:#0ff;font-weight:bold">&#34;github.com/mattn/go-sqlite3&#34;</span>
)

<span style="color:#007f7f">// Task это структура с данными задачи
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">type</span> Task <span style="color:#fff;font-weight:bold">struct</span> {
    ID   <span style="color:#fff;font-weight:bold">int</span>    <span style="color:#0ff;font-weight:bold">`json:&#34;id&#34;`</span>
    Name <span style="color:#fff;font-weight:bold">string</span> <span style="color:#0ff;font-weight:bold">`json:&#34;name&#34;`</span>
}

<span style="color:#007f7f">// TaskCollection это список задач
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">type</span> TaskCollection <span style="color:#fff;font-weight:bold">struct</span> {
    Tasks []Task <span style="color:#0ff;font-weight:bold">`json:&#34;items&#34;`</span>
}</pre></div>
<p>Мы со­зда­ли тип «Task» &mdash; струк­ту­ру с дву­мя по­ля­ми, ID и Name. Go поз­во­ля­ет до­бав­лять ме­та­дан­ные с по­мо­щью об­рат­ных ка­вы­чек. Мы ука­за­ли, что хо­тим ви­деть по­ля в ви­де JSON. И это поз­во­ля­ет функ­ции «c.​Bind» (из об­ра­бот­чи­ков) знать, ка­кие при­вяз­ки дан­ных нуж­ны при со­зда­нии но­вой за­да­чи.<br />
Тип «TaskCollection» это про­сто кол­лек­ция на­ших за­дач. Мы ис­поль­зу­ем её при воз­вра­те спис­ка всех за­дач из ба­зы дан­ных.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// models/tasks.go

func GetTasks(db *sql.DB) TaskCollection {
    sql := &#34;SELECT * FROM tasks&#34;
    rows, err := db.Query(sql)
    // выходим, если SQL не сработал по каким-то причинам
    if err != nil {
        panic(err)
    }
    // убедимся, что всё закроется при выходе из программы
    defer rows.Close()

    result := TaskCollection{}
    for rows.Next() {
        task := Task{}
        err2 := rows.Scan(&amp;task.ID, &amp;task.Name)
        // выход при ошибке
        if err2 != nil {
            panic(err2)
        }
        result.Tasks = append(result.Tasks, task)
    }
    return result
}</pre></div>
<p>Ме­тод GetTasks вы­би­ра­ет все за­да­чи из ба­зы дан­ных, до­бав­ля­ет их в но­вую кол­лек­цию за­дач, и воз­вра­ща­ет их.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// models/tasks.go

func PutTask(db *sql.DB, name string) (int64, error) {
    sql := &#34;INSERT INTO tasks(name) VALUES(?)&#34;

    // выполним SQL запрос
    stmt, err := db.Prepare(sql)
    // выход при ошибке
    if err != nil {
        panic(err)
    }
    // убедимся, что всё закроется при выходе из программы
    defer stmt.Close()

    // заменим символ &#39;?&#39; в запросе на &#39;name&#39;
    result, err2 := stmt.Exec(name)
    // выход при ошибке
    if err2 != nil {
        panic(err2)
    }

    return result.LastInsertId()
}</pre></div>
<p>Ме­тод PutTask встав­ля­ет но­вую за­да­чу в ба­зу дан­ных и воз­вра­ща­ет её id при успе­хе или panic при неуда­че.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// models/tasks.go

func DeleteTask(db *sql.DB, id int) (int64, error) {
    sql := &#34;DELETE FROM tasks WHERE id = ?&#34;

    // выполним SQL запрос
    stmt, err := db.Prepare(sql)
    // выход при ошибке
    if err != nil {
        panic(err)
    }

    // заменим символ &#39;?&#39; в запросе на &#39;id&#39;
    result, err2 := stmt.Exec(id)
    // выход при ошибке
    if err2 != nil {
        panic(err2)
    }

    return result.RowsAffected()
}</pre></div>
<p>Мож­но ещё раз про­те­сти­ро­вать при­ло­же­ние с Postman. Про­ве­рим ро­ут «GET /tasks» &mdash; в от­вет дол­жен прий­ти JSON с «tasks» рав­ным null:<br />
<img src="img/xd145f4391f.png.pagespeed.ic.11e_TRrEvY.png" alt="Разработка: Создание одностраничного веб-приложения на Go, Echo и Vue" /><br />
До­ба­вим за­да­чу. В Postman пе­ре­клю­чи­те ме­тод на «PUT», за­тем от­крой­те вклад­ку «Body». Вы­бе­ри­те «raw», за­тем JSON (application/json) как тип. В тек­сто­вом по­ле вве­ди­те сле­ду­ю­щее:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">{
    &#34;name&#34;: &#34;Foobar&#34;
}</pre></div>
<p>В от­вет долж­но прий­ти &lsquo;created&rsquo;, ти­па та­ко­го:<br />
<img src="img/xde9015cdce.png.pagespeed.ic.aMX-iNuZiz.png" alt="Разработка: Создание одностраничного веб-приложения на Go, Echo и Vue" /><br />
Об­ра­ти­те вни­ма­ние, id вер­нул­ся пот­му, что нам нуж­но про­те­сти­ро­вать ро­ут «DELETE /tasks». Сме­ни­те ме­тод на «DELETE» и ука­жи­те Postman &ldquo;/tasks/:id&rdquo;, за­ме­нив &ldquo;:id&rdquo; на id, ко­то­рый вер­нул­ся в про­шлом пунк­те. В от­вет долж­но прий­ти со­об­ще­ние об успе­хе «deleted».<br />
<img src="img/xbaa8f3cb02.png.pagespeed.ic.FP5BJnnd-X.png" alt="Разработка: Создание одностраничного веб-приложения на Go, Echo и Vue" /><br />
Ес­ли всё хо­ро­шо, то за­про­сив «GET /tasks», вы по­лу­чи­те в от­вет null.</p>

<h5 id="фрон-тенд">Фрон­тенд</h5>

<p>Для про­сто­ты из­ло­же­ния, мы вклю­чим код Javascript в файл раз­мет­ки HTML. Вклю­чим несколь­ко биб­лио­тек: Bootstrap, JQuery и, ко­неч­но, VueJS. В ин­тер­фей­се у нас бу­дет толь­ко по­ле вво­да, кноп­ки и неупо­ря­до­чен­ный спи­сок для на­ших за­дач.<br />
Со­здай­те ди­рек­то­рию &lsquo;public&rsquo; и в ней файл «index.html»:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- public/index.html --&gt;

&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv=&#34;content-type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;

        &lt;title&gt;TODO App&lt;/title&gt;

        &lt;!-- Latest compiled and minified CSS --&gt;
        &lt;link rel=&#34;stylesheet&#34; href=&#34;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&#34;&gt;

        &lt;!-- Font Awesome --&gt;
        &lt;link rel=&#34;stylesheet&#34;  href=&#34;https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css&#34;&gt;

        &lt;!-- JQuery --&gt;
        &lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js&#34;&gt;&lt;/script&gt;

        &lt;!-- Latest compiled and minified JavaScript --&gt;
        &lt;script src=&#34;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js&#34;&gt;&lt;/script&gt;

        &lt;!-- Vue.js --&gt;
        &lt;script src=&#34;http://cdnjs.cloudflare.com/ajax/libs/vue/1.0.24/vue.min.js&#34;&gt;&lt;/script&gt;
        &lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/vue-resource/0.7.0/vue-resource.min.js&#34;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&#34;container&#34;&gt;
            &lt;div class=&#34;row&#34;&gt;
                &lt;div class=&#34;col-md-4&#34;&gt;
                    &lt;h2&gt;My Tasks&lt;/h2&gt;
                    &lt;ul class=&#34;list-group&#34;&gt;
                        &lt;li class=&#34;list-group-item&#34; v-for=&#34;task in tasks&#34;&gt;
                            {{ task.name }}
                            &lt;span class=&#34;pull-right&#34;&gt;
                                &lt;button class=&#34;btn btn-xs btn-danger&#34; v-on:click=&#34;deleteTask($index)&#34;&gt;
                                    &lt;i class=&#34;fa fa-trash-o&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
                                &lt;/button&gt;
                            &lt;/span&gt;
                        &lt;/li&gt;
                    &lt;/ul&gt;
                    &lt;div class=&#34;input-group&#34;&gt;
                        &lt;input type=&#34;text&#34;
                            class=&#34;form-control&#34;
                            placeholder=&#34;New Task&#34;
                            v-on:keyup.enter=&#34;createTask&#34;
                            v-model=&#34;newTask.name&#34;&gt;
                        &lt;span class=&#34;input-group-btn&#34;&gt;
                            &lt;button class=&#34;btn btn-primary&#34; type=&#34;button&#34; v-on:click=&#34;createTask&#34;&gt;Create&lt;/button&gt;
                        &lt;/span&gt;
                    &lt;/div&gt;&lt;!-- /input-group --&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div>
<p>Пе­ре­со­бе­ри­те при­ло­же­ние, за­пу­сти­те его и от­крой­те в бра­у­зе­ре localhost:8000.<br />
<img src="img/x27cbe8c6f9.png.pagespeed.ic.cg-x5UmDRQ.png" alt="Разработка: Создание одностраничного веб-приложения на Go, Echo и Vue" /></p>

<p>Ни­же по­след­не­го те­га «div» мы раз­ме­стим наш код VueJS в те­ге «script». Код этот не очень прост, но хо­ро­шо про­ком­мен­ти­ро­ван. Здесь у нас несколь­ко ме­то­дов для со­зда­ния и уда­ле­ния за­дач, а та­к­же ме­тод ини­ци­а­ли­за­ции, воз­вра­ща­ю­щий спи­сок всех за­дач в ба­зе.<br />
Для об­ще­ния с бэ­кен­дом нам по­на­до­бит­ся HTTP кли­ент, мы бу­дем ис­поль­зо­вать vue-resource так: «this.$http» и да­лее что нам нуж­но, ти­па (get, put, и т.п.).</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- public/index.html --&gt;

        &lt;script&gt;
            new Vue({
                el: &#39;body&#39;,

                data: {
                    tasks: [],
                    newTask: {}
                },

          // запускаем при загрузке страницы, чтобы у нас был актуальный список всех задач
                created: function() {
        // используем $http-клиента из vue-resource для получения данных от роута /tasks
                    this.$http.get(&#39;/tasks&#39;).then(function(response) {
                        this.tasks = response.data.items ? response.data.items : []
                    })
                },

                methods: {
                    createTask: function() {
                        if (!$.trim(this.newTask.name)) {
                            this.newTask = {}
                            return
                        }

             // передаём новую задачу роуту /tasks с помощью $http клиента
                        this.$http.put(&#39;/tasks&#39;, this.newTask).success(function(response) {
                            this.newTask.id = response.created
                            this.tasks.push(this.newTask)
                            console.log(&#34;Task created!&#34;)
                            console.log(this.newTask)
                            this.newTask = {}
                        }).error(function(error) {
                            console.log(error)
                        });
                    },

                    deleteTask: function(index) {
             // используем $http клиента для удаления задачи по её id
                        this.$http.delete(&#39;/tasks/&#39; + this.tasks[index].id).success(function(response) {
                            this.tasks.splice(index, 1)
                            console.log(&#34;Task deleted!&#34;)
                        }).error(function(error) {
                            console.log(error)
                        })
                    }
                }
            })
        &lt;/script&gt;</pre></div>
<h5 id="за-пуск">За­пуск</h5>

<p>У нас всё го­то­во, пе­ре­со­бе­рём при­ло­же­ние и за­пу­стим его!</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">$ go build todo.go
$ ./todo</pre></div>
<p>От­кро­ем в бра­у­зе­ре <a href="http://localhost:8000">localhost:8000</a></p>

<p><img src="img/x586cd60931.png.pagespeed.ic.0VSAkXQG_W.png" alt="Разработка: Создание одностраничного веб-приложения на Go, Echo и Vue" /></p>

<p>Мы рас­смот­ре­ли неслож­ную за­да­чу по со­зда­нию бэ­кен­да на Go с по­мо­щью фрейм­вор­ка Echo и фрон­тен­да на VueJS. На­де­ем­ся, она спо­двиг­нет вас на со­зда­ние по-на­сто­я­ще­му хо­ро­ших и слож­ных веб-при­ло­же­ний!</p>

<p><a href="https://github.com/scotch-io/go-echo-vue-single-page-app">Ис­ход­ный код при­ме­ра.</a></p>

<p><strong>UPD:</strong> в но­вой вер­сии Echo бы­ла по­ло­ма­на об­рат­ная сов­ме­сти­мость и этот при­мер уже не ра­бо­та­ет. Уста­нав­ли­вай­те преды­ду­щую вер­сию:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">go get gopkg.in/labstack/echo.v2</pre></div>
<p>Если у вас ошибки, необходимо убрать из todo.go:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&#34;github.com/labstack/echo/engine/standard&#34;</pre></div>
<p>а вместо:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">e.Run(standard.New(&#34;:8000&#34;))</pre></div>
<p>запускаем сервер так:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">e.Logger.Fatal(e.Start(&#34;:8000&#34;))</pre></div> ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Todolist - быстрый консольный менеджер задач в концепции GTD на Golang</turbo:topic>
      <link>https://fokusov.com/posts/todolist-bystryj-konsolnyj-menedzher-zadach-v-koncepcii-gtd-na-golang/</link>
      <pubDate>Mon, 13 Feb 2017 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ 

<p><img src="img/xd2ec57.png.pagespeed.ic.0Gfjjdc5f8.png" alt="Софт: Todolist - быстрый консольный менеджер задач в концепции GTD на Golang" /><br />
Todolist помогает работать с вашими задачами в терминале. Todolist основан на методе <a href="https://ru.wikipedia.org/wiki/Getting_Things_Done">Getting Things Done</a> и умеет работать с проектами, контекстами и сроками задач.</p>

<p>Списки задач зависят от директории, в которой вы работаете с ними &mdash; просто держите разные списки дел в разных папках.</p>

<p><a href="https://asciinema.org/a/80747"><img src="https://asciinema.org/a/80747.png" alt="Софт: Todolist - быстрый консольный менеджер задач в концепции GTD на Golang" /></a></p>

<h5 id="установка">Установка</h5>

<p>Выберите любой удобный способ:</p>

<ul>
<li><strong>brew install todolist</strong> &mdash; если у вас есть OSX с установленным homebrew.</li>
<li><a href="https://github.com/gammons/todolist/releases">Скачайте последний релиз</a> для вашей платформы и скопируйте исполняемый файл <strong>todolist</strong> в любое место в $PATH.</li>
<li>Если у вас установлен Golang, запустите команду <strong>go get github.com/gammons/todolist</strong>.</li>
</ul>

<h5 id="быстрый-старт">Быстрый старт</h5>

<p><strong>1: Создадим репозиторий todos</strong><br />
Запустите <strong>todolist init</strong> для создания списка задач в файле <strong>.todos.json</strong> в текущей директории.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">~ todolist init
Todo repo initialized.</pre></div>
<p><strong>2: Добавим несколько задач</strong><br />
Добавить задачу можно командой <strong>add</strong> или <strong>a</strong>:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">~ todolist add Chat with @bob about +currentProject due tom
Todo added.
~ todolist a +devops update my master password due fri
Todo added.</pre></div>
<p><strong>3: Список задач</strong><br />
Это сердце всей системы. Вы можете фильтровать и группировать ваши задачи. А если встроенная фильтрация не отвечает вашим нуждам, вы даже можете передать вывод в <strong>grep</strong>!</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">~ todolist list
all
1   [ ] tomorrow    Talk with @bob about the +bigProject
2   [ ] Fri May 13  +devops update my master password</pre></div>
<p><strong>todolist list</strong> принимает разные аргументы. Можно отобрать задачи по срокам:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">~ todolist list due tom
all
1   [ ] tomorrow    Talk with @bob about the +bigProject</pre></div>
<p>Можно сгруппировать по проекту или контексту.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">~ todolist list by project

bigProject
1   [ ] tomorrow    Talk with @bob about the +bigProject

devops
2   [ ] Fri May 13  +devops update my master password</pre></div>
<p><strong>4: Завершить задачу</strong><br />
Пометить задачу как выполненную можно командой <strong>todolist complete</strong> или <strong>todolist c</strong>.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">~ todolist complete 1
Todo completed.
~ todolist c 2
Todo completed.</pre></div>
<p>Теперь при выводе списка задач, вы увидите, что все они выполнены:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">~ todolist list
all
1   [x] tomorrow    Talk with @bob about the +bigProject
2   [x] Fri May 13  +devops update my master password</pre></div>
<p><strong>5: Архивировать выполненные задачи</strong><br />
После выполнения задач, вы можете заархивировать их, чтобы они не отображались при выводе списка.</p>

<p>Вы можете заархивировать каждую задачу индивидуально командой <strong>todolist ar [id]</strong>, но так как у нас сегодня много выполненных задач, мы можем запустить <strong>todolist ac</strong>, которая отправить в архив все выполненные задачи.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">~ todolist ac
All completed todos archived.</pre></div>
<p>Вот и всё! Теперь вы знаете 90% функционала Todolist.</p>

<h5 id="рабочий-процесс">Рабочий процесс</h5>

<p>Задачи могут принимать 3 состояния:</p>

<ul>
<li>Incomplete &mdash; Незавершённые задачи</li>
<li>Complete &mdash; Завершённые задачи</li>
<li>Archived &mdash; Архивированные задачи, они не выводятся в списке задач и увидеть их можно командой <strong>todolist list archived</strong>.<br />
Обычно мы создаём задачу, завершаем её, затем архивируем в конце дня.</li>
</ul>

<h5 id="добавление-задач">Добавление задач</h5>

<p>Задачи добавляются командой <strong>todolist add</strong> или <strong>todolist a</strong>, затем можно заполнить детали задачи.</p>

<ul>
<li><strong>+проекты</strong> и <strong>@контексты</strong> можно вставлять в текст задачи.</li>

<li><p>Нужно обязательно указать срок в конце задачи (due date).<br />
<strong>Формат Due date</strong></p></li>

<li><p>Для сегодняшних или завтрашних задач вы можете указывать <strong>due today</strong> и <strong>due tomorrow</strong>. Или сокращённые команды <strong>due tod</strong> или <strong>due tom</strong>.</p></li>

<li><p>Для задач со сроком в течение текущей недели можно писать первые 3 буквы дня (на англ.яз.). Например, <strong>due mon</strong> или <strong>due thu</strong>. Todolist всегда ищет дни в будущем, поэтому если сегодня Среда, а вы задали <strong>due mon</strong>, то срок задачи будет в следующий Понедельник.</p></li>

<li><p>Для указания определённой даты можно указать <strong>due may 2</strong> или <strong>due 2 may</strong>. Месяц должен быть написан в нижнем регистре тремя буквами.<br />
Примеры:</p></li>
</ul>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">~ todolist a update the staging db with @frank due tom
Todo added.
~ todolist a @pomodoro I need to think about our job tier structure due wed
Todo added.
~ todolist a meet with @jake and @adrian about the +importImprovement project due jun 23
Todo added.
~ todolist l

1   [ ] tomorrow    update the staging db with @frank
2   [ ] Wed Jun 22  @pomodoro I need to think about our job tier structure
3   [ ] Thu Jun 23  meet with @jake and @adrian about the +importImprovement project</pre></div>
<h5 id="завершение-задач-и-возврат-к-невыполненным">Завершение задач и возврат к невыполненным</h5>

<p><strong>todolist complete [id]</strong> или <strong>todolist c [id]</strong> &mdash; завершает задачу с указанным номером.</p>

<p><strong>todolist uncomplete [id]</strong> или <strong>todolist uc [id]</strong> &mdash; помечает задачу как невыполненную.</p>

<h5 id="архивация-и-возврат-из-архива">Архивация и возврат из архива</h5>

<p><strong>todolist archive [id]</strong> или <strong>todolist ar [id]</strong> &mdash; помещает задачу в архив.</p>

<p><strong>todolist unarchive [id]</strong> &mdash; возвращает задачу из архива.</p>

<h5 id="вывод-списка-фильтрация-и-группировка-задач">Вывод списка, фильтрация и группировка задач</h5>

<p><strong>todolist list</strong> или <strong>todolist l</strong> &mdash; список всех незаархивированных задач</p>

<p><strong>todolist l archived</strong> &mdash; список задач в архиве</p>

<p><strong>Внимание:</strong> по-умолчанию, Todolist всегда скрывает архивированные задачи. Увидеть их вы можете только командой <strong>todo list archived</strong>.</p>

<p><strong>Отбор по сроку</strong><br />
<strong>todolist l agenda</strong> &mdash; Список задач на сегодня + просроченные</p>

<p><strong>todolist l overdue</strong> &mdash; Список просроченных задач</p>

<p><strong>todolist l due today</strong> или <strong>todo l due tod</strong> &mdash; Список задач на сегодня</p>

<p><strong>todolist l due tomorrow</strong> или <strong>todo l due tom</strong> &mdash; Список задач на завтра</p>

<p><strong>Отбор по дню недели</strong><br />
<strong>todolist l due mon</strong> &mdash; Список задач на Понедельник</p>

<p><strong>todolist l due this week</strong> &mdash; Список задач на всю неделю</p>

<p><strong>Группировка</strong><br />
Задачи можно сгруппировать по проекту или контексту.</p>

<p><strong>todolist l by p</strong> &mdash; Список задач, сгруппированных по проекту</p>

<p><strong>todolist l by c</strong> &mdash; Список задач, сгруппированных по контексту</p>

<h5 id="редактирование-задач">Редактирование задач</h5>

<p>Пока Todolist позволяет редактировать только срок задачи. Для полного редактирования задачи лучше удалить её и создать заново.</p>

<p><strong>todolist e [id] due [due]</strong> &mdash; редактирует срок задачи.</p>

<p>Примеры:</p>

<ul>
<li><strong>todolist e 133 due tod</strong> &mdash; редактируем задачу с номером 133 и задаём срок на сегодня.</li>
<li><strong>todolist e 56 due jun 20</strong> &mdash; редактируем задачу с номером 56 и задаём срок на 20 июня.</li>
</ul>

<h5 id="expanding-existing-todos">Expanding existing todos</h5>

<p>Todolist поддерживает расширение существующих списков задач с добавлением недостающих деталей. Синтаксис такой:</p>

<p><strong>todolist ex [id] +[project]: todo1[,todo2&hellip;]</strong></p>

<p>Если в списке есть такая задача:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">13  [ ] Sat Jan 28  Write the thesis</pre></div>
<p>Попробуем расширить её, добавив деталей:</p>

<ul>
<li>todolist ex 13 +thesis: get latex template due Jan 22, meet prof. due Jan 23, organize data due Jan 24, Introduction and Abstract due Jan 27</li>
</ul>

<p>Список станет таким:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">14  [ ] Sun Jan 22  get latex template
15  [ ] Mon Jan 23  meet prof.
16  [ ] Tue Jan 24  organize data
17  [ ] Wed Jan 25  Introduction and Abstract</pre></div>
<h5 id="удаление-задач">Удаление задач</h5>

<p><strong>todolist delete [id]</strong> или <strong>todolist d [id]</strong>.</p>

<h5 id="web-представление">Web-представление</h5>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">todolist web</pre></div>
<p><img src="img/x5e6f6e.png.pagespeed.ic.yC_2KnK4rw.png" alt="Софт: Todolist - быстрый консольный менеджер задач в концепции GTD на Golang" /></p>

<p>Эта команда запустит лёгкий веб-сервер по адресу <a href="http://localhost:7890">http://localhost:7890</a>, где вы можете управлять своими задачами в красивом представлении.</p>

<p>Демо-версию можно посмотреть <a href="http://demo.todolist.site/">здесь</a>.</p>

<h5 id="формат-файла-todos-json">Формат файла .todos.json</h5>

<p>В .todos.json в очень простом формате хранятся все задачи из текущей директории. Пример файла .todos.json:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[{
    &#34;id&#34;: 110,
    &#34;subject&#34;: &#34;+toVerify did @scott put zuora alerting in place?&#34;,
    &#34;projects&#34;: [
      &#34;toVerify&#34;
    ],
    &#34;contexts&#34;: [
      &#34;scott&#34;
    ],
    &#34;due&#34;: &#34;2016-05-23&#34;,
    &#34;completed&#34;: false,
    &#34;archived&#34;: false
  }]</pre></div>
<h5 id="заключение">Заключение</h5>

<p>Я обожаю утилиты, соответствующие <a href="https://ru.wikipedia.org/wiki/Философия_UNIX">философии Unix</a>. Будучи уверенным пользователем <a href="https://www.wunderlist.com/">Wunderlist</a>, я планировал переписать 30% возможностей Wunderlist, оставив только те, которые я использовал, в простой консольной утилите.</p>

<p><strong>Чем это отличается от todo.txt?</strong><br />
todo.txt это превосходный инструмент с великолепной экосистемой, но он мне не подошёл. Мне нужны были даты в задачах и некоторые другие параметры, а по-умолчанию в todo.txt не было такого функционала. Я верю в то, что Todolist концептуально ближе к тому, как «крупные» todo-компании делают это, например, Wunderlist, Todoist и т.д.</p>

<p><a href="http://todolist.site">Источник</a></p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Разработка Web-приложений и микросервисов на Go с Gin</turbo:topic>
      <link>https://fokusov.com/posts/razrabotka-web-prilozhenij-i-mikroservisov-na-golang-s-gin/</link>
      <pubDate>Fri, 10 Feb 2017 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ 

<p><img src="img/x54652315c7.png.pagespeed.ic.UObs55EKAq.png" alt="Разработка: Разработка Web-приложений и микросервисов на Golang с Gin" /></p>

<h5 id="вве-де-ние">Вве­де­ние</h5>

<p>Се­год­ня мы по­ка­жем, как со­зда­вать веб-при­ло­же­ния и мик­ро­сер­ви­сы в Go с по­мо­щью фрейм­вор­ка <a href="https://github.com/gin-gonic/gin">Gin</a>. Gin это фрейм­ворк, поз­во­ля­ю­щий умень­шить объ­ём ко­да, необ­хо­ди­мо­го для по­стро­е­ния та­ких при­ло­же­ний. Он по­ощ­ря­ет со­зда­ние мно­го­крат­но-ис­поль­зу­е­мо­го и рас­ши­ря­е­мо­го ко­да.</p>

<p>Мы рас­смот­рим со­зда­ние про­ек­та и сбор­ку неслож­но­го при­ло­же­ния с Gin, ко­то­рое бу­дет вы­во­дить спи­сок то­пи­ков и от­дель­ный то­пик.</p>

<h5 id="под-го-тов-ка">Под­го­тов­ка</h5>

<p>Пе­ред на­ча­лом ра­бо­ты убе­ди­тесь, что у вас уста­нов­ле­ны Go и ути­ли­та curl. Ес­ли curl не уста­нов­ле­на и вы не хо­ти­те ра­бо­тать с ней, ис­поль­зуй­те лю­бую дру­гую ути­ли­ту те­сти­ро­ва­ния API.</p>

<h5 id="что-та-кое-gin">Что та­кое Gin?</h5>

<p>Gin это вы­со­ко­про­из­во­ди­тель­ный мик­рофрейм­ворк, ко­то­рый ис­поль­зу­ет­ся для со­зда­ния веб-при­ло­же­ний и мик­ро­сер­ви­сов. С ним очень удоб­но де­лать ком­плекс­ную кон­вей­ер­ную об­ра­бот­ку за­про­сов из мо­ду­лей &mdash; мно­го­крат­но ис­поль­зу­е­мых ку­соч­ков ко­да. Вы пи­ше­те про­ме­жу­точ­ный слой при­ло­же­ния, ко­то­рый за­тем под­клю­ча­ет­ся в один или бо­лее об­ра­бот­чик за­про­сов или в груп­пу об­ра­бот­чи­ков.</p>

<h5 id="по-че-му-имен-но-gin">По­че­му имен­но Gin?</h5>

<p>Од­но из луч­ших ка­честв Go &mdash; его встро­ен­ная биб­лио­те­ка <strong>net/http</strong>, поз­во­ля­ю­щая с лёг­ко­стью со­зда­вать HTTP сер­вер. Од­на­ко, она не на­столь­ко гиб­кая, как бы хо­те­лось, и ко­ли­че­ство ко­да, тре­бу­е­мое при ра­бо­те с ней, до­воль­но боль­шое.</p>

<p>В Go нет встро­ен­ной под­держ­ки об­ра­бот­чи­ка ро­у­тов на ба­зе ре­гу­ляр­ных вы­ра­же­ний. Вам нуж­но пи­сать код для по­лу­че­ния это­го функ­ци­о­на­ла. Од­на­ко, с ро­стом ко­ли­че­ства ва­ших при­ло­же­ний, вы бу­де­те вы­нуж­де­ны ко­пи­ро­вать один и тот же код вез­де или всё-та­ки со­зда­ди­те биб­лио­те­ку.</p>

<p>В этом и есть за­да­ча Gin. Он со­дер­жит на­бор ча­сто упо­треб­ля­е­мых функ­ций, та­ких как ро­утинг, под­держ­ка middleware, об­ра­бот­ка шаб­ло­нов. Вдо­ба­вок к это­му, он поз­во­ля­ет умень­шить ко­ли­че­ство ко­да в при­ло­же­ни­ях и со­зда­ние веб-при­ло­же­ний с ним на­мно­го про­ще.</p>

<h5 id="про-ек-ти-ро-ва-ние-при-ло-же-ния">Про­ек­ти­ро­ва­ние при­ло­же­ния</h5>

<p>По­смот­рим, как Gin об­ра­ба­ты­ва­ет за­про­сы:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">Request -&gt; Route Parser -&gt; [Optional Middleware] -&gt; Route Handler -&gt; [Optional Middleware] -&gt; Response</pre></div>
<p>Ко­гда при­хо­дит за­прос, Gin сна­ча­ла про­ве­ря­ет, есть ли под­хо­дя­щий ро­ут (марш­рут). Ес­ли со­от­вет­ству­ю­щий ро­ут най­ден, Gin за­пус­ка­ет об­ра­бот­чик это­го ро­у­та и про­ме­жу­точ­ные зве­нья в за­дан­ном по­ряд­ке. Мы уви­дим как это про­ис­хо­дит, ко­гда пе­рей­дём к ко­ду в сле­ду­ю­щем раз­де­ле.</p>

<h5 id="функ-ци-о-нал-при-ло-же-ния">Функ­ци­о­нал при­ло­же­ния</h5>

<p>На­ше при­ло­же­ние &mdash; это про­стой ме­не­джер то­пи­ков. Оно долж­но:</p>

<ul>
<li>поз­во­лять поль­зо­ва­те­лям ре­ги­стри­ро­вать­ся с ло­ги­ном и па­ро­лем (для неав­то­ри­зо­ван­ных поль­зо­ва­те­лей),</li>
<li>поз­во­лять поль­зо­ва­те­лям ав­то­ри­зо­вать­ся (для неав­то­ри­зо­ван­ных поль­зо­ва­те­лей),</li>
<li>поз­во­лять поль­зо­ва­те­лям за­вер­шать се­анс (для ав­то­ри­зо­ван­ных поль­зо­ва­те­лей),</li>
<li>поз­во­лять поль­зо­ва­те­лям со­зда­вать то­пи­ки (для ав­то­ри­зо­ван­ных поль­зо­ва­те­лей),</li>
<li>Вы­во­дить спи­сок всех то­пи­ков на глав­ной стра­ни­це (для всех поль­зо­ва­те­лей), и</li>
<li>Вы­во­дить то­пик на его соб­ствен­ной стра­ни­це (для всех поль­зо­ва­те­лей).<br />
Вдо­ба­вок к это­му мы сде­ла­ем, что­бы спи­сок то­пи­ков и от­дель­ные то­пи­ки бы­ли до­ступ­ны в фор­ма­тах HTML, JSON и XML.</li>
</ul>

<p>Это поз­во­лит нам про­ил­лю­стри­ро­вать, как мож­но ис­поль­зо­вать Gin для про­ек­ти­ро­ва­ния веб-при­ло­же­ний, API сер­ве­ров и мик­ро­сер­ви­сов.</p>

<p>Для это­го мы ис­поль­зу­ем сле­ду­ю­щий функ­ци­о­нал Gin:</p>

<ul>
<li>Routing &mdash; для об­ра­бот­ки раз­лич­ных URL ад­ре­сов,</li>
<li>Custom rendering &mdash; для об­ра­бот­ки фор­ма­та от­ве­та, и</li>
<li>Middleware &mdash; для ре­а­ли­за­ции ав­то­ри­за­ции.<br />
Та­к­же мы на­пи­шем те­сты для про­вер­ки ра­бо­то­спо­соб­но­сти на­ше­го функ­ци­о­на­ла.</li>
</ul>

<h5 id="routing">Routing</h5>

<p>Ро­утинг (марш­ру­ти­за­ция) это од­на из важ­ней­ших функ­ций, име­ю­щих­ся во всех со­вре­мен­ных веб-фрейм­вор­ках. Лю­бая веб-стра­ни­ца или вы­зов API до­сту­пен по URL. Фрейм­вор­ки ис­поль­зу­ют ро­уты для об­ра­бот­ки за­про­сов к этим URL-ад­ре­сам. Ес­ли URL та­кой: <strong>httр://​www.​example.​com/​some/​random/​route</strong>, то ро­ут бу­дет: <strong>/some/random/route</strong>.</p>

<p>У Gin очень быст­рый ро­у­тер, удоб­ный в кон­фи­гу­ри­ро­ва­нии и ра­бо­те. Вме­сте с об­ра­бот­кой опре­де­лен­ных URL-ад­ре­сов, ро­у­тер в Gin мо­жет об­ра­ба­ты­вать шаб­ло­ны ад­ре­сов и груп­пы URL.</p>

<p>В на­шем при­ло­же­нии мы бу­дем:</p>

<ul>
<li>Хра­нить глав­ную стра­ни­цу в ро­уте <strong>/</strong> (за­прос HTTP GET),</li>

<li><p>Груп­пи­ро­вать ро­уты, от­но­ся­щи­е­ся к поль­зо­ва­те­лям, в ро­уте <strong>/u</strong> ,</p></li>

<li><p>Хра­нить стра­ни­цу ав­то­ри­за­ции в <strong>/u/login</strong> (за­прос HTTP GET),</p></li>

<li><p>Пе­ре­да­вать дан­ные ав­то­ри­за­ции в <strong>/u/login</strong> (за­прос HTTP POST),</p></li>

<li><p>За­вер­ше­ние се­ан­са в <strong>/u/logout</strong> (за­прос HTTP GET),</p></li>

<li><p>Хра­нить стра­ни­цу ре­ги­стра­ции в <strong>/u/register</strong> (за­прос HTTP GET),</p></li>

<li><p>Пе­ре­да­вать ре­ги­стра­ци­он­ную ин­фор­ма­цию в <strong>/u/register</strong> (за­прос HTTP POST) ,</p></li>

<li><p>Груп­пи­ро­вать ро­уты, от­но­ся­щи­е­ся к то­пи­кам, в ро­уте <strong>/article</strong>,</p></li>

<li><p>Хра­нить стра­ни­цу со­зда­ния то­пи­ка в <strong>/article/create</strong> (за­прос HTTP GET),</p></li>

<li><p>Пе­ре­да­вать утвер­ждён­ный то­пик в <strong>/article/create</strong> (за­прос HTTP POST), и</p></li>

<li><p>Хра­нить стра­ни­цу то­пи­ка в <strong>/article/view/:article_id</strong> (за­прос HTTP GET). Об­ра­ти­те вни­ма­ние на часть <strong>:article_id</strong> в этом ро­уте. Двое­то­чие <strong>:</strong> в на­ча­ле ука­зы­ва­ет на то, что это ди­на­ми­че­ский ро­ут. Это зна­чит, что <strong>:article_id</strong> мо­жет со­дер­жать лю­бое зна­че­ние и Gin сде­ла­ет это зна­че­ние до­ступ­ным в об­ра­бот­чи­ке за­про­са.</p></li>
</ul>

<h5 id="rendering">Rendering</h5>

<p>Веб-при­ло­же­ние мо­жет вы­ве­сти от­вет в раз­лич­ных фор­ма­тах, та­ких как HTML, текст, JSON, XML или дру­гие фор­ма­ты. API и мик­ро­сер­ви­сы обыч­но от­да­ют дан­ные в фор­ма­те JSON, но здесь та­к­же нет огра­ни­че­ний.</p>

<p>В сле­ду­ю­щем раз­де­ле мы уви­дим, как мож­но об­ра­бо­тать раз­ные ти­пы от­ве­тов без дуб­ли­ро­ва­ния функ­ци­о­на­ла. По-умол­ча­нию мы бу­дем от­ве­чать на за­прос шаб­ло­ном HTML. Од­на­ко, мы со­зда­дим ещё два ви­да за­про­са, ко­то­рые бу­дут от­ве­чать в фор­ма­те JSON или XML.</p>

<h5 id="middleware">Middleware</h5>

<p>В кон­тек­сте веб-при­ло­же­ний на Go, middleware это часть ко­да, ко­то­рую мож­но вы­пол­нить на лю­бом эта­пе об­ра­бот­ки HTTP-за­про­са. Обыч­но их ис­поль­зу­ют для ин­кап­су­ля­ции ти­по­во­го функ­ци­о­на­ла, ко­то­рый вам нуж­но вы­зы­вать из раз­лич­ных ро­у­тов. Мы мо­жем ис­поль­зо­вать middleware пе­ред и/или по­сле об­ра­бо­тан­но­го HTTP-за­про­са. К ти­по­вым при­ме­рам при­ме­не­ния middleware от­но­сят­ся ав­то­ри­за­ция, ва­ли­да­ция и т.п.</p>

<p>Ес­ли middleware ис­поль­зу­ет­ся пе­ред об­ра­бот­кой ро­у­та, лю­бые из­ме­не­ния, сде­лан­ные им, бу­дут до­ступ­ны в глав­ном об­ра­бот­чи­ке за­про­сов. Это удоб­но, ес­ли мы хо­тим ре­а­ли­зо­вать про­вер­ку опре­де­лён­ных за­про­сов. С дру­гой сто­ро­ны, ес­ли middleware ис­поль­зу­ет­ся по­сле об­ра­бот­чи­ка, он по­лу­чит от­вет из об­ра­бот­чи­ка ро­у­тов. Это мож­но ис­поль­зо­вать для мо­ди­фи­ка­ции от­ве­та из об­ра­бот­чи­ка ро­у­та.</p>

<p>Мы долж­ны быть уве­ре­ны, что неко­то­рые стра­ни­цы и дей­ствия, к при­ме­ру, со­зда­ние то­пи­ка, за­вер­ше­ние се­ан­са, до­ступ­ны толь­ко ав­то­ри­зо­ван­ным поль­зо­ва­те­лям. И та­к­же необ­хо­ди­мо, что­бы неко­то­рые стра­ни­цы и дей­ствия, к при­ме­ру, ре­ги­стра­ция, ав­то­ри­за­ция, бы­ли до­ступ­ны толь­ко неав­то­ри­зо­ван­ным поль­зо­ва­те­лям.</p>

<p>Ес­ли мы вклю­чим со­от­вет­ству­ю­щую ло­ги­ку в каж­дый ро­ут, это бу­дет слож­но, из­лишне по­вто­ря­е­мо и склон­но к ошиб­кам. К сча­стью, мы мо­жем со­здать middleware для каж­дой из этих за­дач и мно­го­крат­но ис­поль­зо­вать их в со­от­вет­ству­ю­щих ро­у­тах.</p>

<p>Мы со­зда­дим middleware, ко­то­рое бу­дет при­ме­ни­мо ко всем ро­у­там. На­ше middleware (<strong>setUserStatus</strong>) бу­дет про­ве­рять &mdash; от ав­то­ри­зо­ван­но­го поль­зо­ва­те­ля при­шёл за­прос или от неав­то­ри­зо­ван­но­го. За­тем оно уста­но­вит флаг, ко­то­рый мож­но бу­дет ис­поль­зо­вать в шаб­ло­нах для на­строй­ки ви­ди­мо­сти опре­де­лён­ных ссы­лок в ме­ню при­ло­же­ния.</p>

<h5 id="уста-нов-ка-за-ви-си-мо-стей">Уста­нов­ка за­ви­си­мо­стей</h5>

<p>На­ше при­ло­же­ние бу­дет ис­поль­зо­вать толь­ко од­ну внеш­нюю за­ви­си­мость &mdash; сам фрейм­ворк Gin. Уста­но­вим ак­ту­аль­ную вер­сию та­кой ко­ман­дой:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">go get -u github.com/gin-gonic/gin</pre></div>
<h5 id="со-зда-ние-мно-го-крат-но-ис-поль-зу-е-мых-шаб-ло-нов">Со­зда­ние мно­го­крат­но-ис­поль­зу­е­мых шаб­ло­нов</h5>

<p>На­ше при­ло­же­ние бу­дет отоб­ра­жать веб-стра­ни­цу, ис­поль­зуя её шаб­лон. Од­на­ко, в ней бу­дет несколь­ко ча­стей, та­ких как шап­ка (header), ме­ню, бо­ко­вая па­нель и под­вал (footer), ко­то­рые бу­дут пред­став­ле­ны на всех стра­ни­цах. В Go мож­но со­зда­вать шаб­лон­ные сни­пе­ты, ко­то­рые мож­но бу­дет за­гру­жать в лю­бые шаб­ло­ны.</p>

<p>Мы со­зда­дим сни­пе­ты для шап­ки и под­ва­ла, та­к­же со­зда­дим ме­ню в со­от­вет­ству­ю­щем фай­ле-шаб­лоне, ко­то­рое за­тем вы­зо­вем из шап­ки. Ну и на­ко­нец, мы со­зда­дим шаб­лон глав­ной стра­ни­цы, с ко­то­рой вы­зо­вем шап­ку и под­вал. Все фай­лы шаб­ло­нов бу­дут раз­ме­щать­ся в пап­ке <strong>templates</strong> на­ше­го про­ек­та.</p>

<p>Сна­ча­ла со­здай­те шаб­лон ме­ню в фай­ле <strong>templates/menu.html</strong> как опи­са­но ни­же:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!--menu.html--&gt;

&lt;nav class=&#34;navbar navbar-default&#34;&gt;
  &lt;div class=&#34;container&#34;&gt;
    &lt;div class=&#34;navbar-header&#34;&gt;
      &lt;a class=&#34;navbar-brand&#34; href=&#34;https://fokusov.com/&#34;&gt;
        Home
      &lt;/a&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/nav&gt;</pre></div>
<p>По­ка в на­шем ме­ню есть толь­ко од­на ссыл­ка на глав­ную стра­ни­цу. Поз­же мы до­ба­вим осталь­ные ссыл­ки по ме­ре ро­ста функ­ци­о­на­ла при­ло­же­ния. Шаб­лон шап­ки бу­дет в фай­ле <strong>templates/header.html</strong>:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!--header.html--&gt;

&lt;!doctype html&gt;
&lt;html&gt;

  &lt;head&gt;
    &lt;!--Use the `title` variable to set the title of the page--&gt;
    &lt;title&gt;{{ .title }}&lt;/title&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1&#34;&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;

    &lt;!--Use bootstrap to make the application look nice--&gt;
    &lt;link rel=&#34;stylesheet&#34; href=&#34;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&#34; integrity=&#34;sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7&#34; crossorigin=&#34;anonymous&#34;&gt;
    &lt;script async src=&#34;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js&#34; integrity=&#34;sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS&#34; crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;
  &lt;/head&gt;

  &lt;body class=&#34;container&#34;&gt;
    &lt;!--Embed the menu.html template at this location--&gt;
    {{ template &#34;menu.html&#34; . }}</pre></div>
<p>Как вы ви­ди­те, мы ис­поль­зу­ем здесь фрейм­ворк с от­кры­тым ис­ход­ным ко­дом Bootstrap. Боль­шая часть фай­ла это стан­дарт­ный HTML. Од­на­ко, по­смот­рим вни­ма­тель­но на па­ру строк. В стро­ке с {{ .title }} ди­на­ми­че­ски за­да­ёт­ся за­го­ло­вок стра­ни­цы с по­мо­щью пе­ре­мен­ной <strong>.title</strong>, ко­то­рая долж­на быть опре­де­ле­на в при­ло­же­нии. А в стро­ке {{ template «menu.html». }} мы за­гру­жа­ем шаб­лон ме­ню из фай­ла <strong>menu.html</strong>. Вот так в Go мож­но вы­зы­вать один шаб­лон из дру­го­го.</p>

<p>Шаб­лон под­ва­ла со­дер­жит толь­ко ста­ти­че­ский HTML. Шаб­лон глав­ной стра­ни­цы вы­зы­ва­ет шап­ку и под­вал и вы­во­дит со­об­ще­ние <em>Hello Gin</em>:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!--index.html--&gt;

&lt;!--Embed the header.html template at this location--&gt;
{{ template &#34;header.html&#34; .}}

  &lt;h1&gt;Hello Gin!&lt;/h1&gt;

&lt;!--Embed the footer.html template at this location--&gt;
{{ template &#34;footer.html&#34; .}}</pre></div>
<p>По ана­ло­гии с шаб­ло­ном глав­ной, в шаб­ло­нах дру­гих стра­ниц мы та­к­же ис­поль­зу­ем эти шап­ку и под­вал.</p>

<h5 id="за-вер-ше-ние-и-про-вер-ка-уста-нов-ки">За­вер­ше­ние и про­вер­ка уста­нов­ки</h5>

<p>Со­здав шаб­ло­ны, те­перь са­мое вре­мя со­здать глав­ный файл при­ло­же­ния. Мы со­зда­дим файл <strong>main.go</strong>, в нём бу­дет про­стое веб-при­ло­же­ние, за­гру­жа­ю­щее глав­ную стра­ни­цу. С Gin это де­ла­ет­ся в че­ты­ре ша­га:</p>

<p><strong>1. Со­зда­ём ро­у­тер</strong></p>

<p>Ро­у­тер в Gin со­зда­ёт­ся так:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">router := gin.Default()</pre></div>
<p><strong>2. За­гру­жа­ем шаб­ло­ны</strong></p>

<p>По­сле со­зда­ния ро­у­те­ра, за­гру­зим все шаб­ло­ны:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">router.LoadHTMLGlob(&#34;templates/*&#34;)</pre></div>
<p>Это за­гру­зит все шаб­ло­ны из пап­ки <strong>templates</strong>. За­гру­зив один раз шаб­ло­ны, боль­ше не бу­дет необ­хо­ди­мо­сти пе­ре­чи­ты­вать их, что де­ла­ет веб-при­ло­же­ния с Gin очень быст­ры­ми.</p>

<p><strong>3. За­да­ём об­ра­бот­чик ро­у­тов</strong></p>

<p>Очень важ­но пра­виль­но спро­ек­ти­ро­вать при­ло­же­ние, раз­де­лив на со­от­вет­ству­ю­щие ро­уты и за­дав об­ра­бот­чи­ки для каж­до­го из них. Мы со­зда­дим ро­ут для глав­ной стра­ни­цы и его об­ра­бот­чик.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">router.GET(&#34;/&#34;, func(c *gin.Context) {

  // Call the HTML method of the Context to render a template
  c.HTML(
      // Set the HTTP status to 200 (OK)
      http.StatusOK,
      // Use the index.html template
      &#34;index.html&#34;,
      // Pass the data that the page uses (in this case, &#39;title&#39;)
      gin.H{
          &#34;title&#34;: &#34;Home Page&#34;,
      },
  )

})</pre></div>
<p>С по­мо­щью ме­то­да <strong>router.GET</strong> мы за­да­ём об­ра­бот­чик ро­у­та для GET-за­про­сов. Он при­ни­ма­ет в ка­че­стве па­ра­мет­ров сам ро­ут (<strong>/</strong>) и один или несколь­ко об­ра­бот­чи­ков, ко­то­рые все­го лишь функ­ции.</p>

<p>Об­ра­бот­чик ро­у­та име­ет ука­за­тель на Кон­текст (gin.​Context) в па­ра­мет­рах. В этом кон­тек­сте со­дер­жит­ся вся ин­фор­ма­ция о за­про­се, ко­то­рая мо­жет по­на­до­бит­ся об­ра­бот­чи­ку в даль­ней­шем. К при­ме­ру, в нём есть ин­фор­ма­ция о за­го­лов­ках, cookies и т.д.</p>

<p>В Кон­тек­сте та­к­же есть ме­то­ды для вы­во­да от­ве­та в фор­ма­тах HTML, тек­сте, JSON и XML. В на­шем слу­чае мы взя­ли ме­тод <strong>context.HTML</strong> для об­ра­бот­ки HTML шаб­ло­на (index.html). Вы­зов это­го ме­то­да вклю­ча­ет до­пол­ни­тель­ные дан­ные, в ко­то­рых зна­че­ние <strong>title</strong> уста­нов­ле­но <strong>Home Page</strong>. Это зна­че­ние, ко­то­рое мо­жет быть об­ра­бо­та­но в HTML шаб­лоне. Мы ис­поль­зу­ем это зна­че­ние в те­ге в шаб­лоне шап­ки.</p>

<p><strong>4. За­пуск при­ло­же­ния</strong></p>

<p>Для за­пус­ка при­ло­же­ния вос­поль­зу­ем­ся ме­то­дом <strong>Run</strong> на­ше­го ро­у­те­ра:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">router.Run()</pre></div>
<p>При­ло­же­ние за­пу­стит­ся на <strong>localhost</strong> и <strong>8080</strong> пор­те, по-умол­ча­нию.</p>

<p>Фи­наль­ный файл <strong>main.go</strong> бу­дет та­ким:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#007f7f">// main.go
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">package</span> main

<span style="color:#fff;font-weight:bold">import</span> (
  <span style="color:#0ff;font-weight:bold">&#34;net/http&#34;</span>

  <span style="color:#0ff;font-weight:bold">&#34;github.com/gin-gonic/gin&#34;</span>
)

<span style="color:#fff;font-weight:bold">var</span> router *gin.Engine

<span style="color:#fff;font-weight:bold">func</span> main() {

  <span style="color:#007f7f">// Set the router as the default one provided by Gin
</span><span style="color:#007f7f"></span>  router = gin.Default()

  <span style="color:#007f7f">// Process the templates at the start so that they don&#39;t have to be loaded
</span><span style="color:#007f7f"></span>  <span style="color:#007f7f">// from the disk again. This makes serving HTML pages very fast.
</span><span style="color:#007f7f"></span>  router.LoadHTMLGlob(<span style="color:#0ff;font-weight:bold">&#34;templates/*&#34;</span>)

  <span style="color:#007f7f">// Define the route for the index page and display the index.html template
</span><span style="color:#007f7f"></span>  <span style="color:#007f7f">// To start with, we&#39;ll use an inline route handler. Later on, we&#39;ll create
</span><span style="color:#007f7f"></span>  <span style="color:#007f7f">// standalone functions that will be used as route handlers.
</span><span style="color:#007f7f"></span>  router.GET(<span style="color:#0ff;font-weight:bold">&#34;/&#34;</span>, <span style="color:#fff;font-weight:bold">func</span>(c *gin.Context) {

    <span style="color:#007f7f">// Call the HTML method of the Context to render a template
</span><span style="color:#007f7f"></span>    c.HTML(
      <span style="color:#007f7f">// Set the HTTP status to 200 (OK)
</span><span style="color:#007f7f"></span>      http.StatusOK,
      <span style="color:#007f7f">// Use the index.html template
</span><span style="color:#007f7f"></span>      <span style="color:#0ff;font-weight:bold">&#34;index.html&#34;</span>,
      <span style="color:#007f7f">// Pass the data that the page uses (in this case, &#39;title&#39;)
</span><span style="color:#007f7f"></span>      gin.H{
        <span style="color:#0ff;font-weight:bold">&#34;title&#34;</span>: <span style="color:#0ff;font-weight:bold">&#34;Home Page&#34;</span>,
      },
    )

  })

  <span style="color:#007f7f">// Start serving the application
</span><span style="color:#007f7f"></span>  router.Run()

}</pre></div>
<p>Для за­пус­ка при­ло­же­ния из ко­манд­ной стро­ки, пе­рей­ди­те в пап­ку при­ло­же­ния и вы­пол­ни­те ко­ман­ду:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">go build -o app</pre></div>
<p>Бу­дет со­бра­но при­ло­же­ние и со­здан ис­пол­ня­е­мый файл с име­нем <strong>app</strong>, ко­то­рый мож­но за­пу­стить так:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">./app</pre></div>
<p>Ес­ли всё про­шло успеш­но, вы долж­ны уви­деть при­ло­же­ние по ад­ре­су <a href="http://localhost:8080">http://localhost:8080</a> и оно бу­дет вы­гля­деть при­мер­но так:<br />
<img src="img/x748dbda990.png.pagespeed.ic.6oWeHvCrub.png" alt="Разработка: Разработка Web-приложений и микросервисов на Golang с Gin" /></p>

<p>На этом эта­пе иерар­хия па­пок при­ло­же­ния бу­дет та­кой:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">├── main.go
└── templates
    ├── footer.html
    ├── header.html
    ├── index.html
    └── menu.html</pre></div>
<h5 id="выводим-список-топиков">Выводим список топиков</h5>

<p>Сейчас мы добавим функционал для показа списка всех топиков на главной странице.</p>

<h5 id="настройка-роута">Настройка роута</h5>

<p>В предыдущем разделе мы создали роут и его описание в файле main.go. С ростом размера приложения будет лучше перенести описания роутов в отдельный файл. Мы создадим функцию initializeRoutes() в файле routes.go и будем вызывать её из функции main() для настройки всех роутов. Вместо создания линейного обработчика роутов, мы сделаем роуты отдельными функциями.</p>

<p>После всего этого файл routes.go будет таким:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#007f7f">// routes.go
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">package</span> main

<span style="color:#fff;font-weight:bold">func</span> initializeRoutes() {

  <span style="color:#007f7f">// определение роута главной страницы
</span><span style="color:#007f7f"></span>  router.GET(<span style="color:#0ff;font-weight:bold">&#34;/&#34;</span>, showIndexPage)
}</pre></div>
<p>Так как мы выводим список топиков на главной странице, нам не нужно будет создавать больше никаких других роутов.</p>

<p>Файл main.go должен быть сейчас таким:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#007f7f">// main.go
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">package</span> main

<span style="color:#fff;font-weight:bold">import</span> <span style="color:#0ff;font-weight:bold">&#34;github.com/gin-gonic/gin&#34;</span>

<span style="color:#fff;font-weight:bold">var</span> router *gin.Engine

<span style="color:#fff;font-weight:bold">func</span> main() {

  <span style="color:#007f7f">// роутер по-умолчанию в Gin
</span><span style="color:#007f7f"></span>  router = gin.Default()

  <span style="color:#007f7f">// Обработаем шаблоны вначале, так что их не нужно будет перечитывать
</span><span style="color:#007f7f"></span>  <span style="color:#007f7f">// ещё раз. Из-за этого вывод HTML-страниц такой быстрый.
</span><span style="color:#007f7f"></span>  router.LoadHTMLGlob(<span style="color:#0ff;font-weight:bold">&#34;templates/*&#34;</span>)

  <span style="color:#007f7f">// Инициализируем роуты
</span><span style="color:#007f7f"></span>  initializeRoutes()

  <span style="color:#007f7f">// Запускаем приложение
</span><span style="color:#007f7f"></span>  router.Run()

}</pre></div>
<h5 id="проектирование-модели-топика">Проектирование модели топика</h5>

<p>Сделаем структуру топика простой, всего с тремя полями &mdash; Id, Title (название) и Content (содержание). Её можно описать так:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">type article struct {
  ID      int    `json:&#34;id&#34;`
  Title   string `json:&#34;title&#34;`
  Content string `json:&#34;content&#34;`
}</pre></div>
<p>Большинство приложений используют базу данных для хранения данных. Чтобы не усложнять, мы будем хранить список топиков в памяти и заполнять его при создании двумя следующими топиками:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">var articleList = []article{
  article{ID: 1, Title: &#34;Article 1&#34;, Content: &#34;Article 1 body&#34;},
  article{ID: 2, Title: &#34;Article 2&#34;, Content: &#34;Article 2 body&#34;},
}</pre></div>
<p>Мы вставим этот кусок кода в новый файл models.article.go. Сейчас нам понадобится функция, возвращающая список всех топиков. Мы её назовём getAllArticles() и положим её в этот же файл. И создадим тест для неё. Мы назовём этот тест TestGetAllArticles и вставим его в файл models.article_test.go.</p>

<p>Создадим тест (TestGetAllArticles) для функции getAllArticles(). В результате файл models.article_test.go будет таким:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#007f7f">// models.article_test.go
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">package</span> main

<span style="color:#fff;font-weight:bold">import</span> <span style="color:#0ff;font-weight:bold">&#34;testing&#34;</span>

<span style="color:#007f7f">// Test the function that fetches all articles
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> TestGetAllArticles(t *testing.T) {
  alist := getAllArticles()

  <span style="color:#007f7f">// Check that the length of the list of articles returned is the
</span><span style="color:#007f7f"></span>  <span style="color:#007f7f">// same as the length of the global variable holding the list
</span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">if</span> <span style="color:#fff;font-weight:bold">len</span>(alist) != <span style="color:#fff;font-weight:bold">len</span>(articleList) {
    t.Fail()
  }

  <span style="color:#007f7f">// Check that each member is identical
</span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">for</span> i, v := <span style="color:#fff;font-weight:bold">range</span> alist {
    <span style="color:#fff;font-weight:bold">if</span> v.Content != articleList[i].Content ||
      v.ID != articleList[i].ID ||
      v.Title != articleList[i].Title {

      t.Fail()
      <span style="color:#fff;font-weight:bold">break</span>
    }
  }
}</pre></div>
<p>В этом тесте используется функция getAllArticles() для получения списка всех топиков. Сперва этот тест проверяет, что эта функция получает список топиков и этот список идентичен списку, загруженному в глобальную переменную articleList. Затем он проходит в цикле по списку топиков для проверки уникальности каждого. Если хотя бы одна из этих проверок не удалась, тест возвращает неудачу.</p>

<p>После написания теста приступим к написанию кода модуля. Файл models.article.go будет содержать такой код:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#007f7f">// models.article.go
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">package</span> main

<span style="color:#fff;font-weight:bold">type</span> article <span style="color:#fff;font-weight:bold">struct</span> {
  ID      <span style="color:#fff;font-weight:bold">int</span>    <span style="color:#0ff;font-weight:bold">`json:&#34;id&#34;`</span>
  Title   <span style="color:#fff;font-weight:bold">string</span> <span style="color:#0ff;font-weight:bold">`json:&#34;title&#34;`</span>
  Content <span style="color:#fff;font-weight:bold">string</span> <span style="color:#0ff;font-weight:bold">`json:&#34;content&#34;`</span>
}

<span style="color:#007f7f">// For this demo, we&#39;re storing the article list in memory
</span><span style="color:#007f7f">// In a real application, this list will most likely be fetched
</span><span style="color:#007f7f">// from a database or from static files
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">var</span> articleList = []article{
  article{ID: <span style="color:#ff0;font-weight:bold">1</span>, Title: <span style="color:#0ff;font-weight:bold">&#34;Article 1&#34;</span>, Content: <span style="color:#0ff;font-weight:bold">&#34;Article 1 body&#34;</span>},
  article{ID: <span style="color:#ff0;font-weight:bold">2</span>, Title: <span style="color:#0ff;font-weight:bold">&#34;Article 2&#34;</span>, Content: <span style="color:#0ff;font-weight:bold">&#34;Article 2 body&#34;</span>},
}

<span style="color:#007f7f">// Return a list of all the articles
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> getAllArticles() []article {
  <span style="color:#fff;font-weight:bold">return</span> articleList
}</pre></div>
<h5 id="создание-шаблона-представления">Создание шаблона представления</h5>

<p>Так как список топиков будет выводится на главной странице, нам не нужно создавать новый шаблон. Однако, нам нужно изменить шаблон index.html для вывода в него списка топиков.</p>

<p>Предположим, что список топиков будет передан в шаблон в переменной payload. Тогда следующий снипет выведет список всех топиков:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">{{range .payload }}
    &lt;!--Create the link for the article based on its ID--&gt;
    &lt;a href=&#34;https://fokusov.com/article/view/{{.ID}}&#34;&gt;
      &lt;!--Display the title of the article --&gt;
      &lt;h2&gt;{{.Title}}&lt;/h2&gt;
    &lt;/a&gt;
    &lt;!--Display the content of the article--&gt;
    &lt;p&gt;{{.Content}}&lt;/p&gt;
  {{end}}</pre></div>
<p>Этот снипет пройдётся по всем элементам переменной payload и выведет название и текст каждого топика. Также этот снипет добавит ссылку в каждый топик. Однако, пока мы ещё не создали обработчик соответствующего роута, и эти ссылки на топики не будут работать.</p>

<p>Обновлённый index.html будет таким:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!--index.html--&gt;

&lt;!--Embed the header.html template at this location--&gt;
{{ template &#34;header.html&#34; .}}

  &lt;!--Loop over the `payload` variable, which is the list of articles--&gt;
  {{range .payload }}
    &lt;!--Create the link for the article based on its ID--&gt;
    &lt;a href=&#34;https://fokusov.com/article/view/{{.ID}}&#34;&gt;
      &lt;!--Display the title of the article --&gt;
      &lt;h2&gt;{{.Title}}&lt;/h2&gt;
    &lt;/a&gt;
    &lt;!--Display the content of the article--&gt;
    &lt;p&gt;{{.Content}}&lt;/p&gt;
  {{end}}

&lt;!--Embed the footer.html template at this location--&gt;
{{ template &#34;footer.html&#34; .}}</pre></div>
<h5 id="определяем-требования-к-обработчику-роута-с-помощью-юнит-теста">Определяем требования к обработчику роута с помощью юнит-теста</h5>

<p>Перед созданием обработчика роута главной страницы, мы создадим тест, чтобы определить поведение этого обработчика. Этот тест проверит следующие условия:</p>

<ol>
<li>Обработчик отвечает статус-кодом HTTP 200,</li>
<li>Возвращаемый HTML содержит тег title с текстом «Home Page».<br />
Код теста поместим в функцию TestShowIndexPageUnauthenticated в файл handlers.article_test.go. Вспомогательные функции, используемые в этом тесте, мы разместим в файле common_test.go.</li>
</ol>

<p>Вот содержимое файла handlers.article_test.go:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#007f7f">// handlers.article_test.go
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">package</span> main

<span style="color:#fff;font-weight:bold">import</span> (
  <span style="color:#0ff;font-weight:bold">&#34;io/ioutil&#34;</span>
  <span style="color:#0ff;font-weight:bold">&#34;net/http&#34;</span>
  <span style="color:#0ff;font-weight:bold">&#34;net/http/httptest&#34;</span>
  <span style="color:#0ff;font-weight:bold">&#34;strings&#34;</span>
  <span style="color:#0ff;font-weight:bold">&#34;testing&#34;</span>
)

<span style="color:#007f7f">// Test that a GET request to the home page returns the home page with
</span><span style="color:#007f7f">// the HTTP code 200 for an unauthenticated user
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> TestShowIndexPageUnauthenticated(t *testing.T) {
  r := getRouter(<span style="color:#fff;font-weight:bold">true</span>)

  r.GET(<span style="color:#0ff;font-weight:bold">&#34;/&#34;</span>, showIndexPage)

  <span style="color:#007f7f">// Create a request to send to the above route
</span><span style="color:#007f7f"></span>  req, _ := http.NewRequest(<span style="color:#0ff;font-weight:bold">&#34;GET&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;/&#34;</span>, <span style="color:#fff;font-weight:bold">nil</span>)

  testHTTPResponse(t, r, req, <span style="color:#fff;font-weight:bold">func</span>(w *httptest.ResponseRecorder) <span style="color:#fff;font-weight:bold">bool</span> {
    <span style="color:#007f7f">// Test that the http status code is 200
</span><span style="color:#007f7f"></span>    statusOK := w.Code == http.StatusOK

    <span style="color:#007f7f">// Test that the page title is &#34;Home Page&#34;
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// You can carry out a lot more detailed tests using libraries that can
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// parse and process HTML pages
</span><span style="color:#007f7f"></span>    p, err := ioutil.ReadAll(w.Body)
    pageOK := err == <span style="color:#fff;font-weight:bold">nil</span> &amp;&amp; strings.Index(<span style="color:#fff;font-weight:bold">string</span>(p), <span style="color:#0ff;font-weight:bold">&#34;&lt;title&gt;Home Page&lt;/title&gt;&#34;</span>) &gt; <span style="color:#ff0;font-weight:bold">0</span>

    <span style="color:#fff;font-weight:bold">return</span> statusOK &amp;&amp; pageOK
  })
}</pre></div>
<p>Файл common_test.go:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#fff;font-weight:bold">package</span> main

<span style="color:#fff;font-weight:bold">import</span> (
  <span style="color:#0ff;font-weight:bold">&#34;net/http&#34;</span>
  <span style="color:#0ff;font-weight:bold">&#34;net/http/httptest&#34;</span>
  <span style="color:#0ff;font-weight:bold">&#34;os&#34;</span>
  <span style="color:#0ff;font-weight:bold">&#34;testing&#34;</span>

  <span style="color:#0ff;font-weight:bold">&#34;github.com/gin-gonic/gin&#34;</span>
)

<span style="color:#fff;font-weight:bold">var</span> tmpArticleList []article

<span style="color:#007f7f">// This function is used for setup before executing the test functions
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> TestMain(m *testing.M) {
  <span style="color:#007f7f">//Set Gin to Test Mode
</span><span style="color:#007f7f"></span>  gin.SetMode(gin.TestMode)

  <span style="color:#007f7f">// Run the other tests
</span><span style="color:#007f7f"></span>  os.Exit(m.Run())
}

<span style="color:#007f7f">// Helper function to create a router during testing
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> getRouter(withTemplates <span style="color:#fff;font-weight:bold">bool</span>) *gin.Engine {
  r := gin.Default()
  <span style="color:#fff;font-weight:bold">if</span> withTemplates {
    r.LoadHTMLGlob(<span style="color:#0ff;font-weight:bold">&#34;templates/*&#34;</span>)
  }
  <span style="color:#fff;font-weight:bold">return</span> r
}

<span style="color:#007f7f">// Helper function to process a request and test its response
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> testHTTPResponse(t *testing.T, r *gin.Engine, req *http.Request, f <span style="color:#fff;font-weight:bold">func</span>(w *httptest.ResponseRecorder) <span style="color:#fff;font-weight:bold">bool</span>) {

  <span style="color:#007f7f">// Create a response recorder
</span><span style="color:#007f7f"></span>  w := httptest.NewRecorder()

  <span style="color:#007f7f">// Create the service and process the above request.
</span><span style="color:#007f7f"></span>  r.ServeHTTP(w, req)

  <span style="color:#fff;font-weight:bold">if</span> !f(w) {
    t.Fail()
  }
}

<span style="color:#007f7f">// This function is used to store the main lists into the temporary one
</span><span style="color:#007f7f">// for testing
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> saveLists() {
  tmpArticleList = articleList
}

<span style="color:#007f7f">// This function is used to restore the main lists from the temporary one
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">func</span> restoreLists() {
  articleList = tmpArticleList
}</pre></div>
<p>Для написания теста мы написали несколько вспомогательных функций. Они в дальнейшем помогут нам уменьшить количество кода при написании похожих тестов.</p>

<p>Функция TestMain переводит Gin в тестовый режим и вызывает функции тестирования. Функция getRouter создаёт и возвращает роутер. Функция saveLists() помещает список топиков во временную переменную. Она используется в функции restoreLists() для восстановления списка топиков до первоначального состояния после выполнения юнит-теста.</p>

<p>И, наконец, функция testHTTPResponse выполняет переданную ей функцию для проверки &mdash; возвращает ли она булево значение true &mdash; показывая успешность теста, или нет. Эта функция помогает нам избежать дублирования кода, необходимого для тестирования ответа на HTTP-запрос.</p>

<p>Для проверки HTTP-кода и возвращаемого HTML, сделаем следующее:</p>

<ol>
<li>Создадим новый роутер,</li>
<li>Определим роуту тот же обработчик, что используется в главном приложении (showIndexPage),</li>
<li>Создадим новый запрос для доступа к роуту,</li>
<li>Создадим функцию, обрабатывающую ответ, для тестирования HTTP-кода и HTML, и</li>
<li>Вызовем testHTTPResponse() из новой функции для завершения теста.</li>
</ol>

<h5 id="создание-обработчика-роута">Создание обработчика роута</h5>

<p>Мы будет создавать все обработчики роутов, относящихся к топикам, в файле handlers.article.go. Обработчик главной страницы, showIndexPage выполняет следующие задачи:</p>

<p><strong>1. Получает список топиков</strong></p>

<p>Это делается с помощью функции getAllArticles, созданной ранее:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">articles := getAllArticles()</pre></div>
<p><strong>2. Обрабатывает шаблон index.html, передавая ему список топиков</strong></p>

<p>Это делается с помощью кода ниже:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">c.HTML(
    // Set the HTTP status to 200 (OK)
    http.StatusOK,
    // Use the index.html template
    &#34;index.html&#34;,
    // Pass the data that the page uses
    gin.H{
        &#34;title&#34;:   &#34;Home Page&#34;,
        &#34;payload&#34;: articles,
    },
)</pre></div>
<p>Разница с кодом из предыдущего раздела только в том, что мы передаём список топиков, который можно прочитать в шаблоне в переменной payload.</p>

<p>Файл handlers.article.go должен быть таким:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#007f7f">// handlers.article.go
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">package</span> main

<span style="color:#fff;font-weight:bold">import</span> (
  <span style="color:#0ff;font-weight:bold">&#34;net/http&#34;</span>

  <span style="color:#0ff;font-weight:bold">&#34;github.com/gin-gonic/gin&#34;</span>
)

<span style="color:#fff;font-weight:bold">func</span> showIndexPage(c *gin.Context) {
  articles := getAllArticles()

  <span style="color:#007f7f">// Call the HTML method of the Context to render a template
</span><span style="color:#007f7f"></span>  c.HTML(
    <span style="color:#007f7f">// Set the HTTP status to 200 (OK)
</span><span style="color:#007f7f"></span>    http.StatusOK,
    <span style="color:#007f7f">// Use the index.html template
</span><span style="color:#007f7f"></span>    <span style="color:#0ff;font-weight:bold">&#34;index.html&#34;</span>,
    <span style="color:#007f7f">// Pass the data that the page uses
</span><span style="color:#007f7f"></span>    gin.H{
      <span style="color:#0ff;font-weight:bold">&#34;title&#34;</span>:   <span style="color:#0ff;font-weight:bold">&#34;Home Page&#34;</span>,
      <span style="color:#0ff;font-weight:bold">&#34;payload&#34;</span>: articles,
    },
  )

}</pre></div>
<p>Если сейчас собрать и запустить приложение, открыть в браузере <a href="http://localhost:8080">http://localhost:8080</a>, оно будет выглядеть так:</p>

<p><img src="img/x4f02c8af3e.png.pagespeed.ic.Oou9m93pqm.png" alt="Разработка: Разработка Web-приложений и микросервисов на Golang с Gin" /></p>

<p>Новые файлы, добавленные в этом разделе:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">├── common_test.go
├── handlers.article.go
├── handlers.article_test.go
├── models.article.go
├── models.article_test.go
└── routes.go</pre></div>
<h5 id="вывод-топика">Вывод топика</h5>

<p>У нас пока не работают ссылки на топики из общего списка. Сейчас мы добавим обработчики клика и шаблон для вывода топика.</p>

<h5 id="настройка-роутов">Настройка роутов</h5>

<p>Мы можем создать роут для обработки запросов для топика подобно роуту из предыдущей части. Однако, мы должны учитывать, что хотя обработчик для всех топиков будет один, URL каждого топика должен быть уникальным. Gin позволяет это сделать с помощью передачи параметров в роут:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">router.GET(&#34;/article/view/:article_id&#34;, getArticle)</pre></div>
<p>Этот роут будет обрабатывать соответствующие указанному пути запросы, а также хранить значение параметра, переданного в роут &mdash; article_id, который мы обработаем в обработчике роута. Обработчиком нашего роута будет функция getArticle.</p>

<p>Изменённый файл routes.go:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#007f7f">// routes.go
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">package</span> main

<span style="color:#fff;font-weight:bold">func</span> initializeRoutes() {

  <span style="color:#007f7f">// обработчик главного роута
</span><span style="color:#007f7f"></span>  router.GET(<span style="color:#0ff;font-weight:bold">&#34;/&#34;</span>, showIndexPage)

  <span style="color:#007f7f">// Обработчик GET-запросов на /article/view/некоторый_article_id
</span><span style="color:#007f7f"></span>  router.GET(<span style="color:#0ff;font-weight:bold">&#34;/article/view/:article_id&#34;</span>, getArticle)

}</pre></div>
<h5 id="шаблоны">Шаблоны</h5>

<p>Для вывода топика нам нужно создать новый шаблон templates/article.html. Он будет создан так же, как шаблон index.html, но с небольшим отличием: вместо передачи в него переменной со списком топиков, мы будем передавать в него только один топик.</p>

<p>Посмотреть код шаблона <a href="https://github.com/demo-apps/go-gin-app/blob/3-display-single-article/templates/article.html">article.html</a> можно на Github.</p>

<h5 id="определяем-требования-к-обработчику-роутов-юнит-тестами">Определяем требования к обработчику роутов юнит-тестами</h5>

<p>Тест обработчика будет проверять выполнение следующих условий:</p>

<ol>
<li>Обработчик отвечает статус-кодом HTTP 200,</li>
<li>Возвращаемый HTML содержит тег title, содержащий название полученного топика.<br />
Код теста будет в функции TestArticleUnauthenticated в файле handlers.article_test.go. Вспомогательные функции мы разместим в файле common_test.go.</li>
</ol>

<h5 id="создаём-обработчик-роута">Создаём обработчик роута</h5>

<p>Итак, что должен делать обработчик роута для топика &mdash; getArticle:</p>

<p><strong>1. Получить ID топика для вывода</strong></p>

<p>Для вывода нужного топика, мы должны получить его ID из контекста. Примерно так:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">c.Param(&#34;article_id&#34;)</pre></div>
<p>где c &mdash; это Контекст Gin, который передаётся параметром в любой обработчик при разработке с Gin.</p>

<p><strong>2. Получить сам топик</strong></p>

<p>Это можно сделать с помощью функции getArticleByID() из файла models.article.go:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">article, err := getArticleByID(articleID)</pre></div>
<p>Функция getArticleByID (в models.article.go) выглядит так:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">func getArticleByID(id int) (*article, error) {
  for _, a := range articleList {
    if a.ID == id {
      return &amp;a, nil
    }
  }
  return nil, errors.New(&#34;Article not found&#34;)
}</pre></div>
<p>Эта функция считывает список топиков в цикле и возвращает топик, ID которого соответствует переданному ID. Если такого топика нет, она возвращает ошибку.</p>

<p><strong>3. Обработать шаблон article.html, передав в него топик</strong></p>

<p>Код ниже как раз делает это:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">c.HTML(
    // Зададим HTTP статус 200 (OK)
    http.StatusOK,
    // Используем шаблон article.html
    &#34;article.html&#34;,
    // Передадим данные в шаблон
    gin.H{
        &#34;title&#34;:   article.Title,
        &#34;payload&#34;: article,
    },
)</pre></div>
<p>Обновлённый файл handlers.article.go будет таким:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#007f7f">// handlers.article.go
</span><span style="color:#007f7f"></span>
<span style="color:#fff;font-weight:bold">package</span> main

<span style="color:#fff;font-weight:bold">import</span> (
  <span style="color:#0ff;font-weight:bold">&#34;net/http&#34;</span>
  <span style="color:#0ff;font-weight:bold">&#34;strconv&#34;</span>

  <span style="color:#0ff;font-weight:bold">&#34;github.com/gin-gonic/gin&#34;</span>
)

<span style="color:#fff;font-weight:bold">func</span> showIndexPage(c *gin.Context) {
  articles := getAllArticles()

  <span style="color:#007f7f">// Вызовем метод HTML из Контекста Gin для обработки шаблона
</span><span style="color:#007f7f"></span>  c.HTML(
    <span style="color:#007f7f">// Зададим HTTP статус 200 (OK)
</span><span style="color:#007f7f"></span>    http.StatusOK,
    <span style="color:#007f7f">// Используем шаблон index.html
</span><span style="color:#007f7f"></span>    <span style="color:#0ff;font-weight:bold">&#34;index.html&#34;</span>,
    <span style="color:#007f7f">// Передадим данные в шаблон
</span><span style="color:#007f7f"></span>    gin.H{
      <span style="color:#0ff;font-weight:bold">&#34;title&#34;</span>:   <span style="color:#0ff;font-weight:bold">&#34;Home Page&#34;</span>,
      <span style="color:#0ff;font-weight:bold">&#34;payload&#34;</span>: articles,
    },
  )

}

<span style="color:#fff;font-weight:bold">func</span> getArticle(c *gin.Context) {
  <span style="color:#007f7f">// Проверим валидность ID
</span><span style="color:#007f7f"></span>  <span style="color:#fff;font-weight:bold">if</span> articleID, err := strconv.Atoi(c.Param(<span style="color:#0ff;font-weight:bold">&#34;article_id&#34;</span>)); err == <span style="color:#fff;font-weight:bold">nil</span> {
    <span style="color:#007f7f">// Проверим существование топика
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> article, err := getArticleByID(articleID); err == <span style="color:#fff;font-weight:bold">nil</span> {
      <span style="color:#007f7f">// Вызовем метод HTML из Контекста Gin для обработки шаблона
</span><span style="color:#007f7f"></span>      c.HTML(
        <span style="color:#007f7f">// Зададим HTTP статус 200 (OK)
</span><span style="color:#007f7f"></span>        http.StatusOK,
        <span style="color:#007f7f">// Используем шаблон index.html
</span><span style="color:#007f7f"></span>        <span style="color:#0ff;font-weight:bold">&#34;article.html&#34;</span>,
        <span style="color:#007f7f">// Передадим данные в шаблон
</span><span style="color:#007f7f"></span>        gin.H{
          <span style="color:#0ff;font-weight:bold">&#34;title&#34;</span>:   article.Title,
          <span style="color:#0ff;font-weight:bold">&#34;payload&#34;</span>: article,
        },
      )

    } <span style="color:#fff;font-weight:bold">else</span> {
      <span style="color:#007f7f">// Если топика нет, прервём с ошибкой
</span><span style="color:#007f7f"></span>      c.AbortWithError(http.StatusNotFound, err)
    }

  } <span style="color:#fff;font-weight:bold">else</span> {
    <span style="color:#007f7f">// При некорректном ID в URL, прервём с ошибкой
</span><span style="color:#007f7f"></span>    c.AbortWithStatus(http.StatusNotFound)
  }
}</pre></div>
<p>Если сейчас собрать и запустить наше приложение, при открытии <a href="http://localhost:8080/article/view/1">localhost:8080/article/view/1</a> в браузере оно будет выглядеть так:</p>

<p><img src="img/xab6af14e6f.png.pagespeed.ic.bNYyH_6G5g.png" alt="Разработка: Разработка Web-приложений и микросервисов на Golang с Gin" /></p>

<p>Новые файлы, добавленные в этом разделе:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">└── templates
    └── article.html</pre></div>
<h5 id="ответ-в-json-xml">Ответ в JSON/XML</h5>

<p>В этом разделе мы немного перепишем приложение так, что оно, в зависимости от заголовков запроса, будет отвечать в формате HTML, JSON или XML.</p>

<h5 id="повторно-используемые-функции">Повторно используемые функции</h5>

<p>До сих пор мы использовали метод HTML Контекста Gin для обработки шаблонов прямо из обработчика. Этот способ хорошо если мы всегда будем выводить только в формате HTML. Однако, если мы хотим менять формат ответа, к примеру, на основе какого-то параметра, мы должны переписать эту часть функции, чтобы она делала только валидацию данных и их получение, а выводом в шаблон будет заниматься другая функция в зависимости от формата вывода на основе заголовка Accept. Мы создадим эту функция в файле main.go и она будет общая для всех обработчиков.</p>

<p>В Gin в Контексте, переданном обработчику роута, есть поле Request. В этом поле есть Header, в котором содержатся все заголовки запроса. Для получения заголовка Accept мы можем использовать метод Get в Header, вот так:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// c - это Gin Context
c.Request.Header.Get(&#34;Accept&#34;)</pre></div>
<ul>
<li>Если заголовок: application/json, функция выводит JSON,</li>
<li>Если заголовок: application/xml, функция выводит XML, и</li>
<li>Если заголовок любой другой или вообще пустой, функция выводит HTML.<br />
Полный код функции:</li>
</ul>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// Render one of HTML, JSON or CSV based on the &#39;Accept&#39; header of the request
// If the header doesn&#39;t specify this, HTML is rendered, provided that
// the template name is present
func render(c *gin.Context, data gin.H, templateName string) {

  switch c.Request.Header.Get(&#34;Accept&#34;) {
  case &#34;application/json&#34;:
    // Respond with JSON
    c.JSON(http.StatusOK, data[&#34;payload&#34;])
  case &#34;application/xml&#34;:
    // Respond with XML
    c.XML(http.StatusOK, data[&#34;payload&#34;])
  default:
    // Respond with HTML
    c.HTML(http.StatusOK, templateName, data)
  }

}</pre></div>
<h5 id="изменяем-требования-к-обработчику-роутов">Изменяем требования к обработчику роутов</h5>

<p>Так как мы теперь должны проверить ответ в JSON и XML если задан специальный заголовок, нам нужно добавить тесты в файл handlers.article_test.go для проверки этих условий:</p>

<ol>
<li>Проверить, что приложение вернёт список топиков в формате JSON если заголовок Accept равен application/json</li>
<li>Проверить, что приложение вернёт список топиков в формате XML если заголовок Accept равен application/xml<br />
Мы добавим соответствующие функции TestArticleListJSON и TestArticleXML.</li>
</ol>

<h5 id="обновляем-обработчики">Обновляем обработчики</h5>

<p>Обработчик у нас уже полностью готов, нам нужно только изменить метод обработки c.HTML на соответствующий требуемому формату метод вывода.</p>

<p>К примеру, обработчик роута showIndexPage будет изменён с такого:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">func showIndexPage(c *gin.Context) {
  articles := getAllArticles()

  // Call the HTML method of the Context to render a template
  c.HTML(
    // Set the HTTP status to 200 (OK)
    http.StatusOK,
    // Use the index.html template
    &#34;index.html&#34;,
    // Pass the data that the page uses
    gin.H{
      &#34;title&#34;:   &#34;Home Page&#34;,
      &#34;payload&#34;: articles,
    },
  )

}</pre></div>
<p>на такой:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">func showIndexPage(c *gin.Context) {
  articles := getAllArticles()

  // Call the render function with the name of the template to render
  render(c, gin.H{
    &#34;title&#34;:   &#34;Home Page&#34;,
    &#34;payload&#34;: articles}, &#34;index.html&#34;)

}</pre></div>
<p><strong>Получаем список топиков в формате JSON</strong></p>

<p>Чтобы увидеть приложение в работе, соберём его и запустим. Затем выполним следующую команду:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">curl -X GET -H &#34;Accept: application/json&#34; http://localhost:8080/</pre></div>
<p>Она должна вернуть следующее:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[{&#34;id&#34;:1,&#34;title&#34;:&#34;Article 1&#34;,&#34;content&#34;:&#34;Article 1 body&#34;},{&#34;id&#34;:2,&#34;title&#34;:&#34;Article 2&#34;,&#34;content&#34;:&#34;Article 2 body&#34;}]</pre></div>
<p>Как вы видите, мы получили ответ в формате JSON, передав заголовок Accept как application/json.</p>

<p><strong>Список топиков в формате XML</strong></p>

<p>Теперь запросим детали конкретной статьи в формате XML. Для этого запустите приложение как написано выше и затем выполните команду:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">curl -X GET -H &#34;Accept: application/xml&#34; http://localhost:8080/article/view/1</pre></div>
<p>В ответ должно прийти следующее:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;article&gt;&lt;ID&gt;1&lt;/ID&gt;&lt;Title&gt;Article 1&lt;/Title&gt;&lt;Content&gt;Article 1 body&lt;/Content&gt;&lt;/article&gt;</pre></div>
<h5 id="тестирование-приложения">Тестирование приложения</h5>

<p>Мы использовали тесты для определения требований к обработчикам роутов и моделям, поэтому можем теперь запустить их и проверить, что всё работает как предполагалось. В директории проекта запустите следующую команду:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">go test -v</pre></div>
<p>Результат должен быть примерно таким:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">=== RUN   TestShowIndexPageUnauthenticated
[GIN] 2016/06/14 - 19:07:26 | 200 |     183.315µs |  |   GET     /
--- PASS: TestShowIndexPageUnauthenticated (0.00s)
=== RUN   TestArticleUnauthenticated
[GIN] 2016/06/14 - 19:07:26 | 200 |     143.789µs |  |   GET     /article/view/1
--- PASS: TestArticleUnauthenticated (0.00s)
=== RUN   TestArticleListJSON
[GIN] 2016/06/14 - 19:07:26 | 200 |      51.087µs |  |   GET     /
--- PASS: TestArticleListJSON (0.00s)
=== RUN   TestArticleXML
[GIN] 2016/06/14 - 19:07:26 | 200 |      38.656µs |  |   GET     /article/view/1
--- PASS: TestArticleXML (0.00s)
=== RUN   TestGetAllArticles
--- PASS: TestGetAllArticles (0.00s)
=== RUN   TestGetArticleByID
--- PASS: TestGetArticleByID (0.00s)
PASS
ok    github.com/demo-apps/go-gin-app 0.084s</pre></div>
<p>Как мы видим, эта команда запускает все написанные нами тесты и, в нашем случае, сообщает, что всё работает как положено. Если вы присмотритесь к выводу, то увидите, что Go также сделал и HTTP запросы для нас, проверив обработчики роутов.</p>

<h5 id="заключение">Заключение</h5>

<p>В этом цикле статей мы сделали приложение с помощью фреймворка Gin и постепенно добавили в него функционал. Мы написали тесты, чтобы наше приложение было надёжным, а также использовали методологию повторно используемого кода, чтобы сделать вывод в различные форматы без больших затрат времени.</p>

<p>Код приложения можно скачать в <a href="https://github.com/demo-apps/go-gin-app">этом Github репозитории</a>.</p>

<p>Gin очень прост для того, чтобы начать писать веб-приложения &mdash; вкупе со встроенной функциональностью Go, он легко позволяет строить высококачественные, хорошо покрытые тестами веб-приложения и микросервисы.</p>

<p>По материалам <a href="https://semaphoreci.com/community/tutorials/building-go-web-applications-and-microservices-using-gin">Building Go Web Applications and Microservices Using Gin</a></p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>10 лучших редакторов с поддержкой Markdown для Linux</turbo:topic>
      <link>https://fokusov.com/posts/10-luchshih-redaktorov-s-podderzhkoj-markdown-dlja-linux/</link>
      <pubDate>Sat, 04 Feb 2017 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ 

<p><img src="img/xc017de40c9.png.pagespeed.ic.OgMVt0MlM_.png" alt="Софт: 10 лучших редакторов с поддержкой Markdown для Linux" /></p>

<p>В этой ста­тье мы рас­смот­рим несколь­ко луч­ших ре­дак­то­ров с под­держ­кой Markdown, ко­то­рые мож­но уста­но­вить и ис­поль­зо­вать в Linux. На са­мом де­ле их на­мно­го боль­ше, но мы рас­смот­рим толь­ко са­мые удоб­ные из них.</p>

<p><a href="https://ru.wikipedia.org/wiki/Markdown">Markdown (марк­даун)</a> &mdash; это об­лег­чён­ный язык раз­мет­ки, со­здан­ный с це­лью на­пи­са­ния мак­си­маль­но чи­та­е­мо­го и удоб­но­го для прав­ки тек­ста, но при­год­но­го для пре­об­ра­зо­ва­ния в язы­ки для про­дви­ну­тых пуб­ли­ка­ций (HTML, Rich Text и др.).</p>

<h4 id="atom">Atom</h4>

<p>Atom это со­вре­мен­ный, крос­сплат­фор­мен­ный, мощ­ный тек­сто­вый ре­дак­тор с от­кры­тым ис­ход­ным ко­дом, ра­бо­та­ю­щий в Linux, Windows и Mac OS X. Он очень хо­ро­шо на­стра­и­ва­ет­ся, в том чис­ле бла­го­да­ря пла­ги­нам.</p>

<p>В чис­ло его пре­иму­ществ вхо­дят сле­ду­ю­щие:</p>

<ul>
<li>Встро­ен­ный ме­не­джер па­ке­тов (пла­ги­ны, те­мы и т.п.)</li>
<li>Ум­ное ав­то­до­пол­не­ние ко­да</li>
<li>Под­держ­ка раз­де­ле­ния ок­на</li>
<li>По­иск и за­ме­на тек­ста</li>
<li>Встро­ен­ный дис­пет­чер фай­лов</li>
<li>На­стра­и­ва­е­мые те­мы</li>
<li>Лег­ко рас­ши­ря­ем с по­мо­щью пла­ги­нов с от­кры­тым ис­ход­ным ко­дом<br />
<img src="http://i2.wp.com/blog.javabien.net/wp-content/uploads/2014/03/atom.gif?resize=660%2C343" alt="Софт: 10 лучших редакторов с поддержкой Markdown для Linux" /></li>
</ul>

<p>До­маш­няя стра­ни­ца: <a href="https://atom.io/">https://​atom.​io/</a></p>

<h4 id="vs-code">VS Code</h4>

<p><img src="https://code.visualstudio.com/images/Markdown_selection-preview-scroll-sync.gif" alt="Софт: 10 лучших редакторов с поддержкой Markdown для Linux" /></p>

<p>Всё, опи­сан­ное для преды­ду­ще­го при­ло­же­ния, спра­вед­ли­во и для Visual Studio Code. Это удоб­ный и мощ­ный ре­дак­тор с от­кры­тым ис­ход­ным ко­дом, рас­ши­ря­е­мый с по­мо­щью пла­ги­нов и с под­держ­кой тем оформ­ле­ния. Име­ет встро­ен­ный от­лад­чик и кли­ент си­сте­мы кон­тро­ля вер­сий. Ра­бо­та­ет с Markdown та­к­же с по­мо­щью удоб­но­го пла­ги­на, сра­зу по­ка­зы­вая ре­зуль­тат в со­сед­нем окне.</p>

<p>До­маш­няя стра­ни­ца: <a href="https://code.visualstudio.com">https://​code.​vis​uals​tudi​o.​com</a></p>

<h4 id="gnu-emacs">GNU Emacs</h4>

<p>Кто не зна­ет Emacs? Это­му ре­дак­то­ру уже бо­лее 40 лет и он счи­та­ет­ся од­ним из са­мых по­пу­ляр­ных при­ло­же­ний под *nix си­сте­мы.</p>

<p>Важ­ные функ­ции:</p>

<ul>
<li>Встро­ен­ная до­ку­мен­та­ция и учеб­ник для но­вич­ков</li>
<li>Пол­ная под­держ­ка Unicode</li>
<li>Раз­лич­ные ре­жи­мы ре­дак­ти­ро­ва­ния тек­ста, на­стро­ить ре­дак­тор под се­бя неслож­но</li>
<li>Под­свет­ка син­так­си­са для боль­шин­ства ти­пов фай­лов</li>
<li>Хо­ро­шо на­стра­и­ва­ет­ся на Emacs Lisp или че­рез GUI</li>
<li>Есть си­сте­ма па­ке­тов для за­груз­ки и уста­нов­ки, огром­ное со­об­ще­ство и еще мно­го все­го&hellip;<br />
<img src="img/x6f9a4bb89e.png.pagespeed.ic.FkQbM-v6k5.png" alt="Софт: 10 лучших редакторов с поддержкой Markdown для Linux" /></li>
</ul>

<p>До­маш­няя стра­ни­ца: <a href="https://www.gnu.org/software/emacs/">https://​www.​gnu.​org/​sof​twar​e/​emacs/</a></p>

<h4 id="remarkable">Remarkable</h4>

<p>Remarkable, воз­мож­но, луч­ший из пе­ре­чис­лен­ных ре­дак­тор Markdown для Linux. Он под­дер­жи­ва­ет пол­ный син­так­сис Markdown и чрез­вы­чай­но функ­ци­о­на­лен:</p>

<ul>
<li>Пред­про­смотр в ре­аль­ном вре­ме­ни</li>
<li>Экс­порт в PDF и HTML</li>
<li>Под­держ­ка Github Markdown</li>
<li>Под­держ­ка сво­их сти­лей CSS</li>
<li>Под­свет­ка син­так­си­са с ав­то­ма­ти­че­ским опре­де­ле­ни­ем язы­ка</li>
<li>Го­ря­чие кла­ви­ши<br />
<img src="img/xc2f6f4259e.png.pagespeed.ic.lwijPEKfNq.png" alt="Софт: 10 лучших редакторов с поддержкой Markdown для Linux" /></li>
</ul>

<p>До­маш­няя стра­ни­ца: <a href="https://remarkableapp.github.io">https://​rem​arka​blea​pp.​github.​io</a></p>

<h4 id="retext">ReText</h4>

<p>ReText это про­стой, лёг­кий и мощ­ный ре­дак­тор Markdown для Linux. Об­ла­да­ет сле­ду­ю­щи­ми функ­ци­я­ми:</p>

<ul>
<li>Про­стой и ин­ту­и­тив­ный GUI</li>
<li>Очень на­стра­и­ва­е­мый</li>
<li>Под­держ­ка цве­то­вых схем</li>
<li>Под­держ­ка ма­те­ма­ти­че­ских фор­мул</li>
<li>Есть рас­ши­ре­ния для экс­пор­та тек­ста и мно­гое дру­гое&hellip;<br />
<img src="img/xb7dc1cd669.png.pagespeed.ic.fXmfDJDZDb.png" alt="Софт: 10 лучших редакторов с поддержкой Markdown для Linux" /></li>
</ul>

<p>До­маш­няя стра­ни­ца: <a href="https://github.com/retext-project/retext">https://​github.​com/​retext-​project/​retext</a></p>

<h4 id="mark-my-words">Mark My Words</h4>

<p>Mark My Words это та­к­же лёг­кий, но мощ­ный ре­дак­тор Markdown. Он от­но­си­тель­но мо­ло­дой, но об­ла­да­ет мно­ги­ми важ­ны­ми функ­ци­я­ми, вклю­чая под­свет­ку син­так­си­са, про­стой и удоб­ный GUI.</p>

<ul>
<li>Пред­про­смотр в ре­аль­ном вре­ме­ни</li>
<li>Экс­порт в PDF и HTML</li>
<li>Сле­же­ние за из­ме­не­ни­я­ми фай­лов во внеш­ней про­грам­ме<br />
<img src="img/x11cc915fce.png.pagespeed.ic.z0GidCoYBI.png" alt="Софт: 10 лучших редакторов с поддержкой Markdown для Linux" /></li>
</ul>

<p>До­маш­няя стра­ни­ца: <a href="https://github.com/voldyman/MarkMyWords">https://​github.​com/​vol​dyma​n/​Mar​kMyW​ords</a></p>

<h4 id="vim-instant-markdown-plugin">Vim-Instant-Markdown Plugin</h4>

<p>Vim это очень по­пу­ляр­ный и мощ­ный тек­сто­вый ре­дак­тор под Linux, та­к­же про­ве­рен­ный вре­ме­нем. Он очень лю­бим про­грам­ми­ста­ми за гиб­кость, лёг­кость и рас­ши­ря­е­мость.</p>

<p>Для Vim есть несколь­ко пла­ги­нов для под­держ­ки Markdown, по­про­буй­те наи­бо­лее эф­фек­тив­ный из них Vim-Instant-Markdown.</p>

<p><img src="https://camo.githubusercontent.com/6e7dc465d334c2f962ad8c8bfee654d0e8da24ff/687474703a2f2f646c2e64726f70626f782e636f6d2f752f32383935363236372f696e7374616e742d6d61726b646f776e2d64656d6f5f7468756d622e676966" alt="Софт: 10 лучших редакторов с поддержкой Markdown для Linux" /></p>

<p>До­маш­няя стра­ни­ца: <a href="https://github.com/suan/vim-instant-markdown">https://​github.​com/​suan/​vim-​instant-​markdown</a></p>

<h4 id="sublimetext-markdown-пла-гин">SublimeText-Markdown пла­гин</h4>

<p>Sublime Text очень по­пу­ля­рен и не нуж­да­ет­ся в пред­став­ле­нии. Для под­держ­ки в нём Markdown ре­ко­мен­дую пла­гин <a href="https://github.com/SublimeText-Markdown/MarkdownEditing">SublimeText-Markdown</a>, он име­ет от­лич­ную под­свет­ку син­так­си­са, вы­бор цве­то­вых схем и мно­гое дру­гое.</p>

<p><img src="img/x8a38ebc8d6.png.pagespeed.ic.uFSmx0kZSE.png" alt="Софт: 10 лучших редакторов с поддержкой Markdown для Linux" /></p>

<h4 id="typora">Typora</h4>

<p>Typora не име­ет ок­на пред­про­смот­ра, пе­ре­клю­ча­те­ля ре­жи­ма и все­го та­ко­го. В ней все­го од­но ок­но с под­свет­кой син­так­си­са Markdown в ре­аль­ном вре­ме­ни, что­бы вас ни­что не от­вле­ка­ло от тек­ста.</p>

<p>Ос­нов­ные воз­мож­но­сти:</p>

<ul>
<li>Под­держ­ка Markdown, вклю­чая таб­ли­цы, бло­ки ко­да с под­свет­кой, LaTeX, Оглав­ле­ния.</li>
<li>Крос­сплат­фор­мен­ность</li>
<li>Кра­си­вый ин­тер­фейс и под­держ­ка сво­их CSS сти­лей.</li>
<li>Удоб­ный экс­порт за­ме­ток</li>
</ul>

<iframe width="560" height="315" src="https://www.youtube.com/embed/RLTQ9bnsvFI?ecver=1" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

<p>До­маш­няя стра­ни­ца: <a href="https://typora.io/">https://​typora.​io/</a></p>

<p>На­де­юсь, с этим спис­ком вы вы­бе­ре­те се­бе удоб­ный ре­дак­тор по вку­су!</p>

<p>Ес­ли у вас есть свои пред­ло­же­ния по те­ме, пред­ла­гаю об­су­дить их в ком­мен­та­ри­ях :)</p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Минификация JavaScript кода в приложении NativeScript Angular 2</turbo:topic>
      <link>https://fokusov.com/posts/minifikacija-javascript-koda-v-prilozhenii-nativescript-angular-2/</link>
      <pubDate>Mon, 30 Jan 2017 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ <p><img src="img/x85c3ebeecc.png.pagespeed.ic.BkZ4Zy55ib.png" alt="Разработка: Минификация JavaScript кода в приложении NativeScript Angular 2" /></p>

<p>Сегодня я покажу вам как использовать <a href="https://github.com/webpack/webpack">WebPack</a>, <a href="https://github.com/babel/babel">Babel</a> и <a href="https://github.com/mishoo/UglifyJS2">UglifyJS</a> для минификации, искажения и склеивания JavaScript в приложениях <a href="http://docs.nativescript.org/angular/start/introduction.html">NativeScript Angular 2</a>.</p>

<p>Устанавливаем NativeScript:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">npm install nativescript -g</pre></div>
<p>Создаём приложение Angular 2:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">tns create MyApp --ng</pre></div>
<p>Устанавливаем <a href="https://github.com/NativeScript/nativescript-dev-webpack">nativescript-dev-webpack</a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-core">babel-core</a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-preset-es2015">babel-preset-es2015</a> и <a href="https://github.com/babel/babel-loader">babel-loader</a> в наше приложение:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">cd MyApp
npm install nativescript-dev-webpack --save-dev
npm install babel-core --save-dev
npm install babel-preset-es2015 --save-dev
npm install babel-loader --save-dev</pre></div>
<p>Открываем приложение в любимом редакторе и добавляем babel-loader в конец секции загрузчиков и плагин UglifyJS в конец секции плагинов в webpack.common.js:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">{
    test: /nativescript-intl.*\.js$/,
    loader: &#39;babel-loader&#39;,
    query: {
       presets: [&#39;es2015&#39;]
    }
}</pre></div>
<p><img src="img/xcc42692954.png.pagespeed.ic.OZewXOE1Vp.png" alt="Разработка: Минификация JavaScript кода в приложении NativeScript Angular 2" /></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">new webpack.optimize.UglifyJsPlugin({ compress: false })</pre></div>
<p><img src="img/xd361c28c49.png.pagespeed.ic.KdbA_DrHcM.png" alt="Разработка: Минификация JavaScript кода в приложении NativeScript Angular 2" /></p>

<p>** Сжатие отключено из-за генерации классов Android в NativeScript во время сборки. Компрессор UglifyJS это преобразователь синтаксического дерева, уменьшающий размер кода, делая различные оптимизации с деревом.*</p>

<p>Создаём бандл и запускаем приложение:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">npm run start-android-bundle</pre></div>
<p>или так для ios:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">npm run start-ios-bundle</pre></div>
<p>Результат можно увидеть в папке платформы ios/android:
<img src="img/x85c3ebeecc.png.pagespeed.ic.BkZ4Zy55ib.png" alt="Разработка: Минификация JavaScript кода в приложении NativeScript Angular 2" /></p>

<p>Созданный JavaScript код минифицирован, искажён и забандлен.
Наслаждайтесь!</p>

<p><a href="https://medium.com/@enchev/minify-uglify-and-bundle-your-javascript-in-nativescript-angular-2-app-aabf84f47fbb#.rbn2klwdw">Источник</a>: Minify, uglify and bundle your JavaScript in NativeScript <a href="https://tehnojam.pro/tag/angular/">Angular</a> 2 app</p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Создание кроссплатформенного плеера для SoundCloud® с Fuse</turbo:topic>
      <link>https://fokusov.com/posts/krossplatformennyj-pleer-dlja-soundcloud-s-fuse/</link>
      <pubDate>Mon, 30 Jan 2017 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ 

<p><img src="img/x09990b693e.jpg.pagespeed.ic.ubHmP0mjiw.jpg" alt="Разработка: Безопасность: Кроссплатформенный плеер для SoundCloud® с Fuse" /></p>

<p>Мы по­сто­ян­но по­лу­ча­ем за­про­сы от на­ших поль­зо­ва­те­лей, ко­то­рые хо­тят уви­деть, как вы­гля­дят &ldquo;ре­аль­ные про­грам­мы&rdquo;, сде­лан­ные с <a href="https://tehnojam.pro/tag/fuse/">Fuse</a>. <a href="https://www.fusetools.com/docs/tutorial/tutorial">Наш учеб­ник</a> спе­ци­аль­но пред­на­зна­чен для быст­ро­го на­ча­ла ра­бо­ты с Fuse, но при этом он по­ка не со­дер­жит опи­са­ний слож­ных за­дач.</p>

<p>По­это­му я ре­шил сде­лать пол­ную про­грам­му, с пуб­ли­ка­ци­ей в ма­га­зи­ны при­ло­же­ний. Она бу­дет слу­жить при­ме­ром по-на­сто­я­ще­му слож­ных за­дач и бу­дет ве­ли­ко­леп­ным ма­стер-клас­сом.</p>

<p>При­ло­же­ние бу­дет ра­бо­тать с ре­аль­ным бе­кен­дом, оно бу­дет крос­сплат­фор­мен­ным (ра­бо­тать в <a href="https://tehnojam.pro/tag/android/">Android</a> и <a href="https://tehnojam.pro/tag/ios/">iOS</a>) и бу­дет ис­поль­зо­вать несколь­ко ин­те­рес­ных на­тив­ных ин­те­гра­ций на обе­их плат­фор­мах.</p>

<p>Как мы ви­дим, <a href="https://developers.soundcloud.com/">SoundCloud®</a> име­ет всё необ­хо­ди­мое:</p>

<ul>
<li>Они предо­став­ля­ют REST API (и он бес­пла­тен)</li>
<li>Есть мно­го кон­тен­та для ра­бо­ты (кар­тин­ки и му­зы­ка)</li>
<li>На­ше­му при­ло­же­нию по­на­до­бят­ся на­тив­ные ком­по­нен­ты (кон­тро­лы для управ­ле­ния му­зы­кой и т.п.)</li>
</ul>

<h4 id="пе-ред-тем-как-на-чать">Пе­ред тем, как на­чать&hellip;</h4>

<p>Вы мо­же­те не уста­нав­ли­вать Fuse и не <a href="https://github.com/fusetools/FuseCloud">чи­тать код на Github</a>, что­бы уви­деть го­то­вый ре­зуль­тат. При­ло­же­ние FuseCloud <strong>мож­но ска­чать</strong> в <a href="https://itunes.apple.com/us/app/fusecloud/id1173516856?mt=8">Apple App Store</a> и <a href="https://play.google.com/store/apps/details?id=com.fuse.fusecloud&amp;hl=en">Google Play</a>.</p>

<blockquote>
<p>Вни­ма­ние: при­ло­же­ние FuseCloud это <strong>неофи­ци­аль­ный пле­ер для SoundCloud</strong>, и <strong>ни­ка­ким об­ра­зом не свя­за­но с SoundCloud</strong>. Оно про­сто ис­поль­зу­ет <a href="https://developers.soundcloud.com/docs/api/guide">SoundCloud API</a>.</p>
</blockquote>

<h4 id="ре-а-ли-за-ция">Ре­а­ли­за­ция</h4>

<p>Есть три глав­ных под­за­да­чи: поль­зо­ва­тель­ский ин­тер­фейс, на­пи­сан­ный на UX и JavaScript; обёрт­ка во­круг SoundCloud REST API; на­тив­ный му­зы­каль­ный пле­ер.</p>

<h5 id="на-ви-га-ция">На­ви­га­ция</h5>

<p>Я ис­поль­зо­вал ком­по­нен­ты <strong>Router</strong> и <strong>Navigator</strong> для по­стро­е­ния боль­шей ча­сти на­ви­га­ции, с един­ствен­ным ис­клю­че­ни­ем для <strong>PageControl</strong> в глав­ном пред­став­ле­нии, в ко­то­ром вы мо­же­те пе­ре­клю­чать­ся меж­ду тре­мя та­ба­ми (лен­та но­во­стей, по­иск, из­бран­ное). По­сле со­зда­ния каж­дой стра­ни­цы при­ло­же­ния от­дель­ным ком­по­нен­том, на­ви­га­ция бу­дет при­мер­но та­кой:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// fusecloudnavigationstructure.ux
&lt;Navigator DefaultTemplate=&#34;main&#34;&gt;

    &lt;FuseCloud.MainPage ux:Name=&#34;main&#34;&gt;
        &lt;PageControl ux:Name=&#34;pageControl&#34; Active=&#34;searchPage&#34;&gt;
            &lt;Page ux:Name=&#34;newsFeedPage&#34; /&gt;
            &lt;Page ux:Name=&#34;searchPage&#34; /&gt;
            &lt;Page ux:Name=&#34;favoritesPage&#34; /&gt;
        &lt;/PageControl&gt;
    &lt;/FuseCloud.MainPage&gt;

    &lt;FuseCloud.CommentsPage ux:Template=&#34;comments&#34; router=&#34;router&#34; /&gt;

    &lt;FuseCloud.TrackDetailsPage ux:Name=&#34;track&#34; router=&#34;router&#34;/&gt;

&lt;/Navigator&gt;</pre></div>
<h5 id="бес-ко-неч-ная-про-крут-ка">Бес­ко­неч­ная про­крут­ка</h5>

<p>Бла­го­да­ря но­вым воз­мож­но­стям Fuse, я лег­ко со­здал плав­ную бес­ко­неч­ную про­крут­ку для отоб­ра­же­ния всех ком­мен­та­ри­ев к каж­дой ком­по­зи­ции. Встав­ляя от­дель­ные ком­мен­та­рии в блок Deferred, я за­щи­щён от глю­ков при ав­то­ма­ти­че­ской под­груз­ке но­вых эле­мен­тов. Ни­же вы мо­же­те уви­деть при­мер UX-ко­да для со­зда­ния та­кой про­крут­ки:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// fusecloudendlessscroller.ux
&lt;ScrollView ClipToBounds=&#34;False&#34;&gt;
    &lt;StackPanel&gt;
        &lt;Each Items=&#34;{comments}&#34;&gt;
            &lt;Deferred&gt;
                &lt;FuseCloud.DividerLine Alignment=&#34;Top&#34;/&gt;
                &lt;FuseCloud.Comment ux:Name=&#34;comment&#34; ThumbnailUrl=&#34;{avatar_url}&#34; Username=&#34;{username}&#34; Body=&#34;{body}&#34; /&gt;
            &lt;/Deferred&gt;
        &lt;/Each&gt;
    &lt;/StackPanel&gt;
    &lt;Scrolled To=&#34;End&#34; Within=&#34;100&#34;&gt;
        &lt;Callback Handler=&#34;{showMoreComments}&#34; /&gt;
    &lt;/Scrolled&gt;
&lt;/ScrollView&gt;</pre></div>
<p>Про­крут­ка на 100 то­чек от ниж­не­го края при­ло­же­ния вы­зы­ва­ет JavaScript-функ­цию, ко­то­рая под­гру­жа­ет сле­ду­ю­щие ком­мен­та­рии:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// fusecloudendlessscroller.js
function showMoreComments() {
    if (nCommentsShowing &lt; allComments.length) {
        nCommentsShowing += nCommentsPerPage;
        while (comments.length &lt; nCommentsShowing &amp;&amp; comments.length &lt; allComments.length - 1) {
            comments.add(allComments.getAt(comments.length));
        }
    }
}</pre></div>
<h5 id="за-мут-не-ние-фо-на">За­мут­не­ние фо­на</h5>

<p>Экран про­иг­ры­ва­те­ля по­ка­зы­ва­ет изоб­ра­же­ние аль­бо­ма те­ку­щей до­рож­ки по­се­ре­дине стра­ни­цы, при этом за­пол­няя весь фон за­тем­нён­ной ко­пи­ей это­го же изоб­ра­же­ния. В Fuse та­кое де­ла­ет­ся од­ной строч­кой ко­да: <strong><Blur /></strong>, но за­мут­не­ние боль­ших эле­мен­тов мо­жет пло­хо от­ра­зить­ся на про­из­во­ди­тель­но­сти. По­это­му я ис­поль­зую клас­си­че­ский трюк с про­грамм­ной GPU-об­ра­бот­кой для улуч­ше­ния ско­ро­сти:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// fusecloudscaledblur.ux
&lt;FuseCloud.AlbumArt Width=&#34;20%&#34; Height=&#34;20%&#34;&gt;
    &lt;Blur Radius=&#34;2&#34;/&gt;
    &lt;Scaling Factor=&#34;5&#34; /&gt;
&lt;/FuseCloud.AlbumArt&gt;</pre></div>
<p>Здесь я умень­шаю раз­мер изоб­ра­же­ния до 20% от ори­ги­наль­но­го и за­мут­няю умень­шен­ное изоб­ра­же­ние, за­тем уве­ли­чи­ваю по­лу­чив­ше­е­ся изоб­ра­же­ние до нор­маль­но­го раз­ме­ра.</p>

<p><img src="img/x787658ba2f.jpg.pagespeed.ic.Lr221KUpFB.jpg" alt="Разработка: Кроссплатформенный плеер для SoundCloud® с Fuse" /></p>

<h5 id="ра-бо-та-ем-с-soundcloud-api">Ра­бо­та­ем с SoundCloud API</h5>

<p>Во­об­ще это неслож­ная за­да­ча и в ней нет ни­ка­ких спе­ци­фич­ных для Fuse тех­ник. Я струк­ту­ри­ро­вал обёрт­ку, по­это­му каж­дый за­прос воз­вра­ща­ет promise. Мо­дель при­ло­же­ния бы­ла ис­поль­зо­ва­на как ин­тер­фейс к API че­рез на­бор функ­ций-гет­те­ров, воз­вра­щав­ших promise-ы в Observable. Код ни­же на­гляд­но ил­лю­стри­ру­ет этот под­ход:</p>

<p>Функ­ция, ис­поль­зу­е­мая для по­лу­че­ния ста­ту­са лай­ка для тре­ка, воз­вра­ща­ет promise:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// fusecloudislikingtrackfetch.js
function isLikingTrack(trackId) {
    return Auth.getAccessToken()
        .then(function(token) {
            return FuseCloudGet(&#34;me/favorites/&#34; + trackId, {}, token);
        });
}</pre></div>
<p>Мо­дель пре­вра­ща­ет этот promise в observable, ис­поль­зуя удоб­ную функ­цию (<strong>DelayedObservable</strong>):</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// fusecloudislikingtrackobservable.js
function GetIsLikingTrack(trackId) {
    return DelayedObservable(function(obs) {
        FuseCloud.isLikingTrack(trackId)
            .then(function(result) {
                obs.add(result);
            });
    });
}</pre></div>
<p>Это ре­аль­но удоб­но, учи­ты­вая что воз­вра­щён­ный observable бу­дет за­пол­нен сра­зу при по­лу­че­нии дан­ных. За­тем мы мо­жем сде­лать при­вяз­ку к нему и не бес­по­ко­ить­ся об об­рат­ных вы­зо­вах или об­нов­ле­ни­ях ин­тер­фей­са при­ло­же­ния.</p>

<p>Функ­ция DelayedObservable ра­бо­та­ет как мост меж­ду API, ос­но­ван­ной на promise-ах, и API, ос­но­ван­ной на Observable:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// fuseclouddelayedobservable.js
function DelayedObservable(getter) {
    var ret = Observable();
    getter(ret);
    return ret;
}</pre></div>
<p>Эта функ­ция от­ве­ча­ет за об­нов­ле­ние Observable при за­груз­ке дан­ных.</p>

<h4 id="oauth-2-0">OAuth 2.0</h4>

<p>SoundCloud API поз­во­ля­ет ав­то­ри­зо­вать­ся с по­мо­щью про­то­ко­ла OAuth 2.0. Ис­поль­зуя мо­дуль InterApp, я лег­ко пе­ре­ки­ды­ваю поль­зо­ва­те­ля на ав­то­ри­за­цию с по­мо­щью на­тив­но­го бра­у­зе­ра:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// fusecloudlaunchuri.js
var uri = &#34;https://soundcloud.com/connect?client_id=&#34; + clientId
        + &#34;&amp;display=popup&#34;
        + &#34;&amp;response_type=code&#34;
        + &#34;&amp;redirect_uri=fuse-soundcloud://fuse&#34;;
InterApp.launchUri(uri);</pre></div>
<p>В URL вы­ше пе­ре­да­ёт­ся URI об­рат­но­го вы­зо­ва, ко­то­рый SoundCloud ис­поль­зу­ет для воз­вра­та то­ке­на. Fuse поз­во­ля­ет за­ре­ги­стри­ро­вать свою URI-схе­му в фай­ле про­ек­та:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// fusecloudcustomurischeme.json
&#34;Mobile&#34;:{
    &#34;UriScheme&#34;: &#34;fuse-soundcloud&#34;
}</pre></div>
<p>Та­ким об­ра­зом, SoundCloud API ав­то­ма­ти­че­ски вер­нёт­ся в на­шу про­грам­му, как толь­ко то­кен до­сту­па бу­дет го­тов.</p>

<h4 id="со-зда-ние-крос-сплат-фор-мен-но-го-аудио-пле-е-ра">Со­зда­ние крос­сплат­фор­мен­но­го аудио­пле­е­ра</h4>

<p>Ре­а­ли­за­ция обёрт­ки для на­тив­ных пле­е­ров бы­ла наи­бо­лее ин­те­рес­ной ча­стью про­цес­са. Ча­стич­но из-за то­го, что API для это­го раз­лич­ны у Android и iOS, но та­к­же по при­чине мо­но­лит­ной при­ро­ды ме­диа-пле­е­ров. Я на­чал с ми­ни­маль­но­го на­бо­ра тре­бо­ва­ний.</p>

<p>Наш <strong>StreamingPlayer</strong> дол­жен:</p>

<ul>
<li>Транс­ли­ро­вать аудио по URL</li>
<li>Про­дол­жать иг­рать, ко­гда при­ло­же­ние ухо­дит в фон</li>
<li>Поз­во­лять пе­ре­клю­чать­ся меж­ду тре­ка­ми, по­ка при­ло­же­ние на­хо­дит­ся в фоне (ис­поль­зуя на­тив­ные кон­тро­лы на экране бло­ки­ров­ки)</li>
<li>Отоб­ра­жать об­лож­ку аль­бо­ма на экране бло­ки­ров­ки<br />
<img src="img/x93822d6554.jpg.pagespeed.ic.MDYPBFDT0-.jpg" alt="Разработка: Кроссплатформенный плеер для SoundCloud® с Fuse" /></li>
</ul>

<p>На бу­ма­ге это не ка­жет­ся слиш­ком слож­ной за­да­чей, но на де­ле она ока­за­лась на­сто­я­щим вы­зо­вом.</p>

<p>Пре­жде все­го, под­клю­че­ние к на­тив­но­му аудио­пле­е­ру для про­иг­ры­ва­ния URL бы­ло су­пер­про­стым. API у Android MediaPlayer-а и AVPlayer у iOS пред­ла­га­ют это пря­мо из ко­роб­ки. Мо­ей на­чаль­ной за­дум­кой бы­ло ис­поль­зо­вать ми­ни­маль­ную обёрт­ку во­круг обо­их этих API и про­сто де­лать осталь­ную ра­бо­ту (ти­па управ­ле­ния плей­ли­ста­ми и со­сто­я­ни­ем) в JavaScript. Но огра­ни­че­ние на фо­но­вое вы­пол­не­ние JS на этих плат­фор­мах по­ста­ви­ло крест на этом (од­но из на­ших тре­бо­ва­ний &mdash; воз­мож­ность ис­поль­зо­вать кон­тро­лы на экране бло­ки­ров­ки).</p>

<p>Это озна­ча­ло, что я дол­жен ре­а­ли­зо­вать ра­бо­ту с плей­ли­ста­ми в на­тив­ном ко­де, при этом учи­ты­вая осо­бен­но­сти Android и iOS. К сча­стью, всё ока­за­лось го­раз­до про­ще, так как <a href="https://www.fusetools.com/docs/native-interop/foreign-code">воз­мож­но­сти внеш­не­го ко­да Fuse</a> поз­во­ля­ют вам лег­ко ин­те­гри­ро­вать код на Java и Objective-C в про­ек­ты Fuse. Это очень удоб­но!</p>

<p>Дру­гой ин­те­рес­ной за­да­чей бы­ло по­лу­че­ние те­ку­ще­го со­сто­я­ния пле­е­ра для обо­их ком­по­нен­тов, MediaPlayer и AVPlayer. Оба этих API име­ют раз­ные мо­де­ли со­сто­я­ния и раз­ные пу­ти управ­ле­ния ими, но я на­шёл уни­вер­саль­ный спо­соб.</p>

<p>И, на­ко­нец, ра­бо­та с экра­ном бло­ки­ров­ки. В iOS это крайне про­сто; до­ста­точ­но за­ре­ги­стри­ро­вать несколь­ко си­стем­ных вы­зо­вов. В Android же это не та­кая про­стая за­да­ча. В API, на­чи­ная с уров­ня 21, Android мо­жет по­лу­чать ме­диа-но­ти­фи­ка­ции, ко­то­рые за­ме­ща­ют обыч­ные кон­тро­лы на экране бло­ки­ров­ки. Но нуж­но ко­пать в сто­ро­ну си­сте­мы intent-ов для на­строй­ки ком­му­ни­ка­ции меж­ду но­ти­фи­ка­ци­я­ми и фо­но­вой служ­бой.</p>

<h4 id="воз-мож-но-сти">Воз­мож­но­сти</h4>

<p>В при­ло­же­ние FuseCloud встро­е­ны очень боль­шие воз­мож­но­сти и ме­ха­низ­мы, и так как я люб­лю пе­ре­чис­ле­ния, вот неболь­шой спи­сок фич, за­ло­жен­ных в этой про­грам­ме (и ис­ход­ном ко­де):</p>

<ul>
<li>Аутен­ти­фи­ка­ция в SoundCloud® по про­то­ко­лу OAuth 2.0</li>
<li>Ис­поль­зо­ва­ние па­ке­та InterApp для за­пус­ка url во внеш­нем бра­у­зе­ре и пе­ре­да­ча от­кли­ка по URI</li>
<li>Ав­то­ма­ти­че­ское об­нов­ле­ние некор­рект­ных то­ке­нов</li>
<li>По­лу­че­ние дан­ных по REST API</li>
<li>Лен­та но­во­стей, по­иск тре­ков, из­бран­ное</li>
<li>Воз­мож­ность по­ста­вить лайк и диз­лайк тре­ку</li>
<li>Об­лож­ки тре­ков</li>
<li>Отоб­ра­же­ние ком­мен­та­ри­ев к тре­ку</li>
<li>Раз­ме­ще­ние ком­мен­та­ри­ев</li>
<li>Ста­ти­сти­ка поль­зо­ва­те­ля</li>
<li>Сма­хи­ва­ние вле­во/впра­во для пе­ре­клю­че­ния до­рож­ки</li>
<li>По­тя­ги­ва­ние экра­на для об­нов­ле­ния</li>
<li>Бес­ко­неч­ный спи­сок про­крут­ки</li>
<li>Сма­хи­ва­ние для по­ка­за дей­ствий с эле­мен­том (диз­лайк в из­бран­ном)</li>
<li>Со­хра­не­ние со­сто­я­ния UI с ис­поль­зо­ва­ни­ем Storage API (при­вет­ствен­ная ин­фор­ма­ция по­ка­зы­ва­ет­ся толь­ко один раз при на­ча­ле ра­бо­ты с про­грам­мой)®</li>
<li>HTTP Audio StreamingPlayer для iOS и Android</li>
<li>Транс­ля­ция му­зы­ки из SoundCloud®</li>
<li>На­стра­и­ва­е­мая па­нель пе­ре­мот­ки</li>
<li>Фо­но­вое про­иг­ры­ва­ние</li>
<li>Кон­тро­лы на экране бло­ки­ров­ки в iOS и Android</li>
<li>iOS: сле­ду­ю­щий, преды­ду­щий, иг­рать/па­у­за, пе­ре­мот­ка на экране бло­ки­ров­ки</li>
<li>Об­лож­ка аль­бо­ма на экране бло­ки­ров­ки</li>
<li>Но­ти­фи­ка­ции в Android: сле­ду­ю­щий, преды­ду­щий, иг­рать/па­у­за</li>
<li>По­каз об­лож­ки аль­бо­ма в но­ти­фи­ка­ции и в фоне</li>
<li>Плей­ли­сты</li>
<li>Ав­то­про­иг­ры­ва­ние сле­ду­ю­ще­го при окон­ча­нии тре­ка</li>
</ul>

<h4 id="вы-во-ды-и-за-груз-ки">Вы­во­ды и за­груз­ки</h4>

<p>Бы­ло ре­аль­но класс­но ра­бо­тать над этим про­ек­том. Я необъ­ек­ти­вен, но Fuse ре­аль­но впе­чат­ли­ла ме­ня  &mdash; в ко­то­рый раз.</p>

<p>И <a href="https://www.fusetools.com/docs/native-interop/foreign-code">ме­ха­низ­мы внеш­не­го ко­да</a> Fuse ока­за­лись дей­стви­тель­но хо­ро­шим спо­со­бом со­зда­ния на­тив­ных ком­по­нен­тов. Они поз­во­ля­ют ис­поль­зо­вать до­ку­мен­та­цию к API каж­дой плат­фор­мы на сво­ём язы­ке, где это воз­мож­но, и без обёр­ток на JavaScript.</p>

<p>Вы мо­же­те ска­чать при­ло­же­ние <strong>FuseCloud</strong> для Android и iOS в <a href="https://itunes.apple.com/us/app/fusecloud/id1173516856?mt=8">Apple App Store</a>, в <a href="https://play.google.com/store/apps/details?id=com.fuse.fusecloud&amp;hl=en">Google Play</a>, и <a href="https://github.com/fusetools/FuseCloud">ис­ход­ный код на Github</a>.</p>

<blockquote>
<p>Вни­ма­ние: ещё раз о со­зда­нии &ldquo;ре­аль­ной&rdquo; про­грам­мы (с на­тив­ны­ми ком­по­нен­та­ми и ин­те­гра­ци­я­ми с бе­кен­дом) &mdash; вы по­чти на­вер­ня­ка столк­не­тесь с неко­то­ры­ми труд­но­стя­ми. Мы по­сто­ян­но улуч­ша­ем на­шу до­ку­мен­та­цию, но ес­ли всё-та­ки встре­ти­те та­кой слу­чай, <a href="https://www.fusetools.com/community">дай­те знать об этом нам и со­об­ще­ству</a>, и мы с ра­до­стью вам по­мо­жем :)<br />
<br />
<strong>Узнать боль­ше о Fuse</strong> мож­но по­смот­рев <a href="http://fusetools.com/examples">по­сто­ян­но рас­ту­щий спи­сок при­ме­ров</a> (с ис­ход­ным ко­дом, ко­неч­но), <a href="http://fusetools.com/community">всту­пай­те в на­ше со­об­ще­ство</a> (у нас есть класс­ный фо­рум и груп­па в Slack) или под­пи­сы­вай­тесь на нас в <a href="https://twitter.com/fusetools">Twitter</a> или <a href="https://facebook.com/fusetools">Facebook</a>.</p>
</blockquote>

<p>Ав­тор ори­ги­на­ла <a href="https://blog.prototypr.io/i-made-a-cross-platform-soundcloud-player-with-fuse-9fb1e62b7db1#.uelvgeooc">Kristian Hasselknippe, Software Engineer at Fuse</a></p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Выбор технологии мобильной разработки в 2017 году</turbo:topic>
      <link>https://fokusov.com/posts/tehnologii-mobilnoj-razrabotki-v-2017-godu/</link>
      <pubDate>Sat, 28 Jan 2017 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ 

<p><img src="img/x2b61e64957.png.pagespeed.ic.FcyGgJKAQF.jpg" alt="Разработка: Технологии мобильной разработки в 2017 году" /><br />
Од­на­ж­ды в по­не­дель­ник утром к нам при­шёл кли­ент, ко­то­ро­му необ­хо­ди­мо бы­ло раз­ра­бо­тать муль­ти­плат­фор­мен­ное мо­биль­ное при­ло­же­ние для бан­кин­га. У него был про­то­тип со все­ми экра­на­ми, это и ста­ло на­шим тех­за­да­ни­ем. «Окей, кру­то». Те­перь мы долж­ны во­пло­тить в жизнь эту идею, ко­то­рая бы­ла раз­ме­ром при­мер­но в 50 экра­нов. И у нас есть все­го три ме­ся­ца. Вау.</p>

<p>С че­го на­чать? Ка­кую тех­но­ло­гию ис­поль­зо­вать? Ту, ко­то­рая уже усто­я­лась на рын­ке или луч­ше сде­лать став­ку на со­вре­мен­ный стек? Эти во­про­сы не пе­ре­ста­ва­ли зву­чать в на­ших го­ло­вах.</p>

<p>Мы по­ду­ма­ли, что сто­ит по­про­бо­вать каж­дое ре­ше­ние, пе­ред тем, как вы­брать од­но. За­тем мы на­ча­ли ана­ли­зи­ро­вать все ви­ды воз­мож­ных ре­ше­ний в на­деж­де най­ти ре­ше­ние на­шей про­бле­мы. Ох, стоп&hellip; Это бы­ла пло­хая идея! Этот ана­лиз при­вёл нас к невоз­мож­но­сти сде­лать вы­бор во­об­ще. И этот пост как раз об этом. ( Мы как раз на­ча­ли раз­ра­бот­ку по­сле на­пи­са­ния этой ста­тьи %) )</p>

<p><em>(В про­то­ти­пе бы­ло бо­лее 50 экра­нов; тре­бо­ва­лись та­кие ве­щи, как ка­ме­ра, NFC, сер­ви­сы ло­ка­ции, Push но­ти­фи­ка­ции и т.д.)</em></p>

<p><img src="img/xc287db2b58.jpg.pagespeed.ic.9pDDNarkJR.jpg" alt="Разработка: Технологии мобильной разработки в 2017 году" /></p>

<h4 id="ка-ко-ва-на-ша-цель">Ка­ко­ва на­ша цель?</h4>

<p>В со­вер­шен­стве во­пло­тить идею в мо­биль­ное при­ло­же­ние, ко­то­рое пол­но­стью удо­вле­тво­рит на­ше­го кли­ен­та, поль­зо­ва­те­лей и НАС ( а нас очень слож­но чем-ли­бо удо­вле­тво­рить :P )</p>

<p>Мы счи­та­ем, что всё, над чем мы ра­бо­та­ем, долж­но при­но­сить удо­вле­тво­ре­ние. Мы ни­ко­гда не хо­те­ли бы и не бу­дем де­лать что-то, чем мы не смо­жем впо­след­ствии гор­дить­ся.</p>

<h4 id="обой-дём-де-ре-во-воз-мож-ных-ре-ше-ний">Обой­дём де­ре­во воз­мож­ных ре­ше­ний&hellip;</h4>

<p><img src="img/xa733e50850.jpg.pagespeed.ic.4vx87mdx6E.jpg" alt="Разработка: Технологии мобильной разработки в 2017 году" /></p>

<p>Native Apps: При­ло­же­ния, раз­ра­бо­тан­ные на на­тив­ных язы­ках, та­ких как Java, Objective-C или Swift.<br />
Hybrid Apps: При­ло­же­ния, раз­ра­бо­тан­ные с при­ме­не­ни­ем веб-тех­но­ло­гий, ко­то­рые рас­по­ла­га­ют­ся внут­ри на­тив­но­го кон­тей­не­ра, что да­ёт до­ступ че­рез API к на­тив­ным пла­ги­нам<br />
Almost Native Apps: При­ло­же­ния, вы­пол­ня­е­мые в вир­ту­аль­ной ма­шине <a href="https://tehnojam.pro/tag/javascript/">JavaScript</a>, но ис­поль­зу­ю­щие род­ные для плат­фор­мы ком­по­нен­ты поль­зо­ва­тель­ско­го ин­тер­фей­са</p>

<h4 id="на-тив-ные-при-ло-же-ния">На­тив­ные при­ло­же­ния</h4>

<p>Ес­ли вы уже до­шли до этой ча­сти, то долж­ны по­ни­мать, о чём мы го­во­рим. ДА! ЭТО КОШ­МАР ДЛЯ РАЗ­РА­БОТ­ЧИ­КА. Со­зда­ние оди­на­ко­во­го при­ло­же­ния на раз­ных язы­ках &mdash; это как про­ле­тать че­рез пре­ис­под­нюю раз за ра­зом. Вы толь­ко пред­ставь­те, как тя­же­ло бу­дет ис­прав­лять, до­ра­ба­ты­вать и об­нов­лять раз­ные ко­до­вые ба­зы.</p>

<p>Ко­неч­но, бу­дет су­пер-ме­га-кру­то, ес­ли мы бу­дем раз­ра­ба­ты­вать и под­дер­жи­вать чи­сто на­тив­ные при­ло­же­ния. Но мы ве­рим, что это не сто­ит уси­лий в этом про­ек­те и про­сто невоз­мож­но уло­жить­ся в то вре­мя, что у нас есть.</p>

<h4 id="по-го-ди-те-а-как-же-xamarin">По­го­ди­те&hellip; а как же Xamarin</h4>

<p><img src="img/xc0d582db86.png.pagespeed.ic.PXJLnGmwIE.png" alt="Разработка: Технологии мобильной разработки в 2017 году" /><br />
Xamarin, под­дер­жи­ва­е­мый ком­па­ни­ей Microsoft, предо­став­ля­ет воз­мож­ность со­хра­нять до 75% об­щей ко­до­вой ба­зы, при этом раз­ра­ба­ты­вая поль­зо­ва­тель­ский ин­тер­фейс от­дель­но для каж­дой плат­фор­мы. <strong>Это про­сто ВАУ, не так ли?</strong></p>

<p>На­тив­ный поль­зо­ва­тель­ский ин­тер­фейс, на­тив­ный до­ступ к API, на­тив­ная про­из­во­ди­тель­ность. И это аб­со­лют­но бес­плат­но!<br />
Да, Xamarin был бы ве­ли­ко­леп­ным ва­ри­ан­том, но здесь всё не так про­сто. Есть несколь­ко ми­ну­сов, ко­то­рые за­став­ля­ют нас взгля­нуть и на дру­гие ва­ри­ан­ты:</p>

<ul>
<li>Име­ю­щи­е­ся сро­ки (у нас есть толь­ко 3 ме­ся­ца)<br />
&ndash; Вы­со­кие из­держ­ки раз­ра­бот­ки<br />
&ndash; Раз­ра­бот­ка и те­сти­ро­ва­ние UI под каж­дую плат­фор­му от­ни­ма­ет мно­го вре­ме­ни<br />
&ndash; Неко­то­рые по­же­ла­ния кли­ен­та мо­гут за­ста­вить нас пи­сать биб­лио­те­ки, а мы хо­те­ли бы из­бе­жать это­го</li>
<li>Ре­ше­ние, ко­то­рое мы пред­ла­га­ем, нуж­да­ет­ся в быст­рой раз­ра­бот­ке</li>
<li>Со­об­ще­ство во­круг Xamarin не та­кое боль­шое, как хо­те­лось бы</li>
<li>На­ша ко­ман­да не лю­бит раз­ра­бот­ку на язы­ке c# :(<br />
Но до­ста­точ­но раз­го­во­ров. Мы про­сто пе­рей­дём к дру­го­му ва­ри­ан­ту, так как этот не под­хо­дит нам по вре­ме­ни на раз­ра­бот­ку.</li>
</ul>

<p><img src="img/xf5a565ae75.jpg.pagespeed.ic.dIg3Wb7QOz.jpg" alt="Разработка: Технологии мобильной разработки в 2017 году" /></p>

<p><em>(Но ес­ли у вас есть до­ста­точ­но ре­сур­сов и вре­ме­ни, то Xamarin бу­дет от­лич­ным ва­ри­ан­том)</em></p>

<h4 id="по-го-во-рим-о-ги-бри-дах">По­го­во­рим о ги­бри­дах</h4>

<p>Ги­брид­ные при­ло­же­ния &mdash; в та­ких ком­по­нен­ты ин­тер­фей­са рас­по­ло­же­ны в кон­тей­не­ре с web-view, то есть фак­ти­че­ски в бра­у­зе­ре. И здесь пер­вая за­пад­ня: web-view со­сто­ит из DOM и это при­во­дит к су­ще­ствен­но­му за­мед­ле­нию при­ло­же­ний в срав­не­нии с на­тив­ны­ми.</p>

<p>Окей. Мы зна­ем, что это бу­дет мед­лен­нее, но по­смот­рим, чем этот ва­ри­ант си­лён.</p>

<ul>
<li>Раз­ра­бот­ка со­вре­мен­ных веб-при­ло­же­ний (Progressive App)</li>
<li>До­ступ­ны по­чти все на­тив­ные функ­ции че­рез раз­лич­ные обёрт­ки</li>
<li>Веб тех­но­ло­гии (HTML5, CSS, и JS нам очень близ­ки)</li>
<li>Очень про­стая под­держ­ка при­ло­же­ний (как ми­ни­мум, в срав­не­нии с дру­ги­ми ва­ри­ан­та­ми)</li>
<li>По­тря­са­ю­щая под­держ­ка со­об­ще­ства</li>

<li><p>мно­гое дру­гое&hellip;<br />
Нам нуж­но об­ду­мать, на ка­кие ком­про­ми­сы мы мо­жем пой­ти с учё­том плю­сов/ми­ну­сов&hellip;<br />
<strong>По­смот­рим на име­ю­щи­е­ся здесь ва­ри­ан­ты:</strong></p></li>

<li><p><a href="http://ionicframework.com/docs/guide/preface.html">Ionic 1.3 с angularJS</a><br />
&ndash; Пре­вос­ход­ная под­держ­ка со­об­ще­ства<br />
&ndash; Angularjs &mdash; наш дав­ний друг</p></li>

<li><p><a href="https://framework7.io/">Framework 7</a><br />
-Впе­чат­ля­ю­щий и от­лич­но до­ку­мен­ти­ро­ван­ный, но сла­бая под­держ­ка со­об­ще­ства<br />
-Кри­вая обу­че­ния до­воль­но кру­та, так как этот фрейм­ворк са­мо­до­ста­то­чен</p></li>

<li><p>Sencha UI, <a href="http://www.appcelerator.com/">Appcelerator</a><br />
-Кру­тая кри­вая обу­че­ния<br />
-Мень­шая под­держ­ка со­об­ще­ства<br />
-Не бес­плат­ный&hellip;</p></li>

<li><p>Со­зда­ние соб­ствен­но­го ком­по­нен­та<br />
-Очень мно­го­обе­ща­ю­ще. Но сто­ит ли оно уси­лий?</p></li>

<li><p><a href="http://ionic.io/2">Ionic 2 с angular 2</a><br />
-Хмм&hellip; Я ду­маю, что это по­дой­дёт&hellip; но&hellip; По­го­ди­те&hellip; <a href="https://tehnojam.pro/tag/ionic/">Ionic</a> 2 всё ещё в бе­те</p></li>
</ul>

<h4 id="ionic-1">IONIC 1</h4>

<p>По­ка мы об­суж­да­ли толь­ко ва­ри­ан­ты раз­ра­бот­ки ги­брид­ных при­ло­же­ний. Под­держ­ка со­об­ще­ства у ionic и са­мо­го angularJS очень впе­чат­ли­ла нас. Спер­ва мы взя­ли ionic 1.3.</p>

<ul>
<li>Хо­ро­шая до­ку­мен­та­ция</li>
<li>Фрейм­ворк до­ста­точ­но зре­лый</li>
<li>Мы от­лич­но зна­ем этот стек тех­но­ло­гий</li>
<li>Очень лёг­кое пла­ни­ро­ва­ние раз­ра­бот­ки</li>
<li>Мы в прин­ци­пе зна­ем каж­дый под­вод­ный ка­мень в этом про­ек­те<br />
На­вер­ное, нам сто­ит взять без лиш­них раз­ду­мий ionic 1.3&hellip;</li>
</ul>

<p><img src="img/x8d3338f446.jpg.pagespeed.ic.hXQTgHKUm1.jpg" alt="Разработка: Технологии мобильной разработки в 2017 году" /></p>

<p>Ionic 1.3 по­стро­ен на angularJS. У нас есть ужас­ный опыт мо­биль­ной раз­ра­бот­ки на angularJS. Учи­ты­вая на­ши про­то­ти­пы и слож­ность бу­ду­ще­го при­ло­же­ния, мы уже мог­ли пред­ска­зать недо­ста­ток про­из­во­ди­тель­но­сти, ко­то­рый бу­дет у бу­ду­щей про­грам­мы.</p>

<h4 id="ionic-2">IONIC 2</h4>

<p>Но­вая ар­хи­тек­ту­ра недав­но вы­шед­ше­го <a href="https://tehnojam.pro/tag/angular/">Angular</a> 2 да­ва­ла нам на­деж­ду на уве­ли­че­ние про­из­во­ди­тель­но­сти. Ionic 2, с дру­гой сто­ро­ны, предо­став­лял го­раз­до луч­ший ин­тер­фейс и да­вал ощу­ще­ние на­тив­но­го при­ло­же­ния, а это про­сто фан­та­сти­ка!</p>

<p>Пе­ред тем, как оста­но­вить­ся на Ionic 2, мы ви­дим несколь­ко про­блем:</p>

<ul>
<li>Всё-та­ки это ги­брид­ное при­ло­же­ние и оно не по­ка­жет су­пер-про­из­во­ди­тель­но­сти</li>
<li>Ionic 2 всё ещё в со­сто­я­нии бе­ты</li>

<li><p>Angular 2 это со­вер­шен­но но­вый стек, ко­то­рый нам пред­сто­ит осво­ить<br />
Так по­че­му же нам не хо­чет­ся рас­ста­вать­ся с ionic 2?</p></li>

<li><p>Ionic 2 недав­но (при­мер­но 20/12/2016) за­мо­ро­зил свой API, что озна­ча­ет для нас от­сут­ствие круп­ных про­блем с фрейм­вор­ком в бли­жай­шее вре­мя.</p></li>

<li><p>Це­ле­вые смарт­фо­ны для на­ше­го про­ек­та бу­дут иметь хо­ро­шую про­из­во­ди­тель­ность (в иде­а­ле, Galaxy S3 и бо­лее позд­ние вер­сии).<br />
И в этом кон­тек­сте, бу­дет ли про­из­во­ди­тель­ность про­бле­мой во­об­ще? Мы так не счи­та­ем. И ду­ма­ем, что хо­ро­шее со­об­ще­ство не ста­нет под­дер­жи­вать мо­биль­ный фрейм­ворк, ес­ли он не со­от­вет­ству­ет ожи­да­е­мой про­из­во­ди­тель­но­сти<br />
Так, мы сде­ла­ли став­ку на со­об­ще­ство за angular 2 и ionic 2, ко­то­рые ста­нут ве­ли­ко­леп­ным ре­ше­ни­ем на­шей за­да­чи.</p></li>
</ul>

<p>И всё на­чи­на­ет­ся&hellip; на­чи­на­ет­ся с angular 2</p>

<p><img src="img/x2016a26332.jpg.pagespeed.ic.a8xBuIrF-C.jpg" alt="Разработка: Технологии мобильной разработки в 2017 году" /></p>

<p>Мы на­ча­ли ис­сле­до­ва­ние angular 2 и Ionic 2 с со­зда­ния про­сто­го про­то­ти­па. В про­цес­се со­зда­ния про­то­ти­па мы сфо­ку­си­ро­ва­лись на пе­ре­осмыс­ле­нии UX-ча­сти при­ло­же­ния и по­ка­зы­ва­ли скет­чи ин­тер­фей­са в sketch.io од­но­вре­мен­но для на­ше­го кли­ен­та и раз­ра­бот­чи­ков (Вре­ме­ни на про­ект бы­ло ма­ло, по­это­му нам нуж­но бы­ло из­бе­жать ненуж­ных кор­рек­ти­ро­вок про­ек­та от ко­го-ли­бо).</p>

<h4 id="по-чти-на-тив-ные-ре-ше-ния">По­чти на­тив­ные ре­ше­ния</h4>

<p>По­ка мы про­дол­жа­ли изу­чать Ionic 2 и не сде­ла­ли окон­ча­тель­ный вы­бор, мы не пе­ре­ста­ва­ли ду­мать и о дру­гом ва­ри­ан­те: По­чти-на­тив­ных при­ло­же­ни­ях.<br />
Это React Native и Native Script&hellip;</p>

<p>Оба фрейм­вор­ка гор­дят­ся сво­ей на­тив­ной про­из­во­ди­тель­но­стью. Они ис­поль­зу­ют JavaScript для ло­ги­ки, то­гда как UI от­ри­со­вы­ва­ет­ся на­тив­ны­ми ком­по­нен­та­ми.</p>

<p>Зву­чит очень мно­го­обе­ща­ю­ще!</p>

<ul>
<li>Мень­ше вре­ме­ни на раз­ра­бот­ку</li>
<li>Зна­ко­мые тех­но­ло­гии (ну&hellip; по­чти)</li>
<li>Рас­ту­щее со­об­ще­ство</li>
<li>Про­из­во­ди­тель­ность<br />
<img src="img/xaa9bbcf669.jpg.pagespeed.ic.bWZuYKgn6I.jpg" alt="Разработка: Технологии мобильной разработки в 2017 году" /></li>
</ul>

<p>Очень тя­же­ло сде­лать вы­бор меж­ду React Native и Native Script. Это в кон­це кон­цов окон­чит­ся бит­вой меж­ду Angular 2 про­тив React JS.</p>

<p>Мы про­ана­ли­зи­ро­ва­ли до­ступ­ные ком­по­нен­ты и биб­лио­те­ки, необ­хо­ди­мые на­ше­му при­ло­же­нию.</p>

<h4 id="на-ши-опа-се-ния">На­ши опа­се­ния</h4>

<ul>
<li>Необ­хо­ди­мые пла­ги­ны:<br />
&ndash; Ска­нер штрих­ко­дов<br />
&ndash; NFC<br />
&ndash; Card.io<br />
&ndash; Push-но­ти­фи­ка­ции<br />
&ndash; Ска­нер от­пе­чат­ков паль­ца<br />
&ndash; API ка­ме­ры<br />
&ndash; Го­ло­со­вой API<br />
&ndash; Google кар­ты<br />
&ndash; Bluetooth</li>
<li>Воз­мож­ность ка­сто­ми­за­ции сти­ля при­ло­же­ния</li>

<li><p>Ста­биль­ность пред­ла­га­е­мых API<br />
(мы не хо­тим, что­бы при­ло­же­ние сло­ма­лось в бу­ду­щих вер­си­ях фрейм­вор­ка)<br />
С точ­ки зре­ния на­ших опа­се­ний, оба фрейм­вор­ка иде­аль­ны.</p></li>

<li><p>+1 за React Native из-за име­ю­ще­го­ся у него пла­ги­на к Card.io, то­гда как у Native Script по­ка не бы­ло та­ко­го.</p></li>

<li><p>+1 за Native Script за име­ю­щи­е­ся воз­мож­но­сти сти­ли­за­ции при­ло­же­ния.<br />
Сно­ва ни­чья!</p></li>
</ul>

<h4 id="окон-ча-тель-ный-вер-дикт">Окон­ча­тель­ный вер­дикт</h4>

<p><img src="img/xce3bdc6d83.jpg.pagespeed.ic.0IJiFYFfe3.jpg" alt="Разработка: Технологии мобильной разработки в 2017 году" /></p>

<p>Что нам вы­брать&hellip;? Ionic 2? React Native? Или Native Script?</p>

<p>И мы вы­бра­ли Ionic 2&hellip; Ба­бах!</p>

<p>Слиш­ком тя­же­ло вы­брать луч­ше­го из все­го пе­ре­чис­лен­но­го. Всё, что мы мог­ли, это вы­брать са­мое удоб­ное ре­ше­ние для на­ше­го про­ек­та (По край­ней ме­ре, мы на­де­ем­ся на это).</p>

<h4 id="но-по-че-му-ionic-2">Но по­че­му Ionic 2?</h4>

<p>Вот несколь­ко при­чин&hellip;</p>

<ul>
<li>У Ionic 2 наи­боль­шее со­об­ще­ство</li>
<li>Все нуж­ные нам пла­ги­ны уже есть в нём</li>
<li>Мы та­к­же мо­жем со­брать windows-при­ло­же­ние на этой ба­зе</li>
<li>Нам уже из­ве­стен этот стек и ни­че­го не нуж­но изу­чать</li>
<li>Typescript &mdash; Луч­ший ин­стру­мент!</li>
<li>Боль­шой +1 за ка­сто­ми­за­цию и сти­ли</li>
</ul>

<h4 id="это-всё">Это всё?</h4>

<p><img src="img/x5782203d0d.jpg.pagespeed.ic.dnyyEVj9BQ.jpg" alt="Разработка: Технологии мобильной разработки в 2017 году" /></p>

<p>Од­на из глав­ных при­чин вы­бо­ра Ionic 2 &mdash; это Angular 2! Вы удив­ле­ны? Всё про­сто&hellip;</p>

<p><em>В бу­ду­щем, ко­гда кли­ент ре­шит пе­рей­ти на на­тив­ные при­ло­же­ния, Native Script ста­нет на­шим спа­се­ни­ем. Мы уве­ре­ны, что Native Script к это­му вре­ме­ни уже бу­дет иметь под­держ­ку windows-при­ло­же­ний. И нам не нуж­но бу­дет пе­ре­пи­сы­вать всю ло­ги­ку за­но­во! Нам нуж­но бу­дет про­сто со­здать недо­ста­ю­щие ком­по­нен­ты ин­тер­фей­са и пе­ре­со­брать при­ло­же­ние.</em></p>

<p><strong>Вы не ду­ма­е­те, что это офи­ген­ный план?</strong></p>

<h4 id="за-клю-че-ние">За­клю­че­ние</h4>

<p>Два клю­че­вых мо­мен­та, на ко­то­рых мы сде­ла­ли став­ку</p>

<ol>
<li>Здо­ро­вое со­об­ще­ство это ключ к успе­ху</li>
<li>Angular 2 и Typescript &mdash; фан­та­сти­че­ский ду­эт</li>
</ol>

<h4 id="пре-ду-пре-жде-ние">Пре­ду­пре­жде­ние</h4>

<p>Эта ис­то­рия по­яви­лась в на­ших боль­ных го­ло­вах, по­ка мы ис­ка­ли на­ше ре­ше­ние. Будь­те го­то­вы уди­вить­ся :P</p>

<p><a href="https://cabbageapps.com/mobile-app-development-landscape/">Ори­ги­нал ста­тьи</a></p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Создание анимированной кнопки &#34;Поделиться&#34; в NativeScript &#43; Angular</turbo:topic>
      <link>https://fokusov.com/posts/sozdanie-animirovannoj-knopki-podelitsja-v-nativescript/</link>
      <pubDate>Thu, 26 Jan 2017 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ 

<p><img src="img/xa50e2d15f9.png.pagespeed.ic.WH4jP8y-gH.png" alt="Разработка: main view" title="main view" /></p>

<p>Се­год­ня я по­ка­жу вам как со­зда­вать ани­ми­ро­ван­ную кноп­ку «По­де­лить­ся» в NativeScript и Angular. При на­жа­тии этой кноп­ки бу­дут по­ка­за­ны ма­лень­кие кноп­ки соц­се­тей по кру­гу от глав­ной.</p>

<p>Ис­ход­ный код при­ме­ра вы мо­же­те уви­деть на <a href="https://github.com/bdauria/tns-animated-social-share-button">Github</a>.</p>

<p>Итак, при­сту­пим!</p>

<h4 id="уста-нов-ка">Уста­нов­ка</h4>

<p>Со­зда­дим про­ект, ис­поль­зуя па­ра­метр &ndash;ng для со­зда­ния при­ло­же­ния angular:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">tns create --ng tns-animated-social-button</pre></div>
<p>В на­шем при­ло­же­нии бу­дет ис­поль­зо­вать­ся пла­гин ng2-fonticon от Nathan Walker для вы­во­да ико­нок на кноп­ках. Уста­но­ви­те его по ин­струк­ции на <a href="https://github.com/NathanWalker/nativescript-ng2-fonticon">этой стра­ни­це</a>.<br />
Та­к­же мы ис­поль­зу­ем па­кет <a href="https://lodash.com/">lodash</a>. Уста­но­вим его:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">npm install --save lodash
npm install --save @types/lodash</pre></div>
<p>Те­перь при­сту­пим к на­ше­му ко­ду.</p>

<h4 id="со-зда-ние-socialsharebuttoncomponent">Со­зда­ние SocialShareButtonComponent</h4>

<p>Яд­ро на­ше­го при­ло­же­ния бу­дет опи­са­но в ком­по­нен­те SocialShareButtonComponent. В шаб­лоне бу­дут глав­ная кноп­ка и несколь­ко кно­пок со­ци­аль­ных се­тей.<br />
При на­жа­тии на глав­ную кноп­ку вы­ез­жа­ют ма­лень­кие кноп­ки, а при по­втор­ном на­жа­тии они воз­вра­ща­ют­ся об­рат­но. Для кно­пок мы ис­поль­зу­ем икон­ку «круг» из font awesome. Ико­ноч­ные шриф­ты очень хо­ро­ши тем, что они оди­на­ко­во вы­гля­дят на лю­бом экране и раз­ре­ше­нии. При этом нуж­но пом­нить, что их раз­мер кон­тро­ли­ру­ет­ся па­ра­мет­ром font-size. Для то­го, что­бы сде­лать необ­хо­ди­мый раз­мер ком­по­нен­та, мы долж­ны вы­пол­нить неко­то­рые рас­чё­ты &mdash; это из-за то­го, что не все икон­ки в шриф­те име­ют оди­на­ко­вый раз­мер.<br />
На вход мы бу­дем при­ни­мать мас­сив на­име­но­ва­ний для ико­нок. И ис­поль­зо­вать его для со­зда­ния со­от­вет­ству­ю­щих кно­пок. На­име­но­ва­ния возь­мём из <a href="http://fontawesome.io/icons/">спис­ка ико­нок font awesome</a>. Те­перь, зная всё это, да­вай­те со­зда­дим ком­по­нент в но­вой пап­ке <strong>social-share-button</strong>:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/social-share-button/social-share-button.component.html

import {
  Component,
  Input
} from &#39;@angular/core&#39;;
import { TNSFontIconModule } from &#39;nativescript-ng2-fonticon&#39;;

@Component({
  selector: &#39;social-share-button&#39;,
  templateUrl: &#39;social-share-button/social-share-button.component.html&#39;,
  styleUrls: [&#39;social-share-button/social-share-button.component.css&#39;]
})
export class SocialShareButtonComponent {
  @Input(&#39;size&#39;) size = 75;
  @Input(&#39;shareIcons&#39;) shareIcons: string[];

  public get mainIconSize(): number {
    return this.size * 0.45;
  }

  public get shareButtonSize(): number {
    return this.size * 0.55;
  }

  public get shareIconSize(): number {
    return this.shareButtonSize * 0.5;
  }

  public get viewHeight(): number {
    return this.size + this.shareButtonSize * 1.2;
  }

  public get viewWidth(): number {
    return this.size + this.shareButtonSize * 2.2;
  }

  constructor(private fonticon: TNSFontIconModule) {}
}</pre></div>
<p>В пе­ре­мен­ной <strong>size</strong> мы бу­дем хра­нить расчи­тан­ный раз­мер под раз­ные раз­ре­ше­ния, уста­но­вим по-умол­ча­нию его в <strong>75</strong>. Она бу­дет от­ве­чать за па­ра­метр <strong>font-size</strong> глав­ной кноп­ки. Пе­ре­мен­ная <strong>mainIconSize</strong> это раз­мер икон­ки в глав­ной кноп­ке. Пе­ре­мен­ная <strong>shareButtonSize</strong> от­ве­ча­ет за раз­мер дру­гих кно­пок, а <strong>shareIconSize</strong>, за раз­мер икон­ки в них. Свой­ства <strong>viewHeight</strong> и <strong>viewWidth</strong> от­ве­ча­ют за внеш­ние раз­ме­ры все­го пред­став­ле­ния. Нам нуж­но до­ста­точ­но ме­ста для отоб­ра­же­ния глав­ной кноп­ки, а та­к­же всех осталь­ных ма­лых кно­пок. У нас бу­дет мак­си­мум од­на кноп­ка ря­дом с глав­ной, по­это­му вы­со­та ни­ко­гда не пре­вы­сит size + shareButtonSize. Что ка­са­ет­ся ши­ри­ны, у нас бу­дет по од­ной кноп­ке с каж­дой сто­ро­ны, а в ито­ге: size + shareButtonSize x 2. Мы ис­поль­зу­ем ко­эф­фи­ци­ен­ты в том чис­ле для то­го, что­бы бы­ло немно­го до­пол­ни­тель­но­го про­стран­ства.</p>

<p>Со­зда­дим та­кой шаб­лон:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app/component/social-share-button/social-share-button.component.html --&gt;

&lt;GridLayout rows=&#34;auto&#34;
  [style.width]=&#34;viewWidth&#34;
  [style.height]=&#34;viewHeight&#34;&gt;
  &lt;GridLayout #shareButton
    [style.width]=&#34;shareButtonSize&#34;
    *ngFor=&#34;let shareIcon of shareIcons&#34;&gt;
    &lt;Label
      [style.font-size]=&#34;shareButtonSize&#34;
      class=&#34;fa button&#34;
      [text]=&#34;&#39;fa-circle&#39; | fonticon&#34;&gt;
    &lt;/Label&gt;
    &lt;Label [style.font-size]=&#34;shareIconSize&#34;
      class=&#34;fa share-icon&#34;
      [text]=&#34;&#39;fa-&#39; + shareIcon | fonticon&#34;&gt;&lt;/Label&gt;
  &lt;/GridLayout&gt;
  &lt;GridLayout
    (tap)=&#34;onMainButtonTap()&#34;
    [style.width]=&#34;size&#34;&gt;
    &lt;Label #mainButton
      [style.font-size]=&#34;size&#34;
      class=&#34;fa button&#34;
      [text]=&#34;&#39;fa-circle&#39; | fonticon&#34;&gt;&lt;/Label&gt;
    &lt;Label [style.font-size]=&#34;mainIconSize&#34;
      class=&#34;fa share-icon&#34;
      [text]=&#34;&#39;fa-share-alt&#39; | fonticon&#34;&gt;&lt;/Label&gt;
  &lt;/GridLayout&gt;
&lt;/GridLayout&gt;</pre></div>
<p>Кноп­ки по­ме­ща­ют­ся в GridLayout та­ким об­ра­зом, что­бы икон­ки на­хо­ди­лись по­верх кру­гов. Всё со­дер­жи­мое в свою оче­редь, по­ме­ща­ет­ся в GridLayout, к ко­то­ро­му мы ди­на­ми­че­ски при­ме­ни­ли та­кие свой­ства, как вы­со­та и ши­ри­на.<br />
Для со­зда­ния кно­пок соц­се­тей мы про­хо­дим в цик­ле по мас­си­ву пе­ре­дан­ных ико­нок. Тек­стом икон­ки бу­дет кон­ка­те­на­ция &lsquo;fa-&rsquo; и зна­че­ния <strong>shareIcon</strong>.<br />
За­тем со­зда­дим со­от­вет­ству­ю­щую таб­ли­цу сти­лей:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">/* app/social-share-button/social-share-button.component.css */

GridLayout {
  text-align: center;
  vertical-align: center;
}

Label.button {
  color: #000;
}

Label.share-icon {
  color: #FFF;
  vertical-align: center;
}</pre></div>
<p>Здесь мы все­го лишь удо­сто­ве­рим­ся, что всё со­дер­жи­мое GridLayout от­цен­три­ро­ва­но и за­да­дим кое-ка­кие цве­та. Та­к­же сде­ла­ем, что­бы икон­ки бы­ли от­цен­три­ро­ва­ны по вер­ти­ка­ли внут­ри кноп­ки.</p>

<p>Пе­ред тем, как пе­рей­ти к ре­а­ли­за­ции, вы­ве­дем ре­зуль­тат в AppComponent. Сна­ча­ла до­ба­вим Component в спи­сок де­кла­ра­ций AppModule:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/app.module.ts

import { NgModule, NO_ERRORS_SCHEMA } from &#34;@angular/core&#34;;
import { NativeScriptModule } from &#34;nativescript-angular/platform&#34;;
import { SocialShareButtonComponent } from &#39;./social-share-button/social-share-button.component&#39;;
import { TNSFontIconModule } from &#39;nativescript-ng2-fonticon&#39;;
import { AppComponent } from &#34;./app.component&#34;;

@NgModule({
    declarations: [
      AppComponent,
      SocialShareButtonComponent
    ],
    bootstrap: [AppComponent],
    imports: [
      NativeScriptModule,
      TNSFontIconModule.forRoot({
        &#39;fa&#39;: &#39;font-awesome.css&#39;
      })
    ],
    schemas: [NO_ERRORS_SCHEMA]
})
export class AppModule { }</pre></div>
<p>За­тем от­кро­ем AppComponent и немно­го при­че­шем код:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/app.component.ts

import { Component } from &#34;@angular/core&#34;;

@Component({
  selector: &#34;my-app&#34;,
  templateUrl: &#34;app.component.html&#34;,
  styleUrls: [&#39;app.component.css&#39;]
})
export class AppComponent {
}</pre></div>
<p>Со­здай­те шаб­лон app.​com​pone​nt.​html и вставь­те в него сле­ду­ю­щее:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app/app.component.html --&gt;

&lt;StackLayout class=&#34;container&#34;&gt;
  &lt;social-share-button
    [shareIcons]=&#34;[&#39;facebook&#39;, &#39;twitter&#39;, &#39;github&#39;, &#39;linkedin&#39;, &#39;tumbler&#39;]&#34;&gt;&lt;/social-share-button&gt;
&lt;/StackLayout&gt;</pre></div>
<p>И файл CSS:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">/* app/app.component.css */

StackLayout.container {
  width: 100%;
  vertical-align: center;
  margin-left: auto;
  margin-right: auto;
}</pre></div>
<p>В ре­зуль­та­те долж­но по­лу­чить­ся та­кое:<br />
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALYAAACYCAAAAABsPUyeAAAEL0lEQVR42u3bS0hVQRgA4P/6CMVXei3xERphZZmPTEQIs6hFrQIxKdsUurGdFblpEy0qRQ0psIzeREFgaIuIXkRUZFliNzSNshIrwjRT8T6mhY9bOnM7c86cmXPp/1cX7v/7f8p17syZGSB+GYBsZCMb2chGNrKRjWxkIxvZyEY2spGNbGQjG9n/C/tuRW5ybFR4WERMYlrxaX9g/yiyw5wITb9uZXbvMhuwwl5jUXZ5MPiO1FHrsQts8O+wf7AWe5sWNABAnMs67AdBoD02W4WdAlwR9MYK7I5A4I0i9ewK0BHRqtkrQFcEDillx4LOsPUoZIeB/nisjB0FRqJbETsejMV3JeyNBtVgU8GuAcMRLZ/9DQTETunsIBFsaJPMLgYxIZfdL0gNJVLZEaLY8EUi+6IwNSRJZNu4ZLGtLtJRGMB496k0dhMPOm666gD9/QXS2DwLg63eMgc9o0sS+z6HOv7PwlvUlNWS2Gm6x2U7Nccthe3mUGf/XdpNTaqXwj7FwR6c3Y8W86WwUwx8d9OzXDLYIJx9SQL7Gcc6oE4be60E9kH9aDImaB6og53qQ5q45UjVyslvcVstpfaCOjYbnTn1r3UzgI4mLlblc4XsK96cOnppBqu0yXT2MKs1fWupP2nmsYJ7DfM33m06+xFrdkpL/pwAAFWjhBDiuePjfyLXdPY1RudeCjpxZvK6hGPCZQq7Uetg8ClB+wAfbDq7ViM7ycwFPD/7mKGvcWXsao2NM6zFrtfaeCTDSuwzjMZv56b+zJx6LzInL9mnOtR09g2eMWw4CwDKJ1+3zGOzU0xnt7NaN1LTh3J+Tb/05DDZhaazPcze3sm++yS9Np1Vuk/lDHDDyGRGsw2ggWsGeNV8tq9nO5F7qg9tmnp9nFJ7nlHXZz47X/OoVm+l1c0JjuFY41oyRAJ7QPzKfYd/PnC4J4O9Tv+OqUfQBo4e9m0O9qxlSxc1aZWcJ676PyX0SXirHDbP5l6ahvmMpOfbX3n+3KXeuif0jDJZmyCLedxpzqmq/YyEUVnsl3wrrrymV46W7cyZjLQtJ7JI3L4kDMlj94pT6zpcp3fzer0wtlsm2yVKfY7IZJOzYtTJRC6b5Ahhj8hme0Qc32kmstnknXF1KZHPNn6oZClRwSZ7FR2nM3pYtNSIOnRCFduIO8zItRCjB6F1f05inEQhm1zWp84y1tX4If8emw51JVHNJs7lvOgAB1HP5h7A843fGBJzXWg8Wzs6yCGgoajLWT3hGtUNQtqJuwr3Wsv1ClGXD0VePPxY4Nsc8lBYK8G3U9uZG2KBNYMC+4i/C/z+6MI5p49KOifENjHp5vVA14v6yrJdFYdbOvvGTPj5eGEc2chGNrKRjWxkIxvZyEY2spGNbGQjG9nIRjaykY1sZPsIt8vpj+zxMY8fsj0jw22/AQbHGYQmT15qAAAAAElFTkSuQmCC" alt="Разработка: preview" title="preview" /></p>

<h4 id="ани-ма-ция-кно-пок">Ани­ма­ция кно­пок</h4>

<p>Сей­час мы по­ра­бо­та­ет над ани­ма­ци­я­ми во­круг глав­ной кноп­ки. Спер­ва со­зда­дим свой­ство @ViewChildren() для по­лу­че­ния GridLayout-ов всех кно­пок:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">@ViewChildren(&#39;shareButton&#39;) shareButtonRefs: QueryList&lt;ElementRef&gt;;

  private get shareButtons(): Array&lt;GridLayout&gt; {
    return this.shareButtonRefs.map(s =&gt; s.nativeElement);
  }</pre></div>
<p>Мы хо­тим сде­лать двух­этап­ные ани­ма­ции. Сна­ча­ла кноп­ки соц­се­тей вы­ле­та­ют из-за глав­ной кноп­ки про­стым ли­ней­ным пе­ре­ме­ще­ни­ем. За­тем нам нуж­но сде­лать кое-что по­слож­нее &mdash; нам нуж­но, что­бы мел­кие кноп­ки вы­ле­та­ли по кру­гу от глав­ной. Фи­наль­ная по­зи­ция кноп­ки в кру­ге бу­дет за­ви­сеть от по­ло­же­ния дру­гих кно­пок или, дру­ги­ми сло­ва­ми, от её по­зи­ции в мас­си­ве shareButtons.<br />
Для со­зда­ния кру­го­во­го пе­ре­ме­ще­ния вспом­ним, как расчи­ты­ва­ют­ся ко­ор­ди­на­ты x, y от точ­ки по краю окруж­но­сти, в уг­ло­вой функ­ции:</p>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAM0AAABQCAAAAACfL64oAAAEy0lEQVR42u2bwZHjKhCGCUG1IRDAO5DAXhQCMRACMRBC3/fWIRADIRADKfzvgGwLBLLWeKsk1VA1MzXGePRJTdMaPgkszWpcqXk5TXKSsnxV5B9JyXQlmEjwEa5+eaG5GAwS4BC4TWME42ItWVBo0iQhzzId4tF3Oobz6xfoQeOEPcl0cIffKgFr67FiLNCIyH2Rxhx+Z9CAL9OwjZlmFuFDGAfw+gyNTT/vlinBn5yiaDKN+pRGRgDTRye3eWlyYp0T1Ccpdh6jSQIA1oPHaHIu0gxo/8nJCEM0efTE72mYcmg/DtIRcQIcswPgmBwBcQaAOAFQvj3uTdx3aJhNINP9jKXbCwCQ1KQhG5if89TS4xsAGAfMDtoDcQZTzkjBAICxAERsjttvbNo0DBgNm1/Vz0ZV9x5NSE4ivn639DqoKADEFCcAUJ7mBHiADQAI45wRzXHvkohu08TXtW5mj6W7iDSttdbyCR2hy4Ow8zNRcU4cpABAW8xCOSw0SQCwpjkOEL22ovndmDdi/zwsNUTayQIiVTTUoUmIJO2yfngFQIbmuHeRZnvrjVfAErvbSHt2y1hxr2hCWS2VkZYAxDABgGSXgKSWLBDmcln8i0jrZIFgoU1/KXx1k80raIvGmQqmygLJQzMQFJxbRipkLN0b9yZD+yaNNz4a7n7Eqtsx2U5pUiwZdaa1jhmAJbIAEbNLAHQCQGxjd9y/XD23bax6ZTqUuZYK0dlUVIqPyub312gG2/u7eW+NAgCKQDJFpfioOk9DEw5cHFY5qjL8q1KMhG9H2mjjeJBGOQB6XSk+79bOQ4Oj18aLOdpYV4pXpYEXgoGqtjrXvDlOE02YBd2FZgZAIt4j0oLNhUJVKV6ahnxVKV6PJlfec8p1VFkpXo0mWCkMAcnaXNkUleL1rs3bu64fmvPSSJFuRHOaLYJv0PBZtgi+QqOmdB8af72NtT5NnAi3oYnS4z40SdKNaJAmcyMaeOFuRAMt4o1ovDA3ooGY7kRzr6rz5/7mh+aHptHa3uBFaTre4EVpOt7gk+a/i82bpjf4pPkl/pxiPhwtsDbeIOh0kXZcHNx4g4+xYzRD6mBtYB8uFhveIPKu/BBNrQ7+3f8XKkFwWBzE4G5UrQ4OleLD4uAgzUYdHKIZFgcHI22jDh42B5kcBaUAr1RgZ/ANcbBLw+Syv9M5uNy7ke3WNIU6WLo/iyvoJQAvfRa4xsXBHk0IQQK0HEttdD1792gqdbDwshZXMMjH9Z35G+Jgb95EWIva/dv2riOtMgc36mBhAGZXMNNMAGb6hjjYzwJTzF/ttvRu1MFi3pT3s2sDcHEFS5pxcbA7b+K0/J1WpL16a3VwTVOqg0XILK5gSTMuDnZpgioveKe3VgfXIwp1sJzOiytY0oyLg/0MbZhkf2V/9lbq4BpgvWhUqTa7gmEWBmEWJlmh+KA42FXtVqtna71Ju/+VavcObWodEAd3VLtVZVPTpClBc59kr/fzduQxwJ5qt1t1OnZ+7/bC/YtdkuPi4Fa1i/S6I5jFKfZwDouDW9Vufbd2nYfw9lS7Bw1dZlN6T7XD6Z4pPJ4FtqrdcyW3Vwm1PdXuVZdcRRnYU+1wueek91S7NZm7wDPs+6od3j40dLH2Py3rrcGF9SMWAAAAAElFTkSuQmCC" alt="Разработка: Создание анимированной кнопки Поделиться в NativeScript" /><br />
где x0 и y0 это ко­ор­ди­на­ты на­ча­ла кру­га, r это его ра­ди­ус, а ϴ это угол.</p>

<p>Что­бы мы мог­ли уви­деть кру­го­вую ани­ма­цию, нель­зя про­сто пе­ре­ме­стить точ­ку по кру­гу. Это бы при­ве­ло к пе­ре­се­че­нию окруж­но­сти:<br />
<img src="img/x0505780f75.png.pagespeed.ic.aUPuRm9-k8.png" alt="Разработка: Создание анимированной кнопки Поделиться в NativeScript" /><br />
Вме­сто это­го нуж­но сде­лать несколь­ко по­сле­до­ва­тель­ных пе­ре­ме­ще­ний, ма­лы­ми ша­га­ми (ма­лень­кие ва­ри­а­ции ϴ):<br />
<img src="img/x66e7960a8c.png.pagespeed.ic.6yFZTab06D.png" alt="Разработка: Создание анимированной кнопки Поделиться в NativeScript" /><br />
Пе­ре­ве­дём те­перь это в код.</p>

<h4 id="ани-ми-ру-ем-ма-лые-кноп-ки-во-круг-глав-ной">Ани­ми­ру­ем ма­лые кноп­ки во­круг глав­ной</h4>

<p>От­сле­дим тап по глав­ной кноп­ке ме­то­дом onMainButtonTap() на­ше­го Component:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app/social-share-button/social-share-button.component.html --&gt;

[...]
  &lt;GridLayout
    (tap)=&#34;onMainButtonTap()&#34;
    [style.width]=&#34;size&#34;&gt;
[...]</pre></div>
<p>И со­от­вет­ству­ю­щий ме­тод в Component:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/social-share-button/social-share-button.component.ts

[...]
import { Animation } from &#39;ui/animation&#39;;
[...]
  constructor(private fonticon: TNSFontIconModule) {}

  public onMainButtonTap(): void {
    const animationDefinitions = this.shareButtons.map(button =&gt; {
      return {
        target: button,
        translate: { x: this.size * 0.8, y: 0 },
        duration: 200
      };
    });
    const animation = new Animation(animationDefinitions);
    animation.play();
  }
}</pre></div>
<p>Пе­ре­ме­ще­ние по оси x бу­дет рав­но зна­че­нию, пря­мо про­пор­ци­о­наль­но­му раз­ме­ру глав­ной кноп­ки. С это­го зна­че­ния и нач­нут­ся все вра­ще­ния. Ес­ли вер­нуть­ся к рас­че­там ко­ор­ди­нат, то это бу­дет ра­ди­у­сом, во­круг ко­то­ро­го мы вра­ща­ем кноп­ки. Зная всё это, со­зда­дим свой­ство-getter для по­лу­че­ния это­го зна­че­ния:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
  private get buttonRotationRadius(): number {
    return this.size * 0.8;
  }

[...]
  public onMainButtonTap(): void {
    const animationDefinitions = this.shareButtons.map(button =&gt; {
      return {
        target: button,
        translate: { x: this.buttonRotationRadius, y: 0 },
        duration: 200
      };
    });
    const animation = new Animation(animationDefinitions);
    animation.play();
  }
}</pre></div>
<p>От­сю­да угол ϴ ра­вен ну­лю. Те­перь пе­рей­дём к са­мо­му за­бав­но­му: вра­ще­нию кно­пок.</p>

<h4 id="кру-го-вые-пе-ре-ме-ще-ния-кно-пок">Кру­го­вые пе­ре­ме­ще­ния кно­пок</h4>

<p>Пе­ред тем, как мы про­дол­жим ре­а­ли­за­цию ме­то­да, да­вай­те по­ду­ма­ем о том, что нам нуж­но. Мы го­во­ри­ли, что хо­тим иметь воз­мож­ность пе­ре­ме­щать кноп­ки на неболь­шие уг­лы, или по­ша­го­во. Нам та­к­же нуж­но расчи­тать зна­че­ние мак­си­маль­но­го уг­ла пе­ре­ме­ще­ния каж­дой кноп­ки, в за­ви­си­мо­сти от её по­зи­ции в мас­си­ве. Сде­ла­ем по­ка толь­ко это и со­зда­дим два сле­ду­ю­щих ме­то­да:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
import { range } from &#39;lodash&#39;;
[...]

  private maxAngleFor(index: number): number {
    return index * 45;
  }

  private angleIntervals(maxAngle: number): Array&lt;number&gt; {
    const step = 5;
    return range(0, maxAngle + step, step);
  }
}</pre></div>
<p>Ме­тод maxAngleFor() на вхо­де при­ни­ма­ет index и воз­вра­ща­ет его, умно­жен­ным на 45. Это зна­чит, что каж­дая кноп­ка бу­дет от­де­ле­на чет­вер­тью кру­га &mdash; для сим­мет­рии.<br />
Ме­тод angleIntervals() при­ни­ма­ет maxAngle, и воз­вра­ща­ет мас­сив по­сле­до­ва­тель­ных зна­че­ний с ша­гом 5, в пре­де­лах maxAngle. Это бу­дут на­ши ша­ги вра­ще­ния.<br />
Та­к­же мы ре­а­ли­зу­ем ме­тод по­лу­че­ния ко­ор­ди­нат точ­ки, со­от­вет­ству­ю­щей зна­че­нию уг­ла:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
import { Animation, Pair } from &#39;ui/animation&#39;;
[...]
  private buttonCoordinatesFor(angle: number): Pair {
    const x = this.buttonRotationRadius * Math.cos(angle * Math.PI / 180);
    const y = this.buttonRotationRadius * Math.sin(angle * Math.PI / 180);

    return { x: x, y: y };
  }
}</pre></div>
<p>Те­перь важ­ная за­да­ча &mdash; сде­лать пе­ре­ме­ще­ния кно­пок с при­вяз­кой к ша­гу по окруж­но­сти. Од­но из ре­ше­ний для это­го &mdash; со­здать мас­сив из AnimationDefinition, как мы сде­ла­ли в преды­ду­щем раз­де­ле, и вы­зы­вать ани­ма­ции с фла­гом playSequentially. К со­жа­ле­нию, сде­лай мы так, это при­ве­ло бы к очист­ке пред­став­ле­ния по­сле каж­до­го ша­га ани­ма­ции, что нам аб­со­лют­но не нуж­но. Дру­гое ре­ше­ние &mdash; к каж­до­му ша­гу ани­ма­ции при­вя­зы­вать воз­вра­щён­ное зна­че­ние Promise че­рез ме­тод then(). Мы мо­жем сде­лать это с по­мо­щью ме­то­да reduce(), вы­зван­но­го по­сле ме­то­да angleIntervals(). Несколь­ко строк ко­да рас­ска­жут нам боль­ше ты­ся­чи слов:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
    animation.play().then(() =&gt; {
      this.shareButtons.forEach((button, index) =&gt; {
        const maxAngle = this.maxAngleFor(index);
          this.angleIntervals(maxAngle).reduce((accumulator, currentAngle, index) =&gt; {
            return accumulator.then(() =&gt; {
              return button.animate({
                translate: this.buttonCoordinatesFor(currentAngle),
                duration: 0.8
              });
            });
          }, Promise.resolve({}));
      });
[...]</pre></div>
<p>Для каж­дой кноп­ки мы по­лу­ча­ем со­от­вет­ству­ю­щее ей зна­че­ние maxAngle. И ис­поль­зу­ем его для рас­чё­та уг­ло­вых ша­гов, вы­зы­вая ме­тод reduce, свя­зы­вая вме­сте все Promise (мы на­ча­ли с ре­зуль­та­та пу­сто­го Promise). Про­дол­жи­тель­ность ани­ма­ции за­ни­ма­ет все­го 0.8 мс, так мы пе­ре­ме­ща­ем кноп­ку на со­от­вет­ству­ю­щие ко­ор­ди­на­ты для те­ку­ще­го уг­ла. На­пом­ню, что на­чи­на­ем мы с уг­ла, рав­но­го 0.</p>

<p>По­сле неболь­шо­го ре­фак­то­рин­га, это пре­вра­ща­ет­ся в:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
  public onMainButtonTap(): void {
    this.translateShareButtonsOutOfMainButton().then(() =&gt; {
      this.rotateShareButtonsAroundMainButton();
    });
  }

  private translateShareButtonsOutOfMainButton(): AnimationPromise {
    const animationDefinitions = this.shareButtons.map(button =&gt; {
      return {
        target: button,
        translate: { x: this.circularRotationRadius, y: 0 },
        duration: 200
      };
    });
    const animation = new Animation(animationDefinitions);
    return animation.play();
  }

  private rotateShareButtonsAroundMainButton(): void {
    this.shareButtons.forEach((button, index) =&gt; {
      this.rotateAroundMainButton(button, index);
    });
  }

  private rotateAroundMainButton(button: GridLayout, index: number): AnimationPromise {
    const maxAngle = this.maxAngleFor(index);
    return this.angleIntervals(maxAngle).reduce(
      this.getStepRotationAccumulatorFor(button),Promise.resolve()
    );
  }

  private getStepRotationAccumulatorFor(button: GridLayout) {
    return (accumulator, currentAngle, index) =&gt; {
      return accumulator.then(() =&gt; this.doStepRotation(button, currentAngle));
    }
  }

  private doStepRotation(button: GridLayout, angle: number): AnimationPromise {
    return button.animate({
      translate: this.buttonCoordinatesFor(angle),
      duration: 0.8
    });
  }
}</pre></div>
<h4 id="воз-врат-кно-пок-на-ме-сто">Воз­врат кно­пок на ме­сто</h4>

<p>Ко­гда кноп­ки по­ка­жут­ся, нам по­на­до­бит­ся спо­соб вер­нуть их на­зад, от­ку­да они вы­шли. Что­бы это сде­лать, нам по­на­до­бит­ся флаг shareButtonDisplayed, по­ка­зы­ва­ю­щий ви­ди­мость кно­пок:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
@Component({
  selector: &#39;social-share-button&#39;,
  templateUrl: &#39;social-share-button/social-share-button.component.html&#39;,
  styleUrls: [&#39;social-share-button/social-share-button.component.css&#39;]
})
export class SocialShareButtonComponent {

  private shareButtonDisplayed = false;
[...]</pre></div>
<p>Ани­ма­ция об­рат­но­го воз­вра­та кно­пок бу­дет очень по­хо­жа на translateShareButtonsOutOfMainButton(), по­это­му мы возь­мём со­дер­жи­мое ме­то­да, что­бы сде­лать его бо­лее уни­фи­ци­ро­ван­ным:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
  private translateShareButtonsOutOfMainButton(): AnimationPromise {
    return this.translateShareButtonsTo({
      x: this.circularRotationRadius,
      y: 0
    })
  }

  private translateShareButtonsTo(coordinates: Pair): AnimationPromise {
    const animationDefinitions = this.shareButtons.map(button =&gt; {
      return {
        target: button,
        translate: coordinates,
        duration: 200
      };
    });
    const animation = new Animation(animationDefinitions);
    return animation.play();
  }
[...]</pre></div>
<p>Что поз­во­лит нам на­пи­сать:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
  private translateShareButtonsBackInMainButton(): AnimationPromise {
    return this.translateShareButtonsTo({ x: 0, y: 0 });
  }
[...]</pre></div>
<p>И те­перь мы мо­жем пе­ре­пи­сать onMainButtonTap():</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
  public onMainButtonTap(): void {
    if (!this.shareButtonDisplayed) {
      this.translateShareButtonsOutOfMainButton().then(() =&gt; {
        this.rotateShareButtonsAroundMainButton();
      });
    }
    else {
      this.translateShareButtonsBackInMainButton();
    }
    this.shareButtonDisplayed = !this.shareButtonDisplayed;
  }
[...]</pre></div>
<p>Про­бле­ма те­ку­щей ре­а­ли­за­ции в том, что поль­зо­ва­тель мо­жет по­ло­мать на­шу ани­ма­цию. Что­бы это­го из­бе­жать, мы вве­дём пе­ре­мен­ную-пе­ре­чис­ле­ние State, по­ка­зы­ва­ю­щую со­сто­я­ние Component: ожи­да­ние, про­иг­ры­ва­ние или оста­нов­лен. Пе­ред этим необ­хо­ди­мо пе­ре­де­лать ме­тод rotateShareButtonsAroundMainButton() для воз­вра­та Promise. В этом ме­то­де мы хо­тим воз­вра­щать ре­зуль­тат Promise-ов всех ани­ма­ций, по­это­му мы долж­ны пой­мать мо­мент окон­ча­ния всей ани­ма­ции (оста­нов­лен). Из­ме­ним ме­тод сле­ду­ю­щим об­ра­зом:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
  private rotateShareButtonsAroundMainButton(): AnimationPromise {
    const animationPromises = this.shareButtons.map((button, index) =&gt; {
      return this.rotateAroundMainButton(button, index);
    });
    return &lt;AnimationPromise&gt;Promise.all(animationPromises);
  }
[...]</pre></div>
<p>Из­ме­ним флаг по со­сто­я­нию ани­ма­ции:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
enum AnimationState {
  idle,
  animating,
  settled
}

@Component({
  selector: &#39;social-share-button&#39;,
  templateUrl: &#39;social-share-button/social-share-button.component.html&#39;,
  styleUrls: [&#39;social-share-button/social-share-button.component.css&#39;]
})
export class SocialShareButtonComponent {

  private animationState = AnimationState.idle;
[...]</pre></div>
<p>И фи­наль­ная ре­а­ли­за­ция:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
  public onMainButtonTap(): void {
    if (this.animationState === AnimationState.idle) {
      this.translateShareButtonsOutOfMainButton().then(() =&gt; {
        this.animationState = AnimationState.animating;
        return this.rotateShareButtonsAroundMainButton();
      }).then(() =&gt; {
       this.animationState = AnimationState.settled;
      });
    }
    if (this.animationState === AnimationState.settled) {
      this.translateShareButtonsBackInMainButton().then(() =&gt; {
        this.animationState = AnimationState.idle;
      });
    }
  }
[...]</pre></div>
<p>К это­му мо­мен­ту вы уже долж­ны убе­дить­ся в кра­со­те Promise-ов в JavaScript.</p>

<h4 id="де-ла-ем-кноп-ки-на-стра-и-ва-е-мы-ми">Де­ла­ем кноп­ки на­стра­и­ва­е­мы­ми</h4>

<p>Сей­час на­ши чер­но-бе­лые кноп­ки вы­гля­дят очень скуч­но. Сде­ла­ем их на­стра­и­ва­е­мы­ми. До­ба­вим па­ру Input-ов (с неко­то­ры­ми зна­че­ни­я­ми по-умол­ча­нию):</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
  @Input(&#39;buttonColor&#39;) buttonColor = &#39;#CC0000&#39;;
  @Input(&#39;iconColor&#39;) iconColor = &#39;#FFFFFF&#39;;
[...]</pre></div>
<p>И при­вя­жем к шаб­ло­ну:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app/social-share-button/social-share-button.component.html --&gt;

&lt;GridLayout rows=&#34;auto&#34;
  [style.width]=&#34;viewWidth&#34;
  [style.height]=&#34;viewHeight&#34;&gt;
  &lt;GridLayout #shareButton
    [style.width]=&#34;shareButtonSize&#34;
    *ngFor=&#34;let shareIcon of shareIcons&#34;&gt;
    &lt;Label
      [style.color]=&#34;buttonColor&#34;
      [style.font-size]=&#34;shareButtonSize&#34;
      class=&#34;fa button&#34;
      [text]=&#34;&#39;fa-circle&#39; | fonticon&#34;&gt;
    &lt;/Label&gt;
    &lt;Label [style.font-size]=&#34;shareIconSize&#34;
      [style.color]=&#34;iconColor&#34;
      class=&#34;fa share-icon&#34;
      [text]=&#34;&#39;fa-&#39; + shareIcon | fonticon&#34;&gt;&lt;/Label&gt;
  &lt;/GridLayout&gt;
  &lt;GridLayout
    (tap)=&#34;onMainButtonTap()&#34;
    [style.width]=&#34;size&#34;&gt;
    &lt;Label
      [style.color]=&#34;buttonColor&#34;
      [style.font-size]=&#34;size&#34;
      class=&#34;fa button&#34;
      [text]=&#34;&#39;fa-circle&#39; | fonticon&#34;&gt;&lt;/Label&gt;
    &lt;Label [style.font-size]=&#34;mainIconSize&#34;
      [style.color]=&#34;iconColor&#34;
      class=&#34;fa share-icon&#34;
      [text]=&#34;&#39;fa-share-alt&#39; | fonticon&#34;&gt;&lt;/Label&gt;
  &lt;/GridLayout&gt;
&lt;/GridLayout&gt;</pre></div>
<p>А та­к­же мож­но немно­го под­со­кра­тить таб­ли­цу сти­лей:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">/* app/social-share-button/social-share-button.component.css */

GridLayout {
  text-align: center;
  vertical-align: center;
}

Label.share-icon {
  vertical-align: center;
}</pre></div>
<h4 id="до-ба-вим-эф-фект-те-ни-с-по-мо-щью-на-тив-но-го-ко-да">До­ба­вим эф­фект те­ни с по­мо­щью на­тив­но­го ко­да</h4>

<p>Немно­го улуч­шим стиль кноп­ки, до­ба­вив к ней тень. NativeScript по­ка не под­дер­жи­ва­ет по­каз те­ни в пред­став­ле­нии, по­это­му мы сде­ла­ем это на на­тив­ном ко­де, с по­мо­щью Directive, ко­то­рая мо­жет быть ре­а­ли­зо­ва­на и для iOS и для Android.<br />
Со­зда­дим но­вую пап­ку спе­ци­аль­но для ко­да на­шей Directive, на­зо­вём её label-shadow. Те­перь со­зда­дим аб­стракт­ную ба­зо­вую ди­рек­ти­ву, ко­то­рая бу­дет уна­сле­до­ва­на каж­дой плат­фор­мой:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/label-shadow/label-shadow-base.directive.ts

import { Directive, ElementRef } from &#39;@angular/core&#39;;
import { Label } from &#39;ui/label&#39;;
import { Observable } from &#39;data/observable&#39;;
import { Color } from &#39;color&#39;;

@Directive({
  selector: &#39;[shadow]&#39;
})

export abstract class LabelShadowBaseDirective {

  private get label(): Label {
    return this.el.nativeElement;
  }

  protected get shadowColor(): Color {
    return new Color(&#39;#888888&#39;);
  }

  protected get shadowOffset(): number {
    return 5.0;
  }

  constructor(protected el: ElementRef) {
    this.label.on(Observable.propertyChangeEvent, () =&gt; {
      if (this.label.text !== undefined) {
        this.displayShadowOn(this.label);
      }
    });
  }

  protected abstract displayShadowOn(label: Label);
}</pre></div>
<p>Нам нуж­но по­до­ждать, по­ка Label с пла­ги­ном FontIcon на­стро­ит­ся, по­это­му до­ба­вим хук &mdash; пе­ре­хват­чик со­бы­тия. По его го­тов­но­сти мы при­ме­ним аб­стракт­ный ме­тод displayShadowOn().</p>

<p>Пе­ред тем, как взять­ся за ре­а­ли­за­цию, со­зда­дим опи­са­ние ти­пов, ко­то­рое по­ка­жет TypeScript, что ди­рек­ти­ва здесь бу­дет во вре­мя ком­пи­ля­ции:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/label-shadow/label-shadow.directive.ts

import { Label } from &#39;ui/label&#39;;
import { LabelShadowBaseDirective } from &#39;./label-shadow-base.directive&#39;;

export declare class LabelShadowDirective extends LabelShadowBaseDirective {
  constructor(label: Label);
  protected displayShadowOn(label: Label);
}</pre></div>
<p>Со­зда­дим ре­а­ли­за­цию под Android:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/label/label-shadow.directive.android.ts

import { Directive, ElementRef } from &#39;@angular/core&#39;;
import { Label } from &#39;ui/label&#39;;
import { LabelShadowBaseDirective } from &#39;./label-shadow-base.directive&#39;;
import { Color } from &#39;color&#39;;

@Directive({
  selector: &#39;[shadow]&#39;
})
export class LabelShadowDirective extends LabelShadowBaseDirective {
  constructor(protected el: ElementRef) {
    super(el);
  }

  protected displayShadowOn(label: Label) {
    const nativeView = label.android;
    nativeView.setShadowLayer(
      10.0,
      this.shadowOffset,
      this.shadowOffset,
      this.shadowColor.android
    );
  }
}</pre></div>
<p>И для iOS:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/label-shadow/label-shadow.directive.ios.ts

import { Directive, ElementRef } from &#39;@angular/core&#39;;
import { Label } from &#39;ui/label&#39;;
import { Observable } from &#39;data/observable&#39;;
import { LabelShadowBaseDirective } from &#39;./label-shadow-base.directive&#39;;
import { Color } from &#39;color&#39;;

declare const CGSizeMake: any;

@Directive({
  selector: &#39;[shadow]&#39;
})
export abstract class LabelShadowDirective extends LabelShadowBaseDirective {

  constructor(protected el: ElementRef) {
    super(el);
  }

  protected displayShadowOn(label: Label) {
    const nativeView = label.ios;
    nativeView.layer.shadowColor = this.shadowColor.ios.CGColor;
    nativeView.layer.shadowOffset = CGSizeMake(this.shadowOffset, this.shadowOffset);
    nativeView.layer.shadowOpacity = 1.0;
    nativeView.layer.shadowRadius = 2.0;
  }
}</pre></div>
<p>За­тем до­ба­вим Directive в де­кла­ра­ции AppModule:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/app.module.ts

import { NgModule, NO_ERRORS_SCHEMA } from &#39;@angular/core&#39;;
import { NativeScriptModule } from &#39;nativescript-angular/platform&#39;;
import { SocialShareButtonComponent } from &#39;./social-share-button/social-share-button.component&#39;;
import { TNSFontIconModule } from &#39;nativescript-ng2-fonticon&#39;;
import { AppComponent } from &#39;./app.component&#39;;
import { LabelShadowDirective } from &#39;./label-shadow/label-shadow.directive&#39;;

@NgModule({
    declarations: [
      AppComponent,
      SocialShareButtonComponent,
      LabelShadowDirective
    ],
    bootstrap: [AppComponent],
    imports: [
      NativeScriptModule,
      TNSFontIconModule.forRoot({
        &#39;fa&#39;: &#39;font-awesome.css&#39;
      })
    ],
    schemas: [NO_ERRORS_SCHEMA]
})
export class AppModule { }</pre></div>
<p>Те­перь мы мо­жем до­ба­вить ди­рек­ти­ву в Label-ы FontIcon, пред­став­ля­ю­щие на­ши кноп­ки:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app/social-share-button/social-share-button.component.html --&gt;

[...]
    &lt;Label
      shadow
      [style.color]=&#34;buttonColor&#34;
      [style.font-size]=&#34;shareButtonSize&#34;
      class=&#34;fa button&#34;
      [text]=&#34;&#39;fa-circle&#39; | fonticon&#34;&gt;
    &lt;/Label&gt;
[...]
    &lt;Label
      shadow
      [style.color]=&#34;buttonColor&#34;
      [style.font-size]=&#34;size&#34;
      class=&#34;fa button&#34;
      [text]=&#34;&#39;fa-circle&#39; | fonticon&#34;&gt;&lt;/Label&gt;
[...]</pre></div>
<p>Пред­ста­вим Component в раз­ных раз­ме­рах и цве­тах. От­ре­дак­ти­ру­ем AppComponent:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/app.component.ts

import { Component } from &#34;@angular/core&#34;;

@Component({
  selector: &#34;my-app&#34;,
  templateUrl: &#34;app.component.html&#34;,
  styleUrls: [&#39;app.component.css&#39;]
})
export class AppComponent {
  public get shareIcons(): Array&lt;string&gt; {
    return [&#39;facebook&#39;, &#39;twitter&#39;, &#39;linkedin&#39;, &#39;github&#39;, &#39;tumblr&#39;];
  }
}</pre></div>
<p>И шаб­лон:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app/app.component.html --&gt;

&lt;StackLayout class=&#34;container&#34;&gt;
  &lt;social-share-button
    [shareIcons]=&#34;shareIcons&#34;
    [size]=&#34;100&#34;&gt;
  &lt;social-share-button
    [buttonColor]=&#34;&#39;#581845&#39;&#34;
    [shareIcons]=&#34;shareIcons&#34;
    [size]=&#34;80&#34;&gt;
  &lt;social-share-button
    [buttonColor]=&#34;&#39;#FFC300&#39;&#34;
    [iconColor]=&#34;&#39;#C70039&#39;&#34;
    [shareIcons]=&#34;shareIcons&#34;
    [size]=&#34;60&#34;&gt;
  &lt;social-share-button
    [buttonColor]=&#34;&#39;#99D5FF&#39;&#34;
    [iconColor]=&#34;&#39;#000000&#39;&#34;
    [shareIcons]=&#34;shareIcons&#34;
    [size]=&#34;40&#34;&gt;
&lt;/StackLayout&gt;</pre></div>
<p>Что даст нам:</p>

<p><img src="img/x92062e41b1.png.pagespeed.ic.oVK2Ku7sZe.png" alt="Разработка: Создание анимированной кнопки Поделиться в NativeScript" /></p>

<h4 id="ре-зуль-тат-на-жа-той-кноп-ки-по-де-лить-ся">Ре­зуль­тат на­жа­той кноп­ки «По­де­лить­ся»</h4>

<p>Кноп­ки уже вы­гля­дят хо­ро­шо, но они бес­по­лез­ны, по­то­му что ни­че­го не де­ла­ют. Вве­дём EventEmitter Output, ко­то­рый бу­дет по­ка­зы­вать имя икон­ки, ко­гда со­от­вет­ству­ю­щая кноп­ка бу­дет на­жа­та:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/social-share-button.component.ts

[...]
  @Output(&#39;shareButtonTap&#39;) shareButtonTap = new EventEmitter&lt;string&gt;();
[...]</pre></div>
<p>За­тем при­вя­жем хук к (tap) GridLayout-а кноп­ки на ме­тод onShareButton(), пе­ре­да­вая ему на­зва­ние икон­ки:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app/social-share-button/social-share-button.component.html --&gt;

[...]
  &lt;GridLayout #shareButton
    [style.width]=&#34;shareButtonSize&#34;
    *ngFor=&#34;let shareIcon of shareIcons&#34;
    (tap)=&#34;onShareButtonTap(shareIcon)&#34;&gt;
[...]</pre></div>
<p>Со­зда­дим со­от­вет­ству­ю­щий ме­тод, по­ка­зы­ва­ю­щий имя знач­ка, пе­ре­дав ему па­ра­мет­ром икон­ку:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/social-share-button/social-share-button.component.ts

[...]
  public onShareButtonTap(icon: string): void {
    this.shareButtonTap.emit(icon);
  }
[...]</pre></div>
<p>Это поз­во­ля­ет под­пи­сать­ся на со­бы­тие в AppComponent:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app/app.component.html --&gt;

[...]
  &lt;social-share-button
    [shareIcons]=&#34;shareIcons&#34;
    [size]=&#34;100&#34;
    (shareButtonTap)=&#34;onShareButtonTap($event)&#34;&gt;&lt;/social-share-button&gt;
[...]</pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/app.component.ts

import { Component } from &#34;@angular/core&#34;;
import * as dialogs from &#39;ui/dialogs&#39;;

@Component({
  selector: &#34;my-app&#34;,
  templateUrl: &#34;app.component.html&#34;,
  styleUrls: [&#39;app.component.css&#39;]
})
export class AppComponent {
  public get shareIcons(): Array&lt;string&gt; {
    return [&#39;facebook&#39;, &#39;twitter&#39;, &#39;linkedin&#39;, &#39;github&#39;, &#39;tumblr&#39;];
  }

  public onShareButtonTap(event: string): void {
    dialogs.alert(`share on: ${event}`);
  }
}</pre></div>
<h4 id="до-ба-вим-немно-го-про-ве-рок">До­ба­вим немно­го про­ве­рок</h4>

<p>В по­след­нем ша­ге до­ба­вим про­вер­ки, для то­го, что­бы предот­вра­тить некор­рект­ное ис­поль­зо­ва­ние Component-а.</p>

<p>Окро­ем ещё раз SocialShareButton, и сде­ла­ем так, что­бы он ре­а­ли­зо­вы­вал ин­тер­фейс OnInit:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/social-share-button/social-share-button.component.ts

import {
[...]
  OnInit
} from &#39;@angular/core&#39;;

[...]
export class SocialShareButtonComponent implements OnInit {
[...]</pre></div>
<p>за­тем ре­а­ли­зу­ем пе­ре­хват ngOnInit() с про­вер­ка­ми:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/social-share-button.component.ts

[...]
  public ngOnInit() {
    if (!this.shareIcons || this.shareIcons.length === 0) {
      throw new Error(&#39;you need to specify at least 1 icon&#39;);
    }
    if (this.shareIcons.length &gt; 5) {
      throw new Error(&#39;the list of icons cannot contain more than 5 elements&#39;);
    }
  }
[...]</pre></div>
<p>Наш Component те­перь го­тов!</p>

<p><a href="http://www.blog.bdauria.com/wp-content/uploads/2017/01/showcase.webm?_=1"><img src="http://www.blog.bdauria.com/wp-content/uploads/2017/01/showcase.webm?_=1" alt="video" /></a></p>

<p>Ес­ли вам по­нра­вил­ся этот ма­те­ри­ал, не за­будь­те по­де­лить­ся им с кол­ле­га­ми!</p>

<p><a href="http://www.blog.bdauria.com/?p=1021">Ис­точ­ник</a></p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Создание мультиязычного приложения NativeScript</turbo:topic>
      <link>https://fokusov.com/posts/sozdanie-multijazychnogo-prilozhenija-nativescript/</link>
      <pubDate>Thu, 19 Jan 2017 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ 

<p>Для недавнего проекта мне понадобилось решение для мгновенного переключения языка с Нидерландского на Английский.</p>

<p>В одном концепте на NativeScript я разработал собственное решение на чистом <a href="https://tehnojam.pro/tag/javascript/">JavaScript</a> с <a href="https://github.com/messageformat/Jed">Jed</a>. Оно работало, но было далеко не идеальным.<br />
После этого я решил создать приложение на NativeScript с Angular (2+) и начал поиск существующих библиотек локализации для Angular. Лучшим решением оказалась библиотека <a href="https://github.com/ocombe/ng2-translate">ng-translate</a> от <a href="https://twitter.com/OCombe">Olivier Combe</a>.</p>

<p>В Angular она завелась с полпинка, а вот заставить её работать в NativeScript стоило мне много крови и пота. Но благодаря сообществу вокруг NativeScript и персонально Nathan Walker, мне удалось это сделать. И, в принципе, это было не так сложно.</p>

<p>Вы можете выполнить описанное ниже или же просто скачать готовый пример <a href="https://github.com/nativescriptnl/NSNL_Multilingual">NSNL_Multilingual</a> с GitHub.</p>

<h4 id="1-создание-приложения-на-nativescript-и-angular">1. Создание приложения на NativeScript и Angular</h4>

<p>С помощью следующих команд мы создадим новый проект и добавим в него платформы <a href="https://tehnojam.pro/tag/android/">Android</a> и <a href="https://tehnojam.pro/tag/ios/">iOS</a>.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">tns create projectname --ng
cd projectname
tns platform add android
tns platform add ios</pre></div>
<h4 id="2-установка-ng2-translate">2. Установка ng2-translate</h4>

<p>ng2-translate это пакет npm, поэтому он устанавливается стандартно:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">npm install ng2-translate --save</pre></div>
<h4 id="3-создание-языковых-файлов">3. Создание языковых файлов</h4>

<p>Создадим папку <strong>i18n</strong> в папке <strong>app</strong> нашего проекта и добавим файлы nl.json и en.json.<br />
<strong>nl.json</strong></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">{
    &#34;EXAMPLE&#34;: {
        &#34;TITLE&#34;: &#34;Hallo wereld!&#34;,
        &#34;TEXT&#34;: &#34;Dit is een zin in het Nederlands.&#34;,
        &#34;BACK&#34;: &#34;Terug&#34;
    }
}</pre></div>
<p><strong>en.json</strong></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">{
    &#34;EXAMPLE&#34;: {
         &#34;TITLE&#34;: &#34;Hello world!&#34;,
         &#34;TEXT&#34;: &#34;This is a sentence in English.&#34;,
         &#34;BACK&#34;: &#34;Back&#34;
    }
}</pre></div>
<h4 id="4-отредактируем-файл-app-module-ts">4. Отредактируем файл app.module.ts</h4>

<p>Здесь нам нужно импортировать следующие модули:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">import {NativeScriptHttpModule} from &#34;nativescript-angular/http&#34;;
import {TranslateModule, TranslateLoader, TranslateStaticLoader} from &#34;ng2-translate&#34;;
import {Http} from &#34;@angular/http&#34;;</pre></div>
<p>NativeScript использует <a href="https://angular.io/docs/ts/latest/cookbook/aot-compiler.html">AOT компиляцию</a>, поэтому нам нужно экспортировать функцию, которая возвращает <strong>TranslateStaticLoader</strong>.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// for AoT compilation
export function translateLoaderFactory(http: Http) {
    return new TranslateStaticLoader(http, &#34;/i18n&#34;, &#34;.json&#34;);
};</pre></div>
<p>Также нам нужно расширить импорты <strong>@NgModule</strong>:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">NativeScriptHttpModule,
TranslateModule.forRoot([{
    provide: TranslateLoader,
    deps: [Http],
    useFactory: (translateLoaderFactory)}])</pre></div>
<h4 id="5-отредактируем-app-component-html">5. Отредактируем app.component.html</h4>

<p>Замените содержитое файла <strong>app.component.html</strong> следующей разметкой.<br />
С помощью неё мы привязываем EXAMPLE.TITLE к тексту в ActionBar, компоненту Label и содержимому TextView.<br />
Также у нас есть кнопки для переключения между Нидерландским и Английским языками. Эти кнопки вызывают функцию <strong>changeLanguage</strong> при нажатии.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;ActionBar [title]=&#34;&#39;EXAMPLE.TITLE&#39; | translate&#34;&gt;&lt;/ActionBar&gt;
&lt;ScrollView&gt;
    &lt;StackLayout&gt;
        &lt;Label [text]=&#34;&#39;EXAMPLE.TITLE&#39; | translate&#34;&gt;&lt;/Label&gt;
        &lt;TextView editable=&#34;false&#34; [text]=&#34;&#39;EXAMPLE.TEXT&#39; | translate&#34;&gt;&lt;/TextView&gt;
        &lt;Button text=&#34;Nederlands&#34; (tap)=&#34;changeLanguage(&#39;nl&#39;)&#34;&gt;&lt;/Button&gt;
        &lt;Button text=&#34;English&#34; (tap)=&#34;changeLanguage(&#39;en&#39;)&#34;&gt;&lt;/Button&gt;
    &lt;/StackLayout&gt;
&lt;/ScrollView&gt;</pre></div>
<h4 id="6-отредактируем-app-component-ts">6. Отредактируем app.component.ts</h4>

<p>Сначала нам нужно импортировать следующие модули:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">import * as Platform from &#34;platform&#34;;
import {TranslateService} from &#39;ng2-translate&#39;;</pre></div>
<p>При инициализации мы установим язык по-умолчанию в Нидерландский.<br />
После этого изменим язык, основываясь на предпочитаемом языке на устройстве. В случае, если для такого языка у нас нет файла локализации, ng2-translate вернёт язык по-умолчанию.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">constructor(private translate: TranslateService) {
    this.translate.setDefaultLang(&#34;nl&#34;);
    this.translate.use(Platform.device.language);
}</pre></div>
<p>Также нам нужна функция для переключения языков:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">public changeLanguage(lang: string) {
    this.translate.use(lang);
}</pre></div>
<p>Готово! За шесть простых шагов мы создали мультиязычное приложение на NativeScript!</p>

<p>Рекомендую посмотреть более расширенный пример <a href="https://github.com/nativescriptnl/NSNL_Multilingual">NSNL_Multilingual</a> на GitHub, в котором также используется <a href="https://angular.io/docs/ts/latest/guide/router.html">Angular routing</a>.</p>

<p>*Оригинал взят на <a href="https://nativescript.nl/tips/how-to-create-a-multilingual-nativescript-app/">NativeScript.nl</a></p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Контакты</turbo:topic>
      <link>https://fokusov.com/contacts/</link>
      <pubDate>Thu, 20 Oct 2016 22:55:05 -0400</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ <p>Почта: <a href="mailto:igor@fokusov.com">igor@fokusov.com</a></p>

<p>Телефон: <a href="tel:+79215486950">+7 (921) 548-69-50</a></p>

<p>Skype: <a href="skype:fokusov">fokusov</a></p>

<p>FL.ru: <a href="https://www.fl.ru/users/fokusov">fokusov</a></p>

<p>1clancer.ru: <a href="http://1clancer.ru/5999">fokusov</a></p>

<p>ВК: <a href="https://vk.com/ig.fokusov">ig.fokusov</a></p>

<p>Telegram: <a href="https://t.me/ighar">ighar</a></p>

<p>Резюме: <a href="https://spb.hh.ru/resume/2eab4710ff017203db0039ed1f46366a733939">на hh.ru</a></p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Проекты Андроид</turbo:topic>
      <link>https://fokusov.com/android/</link>
      <pubDate>Thu, 20 Oct 2016 22:55:05 -0400</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ 

<p>Некоторые мои приложения для Android, опубликованные в <a href="https://play.google.com/store/apps/developer?id=Igor+Fokusov">Google Play</a>:</p>

<h2 id="календарь-бухгалтера-https-play-google-com-store-apps-details-id-com-fokusov-buhcal"><a href="https://play.google.com/store/apps/details?id=com.fokusov.buhcal">Календарь бухгалтера</a></h2>

<p><img src="/pic01.png" alt="Календарь бухгалтера" /></p>

<hr />

<h2 id="minimal-weather-погода-https-play-google-com-store-apps-details-id-com-fokusov-minimalweather"><a href="https://play.google.com/store/apps/details?id=com.fokusov.MinimalWeather">Minimal Weather (погода)</a></h2>

<p><img src="/pic02.jpg" alt="Minimal Weather" /></p>

<hr />

<h2 id="обновления-1с-https-play-google-com-store-apps-details-id-com-fokusov-c1helperfree"><a href="https://play.google.com/store/apps/details?id=com.fokusov.c1helperfree">Обновления 1С</a></h2>

<p><img src="/pic03.png" alt="Обновления 1С" /></p>

<hr />

<h2 id="money-timer-https-play-google-com-store-apps-details-id-com-fokusov-moneytimer"><a href="https://play.google.com/store/apps/details?id=com.fokusov.MoneyTimer">Money Timer</a></h2>

<p><img src="/pic04.jpg" alt="Money timer" /></p>

<hr />

<h2 id="курсы-валют-https-play-google-com-store-apps-details-id-com-fokusov-currates"><a href="https://play.google.com/store/apps/details?id=com.fokusov.currates">Курсы валют</a></h2>

<p><img src="/pic05.png" alt="Курсы валют" /></p>

<hr />

<p>Я создаю приложения под андроид с помощью кроссплатформенного фреймворка <a href="https://www.nativescript.org">NativeScript</a> и иногда пишу о разработке в своем <a href="http://medium.com/@fokusov">блоге</a>. Обращайтесь, если вам понадобится недорогое качественное мобильное приложение :)</p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Выполненные проекты</turbo:topic>
      <link>https://fokusov.com/projects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ 

<p>Здесь перечислены некоторые проекты на базе 1С, завершённые мной за предыдущие годы:</p>

<h2 id="автоматизация-расчета-зарплаты-в-1с-7-7">Автоматизация расчета зарплаты в 1С 7.7</h2>

<p>Отрасль: Исправительное учреждение</p>

<p>Проблема: Стандартные зарплатные конфигурации 1С не были приспособлены для расчета зарплат некоторых категорий работников учреждения, из-за этого большая часть расчета проводилась вручную.</p>

<p>Решение: Доработка стандартных алгоритмов расчета в 1С ЗИК и помощников расчета в 1С Зарплата Камин 2 полностью решили проблему.</p>

<p>Результат: Снижена трудоемкость ведения учета в несколько раз, отсутствие ошибок в расчете, в т.ч. сложных начислений/удержаний и расчете налогов.</p>

<hr />

<h2 id="доработка-производственного-учета-в-1с">Доработка производственного учета в 1С</h2>

<p>Отрасль: Полиграфия</p>

<p>Проблема: У клиента самописная конфигурация для полиграфии на базе 1С Бухгалтерия 7.7, в которой требовались доработки согласно техзадания.</p>

<p>Решение: Добавлена подсистема учёта полиграфических заказов, расчёт себестоимости, стоимости, учёт загрузки печатных машин и пр. ресурсов. Создана дополнительная отчётность по менеджерам. Дописан блок управленческого учёта. Настроены обмены данными между десятком различных информационных баз предприятия. Совместная разработка системы Полиграфический заказ с ОАО Северсталь- разработка ПО для интеграции 1С и систем на базе Oracle.
Для 1с 8.х реализован учёт розничной торговли в сети киосков, учёт производства и продаж рекламы, доработана подсистема управленческого учёта. Дописан функционал по приёму и расчёту заказов рекламного агентства. Добавлена дополнительная отчётность: начисление процентов менеджерам, учёт взаиморасчётов по определенным критериям, различные реестры. Настроен специфический обмен данными между базами оперативного учёта и единой бухгалтерской базой.</p>

<p>Результат: Снижена трудоемкость ведения учета менеджеров, реализованы сложнейшие производственные механизмы работы предприятия.</p>

<hr />

<h2 id="проектирование-системы-на-базе-1с-ортикон-управление-нпф-8">Проектирование системы на базе 1С Ортикон: Управление НПФ 8</h2>

<p>Отрасль: НПФ</p>

<p>Проблема: Типовое решение не подходило под конкретную организацию, требовалась доработка нескольких подсистем.</p>

<p>Решение: Разработано детальное техзадание. Доработана система расчёта негосударственных пенсий согласно ТЗ.</p>

<hr />

<h2 id="доработка-обмена-данными-между-storehouse-и-1с-бп">Доработка обмена данными между Storehouse и 1С БП</h2>

<p>Отрасль: Ресторанный бизнес</p>

<p>Проблема: Стандартный обмен данными не учитывал специфику работы предприятия, из-за этого большая часть работы по выгрузке в бухгалтерию проводилась вручную.</p>

<p>Решение: Переписан по заданию Заказчика типовой обмен данными между системой складского учета Storehouse и 1С БП.</p>

<p>Результат: Снижена трудоемкость ведения учета.</p>

<hr />

<h2 id="доработка-1с-бгу">Доработка 1С БГУ</h2>

<p>Отрасль: Бюджетное учреждение</p>

<p>Проблема: Заказчику требовалась доработка типового решения на базе 1С: Бухгалтерия государственного учреждения для нужд казначейства.</p>

<p>Решение: Реализована подсистема распределения денежных средств по головным подразделениям учреждения, при этом стандартные механизмы практически не были затронуты.</p>

<p>Результат: Снижена трудоемкость ведения учета в несколько раз.</p>

<hr />

<h2 id="доработка-1с-унф">Доработка 1С УНФ</h2>

<p>Отрасль: Производство</p>

<p>Проблема: В стандартной конфигурации не была реализована система контроля за заказами, не хватало статусов у заказов, большинство этих работ велось вручную в комментариях к заказу или в тетрадке.</p>

<p>Решение: создание автоматической системы прохождения заказов по производственной цепочке, системы контроля за заказами. Добавлены интерфейсы для менеджеров. Созданы более гибкие статусы производственных заказов.</p>

<p>Результат: Снижена трудоемкость ведения учета менеджеров. Заказы перестали &ldquo;пропадать&rdquo; из цепочки, появился полный контроль за работой производства.</p>

<hr />

<h2 id="разработка-обменов-данными-в-1с-ка">Разработка обменов данными в 1С КА</h2>

<p>Отрасль: Алкогольный дистрибьютор</p>

<p>Проблема: При внедрении конфигурации 1С &ldquo;Комплексная автоматизация&rdquo; потребовалось создание обменов данными с крупнейшими поставщиками: Росспиртпромом, Эфесом, Балтикой, Кока-Колой и др.</p>

<p>Решение: Реализованы двусторонний обмен данными с Росспиртпром через веб-сервис поставщика; обмен данными с Эфес; автоматическая загрузка заказов от Кока-Кола; обмен данными с Алкон; доработан обмен данными с Балтикой; созданы отчеты в КИН согласно стандартам поставщика.</p>

<p>Результат: автоматизация работы предприятия с крупнейшими поставщиками. Обмены данными в реальном времени согласно требований поставщиков.</p>

<hr />

<h2 id="внедрение-1с-ут-11-и-доработка-обмена-данными-с-1с-битрикс">Внедрение 1С УТ 11 и доработка обмена данными с 1С Битрикс</h2>

<p>Отрасль: крупный интернет-магазин</p>

<p>Проблема: заказчику требовалось внедрение продукта 1С УТ 11 и перевод всех рабочих механизмов со старого битрикса. Также необходимо было доработать обмен данными с новым сайтом на актуальной версии 1С Битрикс.</p>

<p>Решение: Были загружены все данные со старой учетной системы (интернет-магазин с каталогом на несколько десятков тысяч наименований товаров, в т.ч. сборных товаров) в 1С УТ, доработан справочник Номенклатура (десятки дополнительных свойств и реквизитов), доработан обмен данными с сайтом (в стандартном обмене большинство доп. свойств выгружались некорректно + доработана автоматическая выгрузка больших каталогов товаров в pdf на сайт, привязанных в группе товаров).</p>

<p>Результат: снижение трудоемкости работы менеджеров интернет-магазина, успешно запущен новый интернет-магазин с автоматическим обменом товарами из 1С УТ.</p>

<hr />

<h2 id="доработка-самописной-системы-1с-упр-и-бюдж-учета-в-ут-11">Доработка самописной системы 1С, упр. и бюдж. учета в УТ 11</h2>

<p>Отрасль: Металлообработка</p>

<p>Проблема: Требовалась глубокая доработка самописной системы на базе 1С 8.1 для нужд металлообрабатывающей компании. Плюс к этому необходимо было закончить автоматизацию предприятия (бюджетного и управленческого учета) и перейти с MS Excel на 1С.</p>

<p>Решение: Самописная система по учету принимаемого лома, его обработке и продаже, доработана согласно ТЗ и внедрена в удаленных подразделениях компании. Разработаны обмены данными с центральной базой (дописанная УТ 11). В УТ 11 доработаны документы по учету принимаемого лома, отгрузке, продаже клиентам компании. Доработаны отчеты под требования заказчика. Работа компании переведена с повсеместного учета на базе сложнейших файлов MS Excel на продукты 1С. Настроены автоматически выгружаемые отчеты для поставщиков по сверкам расчетов на сайте компании.</p>

<p>Результат: снижена трудоемкость ведения учета практически всех участков компании. Настроены автоматические обмены с поставщиками. Повышена прозрачность учета в компании.</p>

<hr />

<h3 id="если-вы-пользуетесь-зарплатными-продуктами-фирмы-камин-обращайтесь-за-любыми-доработками-и-поддержкой">Если Вы пользуетесь зарплатными продуктами фирмы Камин, обращайтесь за любыми доработками и поддержкой!</h3>

<p>Оказываю услуги по поддержке работы систем 1С на абонентской основе. Звоните +7 921 548-6950</p>
 ]]></turbo:content>
    </item>
    
    <item turbo="true">
      <turbo:topic>Обо мне</turbo:topic>
      <link>https://fokusov.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>Игорь Фокусов</author>
      <turbo:content>&lt;![CDATA[ <p>Я занимаюсь разработкой ПО, в том числе на платформе 1С, более 15 лет.</p>

<p>Оказываю следующие услуги:</p>

<ul>
<li>Разработка на платформе 1C от 7.7 до 8.3</li>
<li>Проектирование и разработка конфигураций с нуля</li>
<li>Обновление типовых и доработанных конфигураций 1C</li>
<li>Настройка зарплатных конфигураций</li>
<li>Консультирование по работе в программе 1C</li>
<li>Разработка мобильных приложений на 1C</li>
<li>Разработка приложений под Android на Java/Kotlin</li>
</ul>
 ]]></turbo:content>
    </item>
    
  </channel>
</rss>
<!DOCTYPE html>
<html lang="ru">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Игорь Фокусов">
    <meta name="description" content="Услуги профессионального программиста 1с в Череповце. тел. &#43;7 921 548-69-50">
    <meta name="keywords" content="1с предприятие, услуги 1с, программист 1с, 1с8, 1с83, сопровождение 1с, поддержка 1с, программист череповец, 1с программист, 1с программист череповец, стоимость услуг 1с, специалист 1с, программист 1с удаленно">

    <base href="http://fokusov.com/">
    <title>
  Создание анимированной кнопки &#34;Поделиться&#34; в NativeScript &#43; Angular · Фокусов Игорь
</title>

    <link rel="canonical" href="http://fokusov.com/posts/sozdanie-animirovannoj-knopki-podelitsja-v-nativescript/">

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Merriweather:300,700|Source+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="http://fokusov.com/css/coder.min.578f8fce262e4c448c239b69661084c57507b89d51b8d04de15cd1d8f8135600.css" integrity="sha256-V4&#43;PziYuTESMI5tpZhCExXUHuJ1RuNBN4VzR2PgTVgA=" media="screen">
    

    

    

    <link rel="icon" type="image/png" href="http://fokusov.com/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="http://fokusov.com/images/favicon-16x16.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.49" />
  </head>

  <body class="">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="http://fokusov.com/">
      Фокусов Игорь
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="http://fokusov.com/about/">Обо мне</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="http://fokusov.com/projects/">1С</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="http://fokusov.com/android/">Android</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="http://fokusov.com/contacts/">Контакты</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="http://fokusov.com/posts/">Блог</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <h1 class="title">Создание анимированной кнопки &#34;Поделиться&#34; в NativeScript &#43; Angular</h1>
        <h2 class="date">January 26, 2017</h2>
      </header>

      <div>
        

<p><img src="img/xa50e2d15f9.png.pagespeed.ic.WH4jP8y-gH.png" alt="Разработка: main view" title="main view" /></p>

<p>Се­год­ня я по­ка­жу вам как со­зда­вать ани­ми­ро­ван­ную кноп­ку «По­де­лить­ся» в NativeScript и Angular. При на­жа­тии этой кноп­ки бу­дут по­ка­за­ны ма­лень­кие кноп­ки соц­се­тей по кру­гу от глав­ной.</p>

<p>Ис­ход­ный код при­ме­ра вы мо­же­те уви­деть на <a href="https://github.com/bdauria/tns-animated-social-share-button">Github</a>.</p>

<p>Итак, при­сту­пим!</p>

<h4 id="уста-нов-ка">Уста­нов­ка</h4>

<p>Со­зда­дим про­ект, ис­поль­зуя па­ра­метр &ndash;ng для со­зда­ния при­ло­же­ния angular:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">tns create --ng tns-animated-social-button</pre></div>
<p>В на­шем при­ло­же­нии бу­дет ис­поль­зо­вать­ся пла­гин ng2-fonticon от Nathan Walker для вы­во­да ико­нок на кноп­ках. Уста­но­ви­те его по ин­струк­ции на <a href="https://github.com/NathanWalker/nativescript-ng2-fonticon">этой стра­ни­це</a>.<br />
Та­к­же мы ис­поль­зу­ем па­кет <a href="https://lodash.com/">lodash</a>. Уста­но­вим его:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">npm install --save lodash
npm install --save @types/lodash</pre></div>
<p>Те­перь при­сту­пим к на­ше­му ко­ду.</p>

<h4 id="со-зда-ние-socialsharebuttoncomponent">Со­зда­ние SocialShareButtonComponent</h4>

<p>Яд­ро на­ше­го при­ло­же­ния бу­дет опи­са­но в ком­по­нен­те SocialShareButtonComponent. В шаб­лоне бу­дут глав­ная кноп­ка и несколь­ко кно­пок со­ци­аль­ных се­тей.<br />
При на­жа­тии на глав­ную кноп­ку вы­ез­жа­ют ма­лень­кие кноп­ки, а при по­втор­ном на­жа­тии они воз­вра­ща­ют­ся об­рат­но. Для кно­пок мы ис­поль­зу­ем икон­ку «круг» из font awesome. Ико­ноч­ные шриф­ты очень хо­ро­ши тем, что они оди­на­ко­во вы­гля­дят на лю­бом экране и раз­ре­ше­нии. При этом нуж­но пом­нить, что их раз­мер кон­тро­ли­ру­ет­ся па­ра­мет­ром font-size. Для то­го, что­бы сде­лать необ­хо­ди­мый раз­мер ком­по­нен­та, мы долж­ны вы­пол­нить неко­то­рые рас­чё­ты &mdash; это из-за то­го, что не все икон­ки в шриф­те име­ют оди­на­ко­вый раз­мер.<br />
На вход мы бу­дем при­ни­мать мас­сив на­име­но­ва­ний для ико­нок. И ис­поль­зо­вать его для со­зда­ния со­от­вет­ству­ю­щих кно­пок. На­име­но­ва­ния возь­мём из <a href="http://fontawesome.io/icons/">спис­ка ико­нок font awesome</a>. Те­перь, зная всё это, да­вай­те со­зда­дим ком­по­нент в но­вой пап­ке <strong>social-share-button</strong>:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/social-share-button/social-share-button.component.html

import {
  Component,
  Input
} from &#39;@angular/core&#39;;
import { TNSFontIconModule } from &#39;nativescript-ng2-fonticon&#39;;

@Component({
  selector: &#39;social-share-button&#39;,
  templateUrl: &#39;social-share-button/social-share-button.component.html&#39;,
  styleUrls: [&#39;social-share-button/social-share-button.component.css&#39;]
})
export class SocialShareButtonComponent {
  @Input(&#39;size&#39;) size = 75;
  @Input(&#39;shareIcons&#39;) shareIcons: string[];

  public get mainIconSize(): number {
    return this.size * 0.45;
  }

  public get shareButtonSize(): number {
    return this.size * 0.55;
  }

  public get shareIconSize(): number {
    return this.shareButtonSize * 0.5;
  }

  public get viewHeight(): number {
    return this.size + this.shareButtonSize * 1.2;
  }

  public get viewWidth(): number {
    return this.size + this.shareButtonSize * 2.2;
  }

  constructor(private fonticon: TNSFontIconModule) {}
}</pre></div>
<p>В пе­ре­мен­ной <strong>size</strong> мы бу­дем хра­нить расчи­тан­ный раз­мер под раз­ные раз­ре­ше­ния, уста­но­вим по-умол­ча­нию его в <strong>75</strong>. Она бу­дет от­ве­чать за па­ра­метр <strong>font-size</strong> глав­ной кноп­ки. Пе­ре­мен­ная <strong>mainIconSize</strong> это раз­мер икон­ки в глав­ной кноп­ке. Пе­ре­мен­ная <strong>shareButtonSize</strong> от­ве­ча­ет за раз­мер дру­гих кно­пок, а <strong>shareIconSize</strong>, за раз­мер икон­ки в них. Свой­ства <strong>viewHeight</strong> и <strong>viewWidth</strong> от­ве­ча­ют за внеш­ние раз­ме­ры все­го пред­став­ле­ния. Нам нуж­но до­ста­точ­но ме­ста для отоб­ра­же­ния глав­ной кноп­ки, а та­к­же всех осталь­ных ма­лых кно­пок. У нас бу­дет мак­си­мум од­на кноп­ка ря­дом с глав­ной, по­это­му вы­со­та ни­ко­гда не пре­вы­сит size + shareButtonSize. Что ка­са­ет­ся ши­ри­ны, у нас бу­дет по од­ной кноп­ке с каж­дой сто­ро­ны, а в ито­ге: size + shareButtonSize x 2. Мы ис­поль­зу­ем ко­эф­фи­ци­ен­ты в том чис­ле для то­го, что­бы бы­ло немно­го до­пол­ни­тель­но­го про­стран­ства.</p>

<p>Со­зда­дим та­кой шаб­лон:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app/component/social-share-button/social-share-button.component.html --&gt;

&lt;GridLayout rows=&#34;auto&#34;
  [style.width]=&#34;viewWidth&#34;
  [style.height]=&#34;viewHeight&#34;&gt;
  &lt;GridLayout #shareButton
    [style.width]=&#34;shareButtonSize&#34;
    *ngFor=&#34;let shareIcon of shareIcons&#34;&gt;
    &lt;Label
      [style.font-size]=&#34;shareButtonSize&#34;
      class=&#34;fa button&#34;
      [text]=&#34;&#39;fa-circle&#39; | fonticon&#34;&gt;
    &lt;/Label&gt;
    &lt;Label [style.font-size]=&#34;shareIconSize&#34;
      class=&#34;fa share-icon&#34;
      [text]=&#34;&#39;fa-&#39; + shareIcon | fonticon&#34;&gt;&lt;/Label&gt;
  &lt;/GridLayout&gt;
  &lt;GridLayout
    (tap)=&#34;onMainButtonTap()&#34;
    [style.width]=&#34;size&#34;&gt;
    &lt;Label #mainButton
      [style.font-size]=&#34;size&#34;
      class=&#34;fa button&#34;
      [text]=&#34;&#39;fa-circle&#39; | fonticon&#34;&gt;&lt;/Label&gt;
    &lt;Label [style.font-size]=&#34;mainIconSize&#34;
      class=&#34;fa share-icon&#34;
      [text]=&#34;&#39;fa-share-alt&#39; | fonticon&#34;&gt;&lt;/Label&gt;
  &lt;/GridLayout&gt;
&lt;/GridLayout&gt;</pre></div>
<p>Кноп­ки по­ме­ща­ют­ся в GridLayout та­ким об­ра­зом, что­бы икон­ки на­хо­ди­лись по­верх кру­гов. Всё со­дер­жи­мое в свою оче­редь, по­ме­ща­ет­ся в GridLayout, к ко­то­ро­му мы ди­на­ми­че­ски при­ме­ни­ли та­кие свой­ства, как вы­со­та и ши­ри­на.<br />
Для со­зда­ния кно­пок соц­се­тей мы про­хо­дим в цик­ле по мас­си­ву пе­ре­дан­ных ико­нок. Тек­стом икон­ки бу­дет кон­ка­те­на­ция &lsquo;fa-&rsquo; и зна­че­ния <strong>shareIcon</strong>.<br />
За­тем со­зда­дим со­от­вет­ству­ю­щую таб­ли­цу сти­лей:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">/* app/social-share-button/social-share-button.component.css */

GridLayout {
  text-align: center;
  vertical-align: center;
}

Label.button {
  color: #000;
}

Label.share-icon {
  color: #FFF;
  vertical-align: center;
}</pre></div>
<p>Здесь мы все­го лишь удо­сто­ве­рим­ся, что всё со­дер­жи­мое GridLayout от­цен­три­ро­ва­но и за­да­дим кое-ка­кие цве­та. Та­к­же сде­ла­ем, что­бы икон­ки бы­ли от­цен­три­ро­ва­ны по вер­ти­ка­ли внут­ри кноп­ки.</p>

<p>Пе­ред тем, как пе­рей­ти к ре­а­ли­за­ции, вы­ве­дем ре­зуль­тат в AppComponent. Сна­ча­ла до­ба­вим Component в спи­сок де­кла­ра­ций AppModule:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/app.module.ts

import { NgModule, NO_ERRORS_SCHEMA } from &#34;@angular/core&#34;;
import { NativeScriptModule } from &#34;nativescript-angular/platform&#34;;
import { SocialShareButtonComponent } from &#39;./social-share-button/social-share-button.component&#39;;
import { TNSFontIconModule } from &#39;nativescript-ng2-fonticon&#39;;
import { AppComponent } from &#34;./app.component&#34;;

@NgModule({
    declarations: [
      AppComponent,
      SocialShareButtonComponent
    ],
    bootstrap: [AppComponent],
    imports: [
      NativeScriptModule,
      TNSFontIconModule.forRoot({
        &#39;fa&#39;: &#39;font-awesome.css&#39;
      })
    ],
    schemas: [NO_ERRORS_SCHEMA]
})
export class AppModule { }</pre></div>
<p>За­тем от­кро­ем AppComponent и немно­го при­че­шем код:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/app.component.ts

import { Component } from &#34;@angular/core&#34;;

@Component({
  selector: &#34;my-app&#34;,
  templateUrl: &#34;app.component.html&#34;,
  styleUrls: [&#39;app.component.css&#39;]
})
export class AppComponent {
}</pre></div>
<p>Со­здай­те шаб­лон app.​com​pone​nt.​html и вставь­те в него сле­ду­ю­щее:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app/app.component.html --&gt;

&lt;StackLayout class=&#34;container&#34;&gt;
  &lt;social-share-button
    [shareIcons]=&#34;[&#39;facebook&#39;, &#39;twitter&#39;, &#39;github&#39;, &#39;linkedin&#39;, &#39;tumbler&#39;]&#34;&gt;&lt;/social-share-button&gt;
&lt;/StackLayout&gt;</pre></div>
<p>И файл CSS:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">/* app/app.component.css */

StackLayout.container {
  width: 100%;
  vertical-align: center;
  margin-left: auto;
  margin-right: auto;
}</pre></div>
<p>В ре­зуль­та­те долж­но по­лу­чить­ся та­кое:<br />
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALYAAACYCAAAAABsPUyeAAAEL0lEQVR42u3bS0hVQRgA4P/6CMVXei3xERphZZmPTEQIs6hFrQIxKdsUurGdFblpEy0qRQ0psIzeREFgaIuIXkRUZFliNzSNshIrwjRT8T6mhY9bOnM7c86cmXPp/1cX7v/7f8p17syZGSB+GYBsZCMb2chGNrKRjWxkIxvZyEY2spGNbGQjG9n/C/tuRW5ybFR4WERMYlrxaX9g/yiyw5wITb9uZXbvMhuwwl5jUXZ5MPiO1FHrsQts8O+wf7AWe5sWNABAnMs67AdBoD02W4WdAlwR9MYK7I5A4I0i9ewK0BHRqtkrQFcEDillx4LOsPUoZIeB/nisjB0FRqJbETsejMV3JeyNBtVgU8GuAcMRLZ/9DQTETunsIBFsaJPMLgYxIZfdL0gNJVLZEaLY8EUi+6IwNSRJZNu4ZLGtLtJRGMB496k0dhMPOm666gD9/QXS2DwLg63eMgc9o0sS+z6HOv7PwlvUlNWS2Gm6x2U7Nccthe3mUGf/XdpNTaqXwj7FwR6c3Y8W86WwUwx8d9OzXDLYIJx9SQL7Gcc6oE4be60E9kH9aDImaB6og53qQ5q45UjVyslvcVstpfaCOjYbnTn1r3UzgI4mLlblc4XsK96cOnppBqu0yXT2MKs1fWupP2nmsYJ7DfM33m06+xFrdkpL/pwAAFWjhBDiuePjfyLXdPY1RudeCjpxZvK6hGPCZQq7Uetg8ClB+wAfbDq7ViM7ycwFPD/7mKGvcWXsao2NM6zFrtfaeCTDSuwzjMZv56b+zJx6LzInL9mnOtR09g2eMWw4CwDKJ1+3zGOzU0xnt7NaN1LTh3J+Tb/05DDZhaazPcze3sm++yS9Np1Vuk/lDHDDyGRGsw2ggWsGeNV8tq9nO5F7qg9tmnp9nFJ7nlHXZz47X/OoVm+l1c0JjuFY41oyRAJ7QPzKfYd/PnC4J4O9Tv+OqUfQBo4e9m0O9qxlSxc1aZWcJ676PyX0SXirHDbP5l6ahvmMpOfbX3n+3KXeuif0jDJZmyCLedxpzqmq/YyEUVnsl3wrrrymV46W7cyZjLQtJ7JI3L4kDMlj94pT6zpcp3fzer0wtlsm2yVKfY7IZJOzYtTJRC6b5Ahhj8hme0Qc32kmstnknXF1KZHPNn6oZClRwSZ7FR2nM3pYtNSIOnRCFduIO8zItRCjB6F1f05inEQhm1zWp84y1tX4If8emw51JVHNJs7lvOgAB1HP5h7A843fGBJzXWg8Wzs6yCGgoajLWT3hGtUNQtqJuwr3Wsv1ClGXD0VePPxY4Nsc8lBYK8G3U9uZG2KBNYMC+4i/C/z+6MI5p49KOifENjHp5vVA14v6yrJdFYdbOvvGTPj5eGEc2chGNrKRjWxkIxvZyEY2spGNbGQjG9nIRjaykY1sZPsIt8vpj+zxMY8fsj0jw22/AQbHGYQmT15qAAAAAElFTkSuQmCC" alt="Разработка: preview" title="preview" /></p>

<h4 id="ани-ма-ция-кно-пок">Ани­ма­ция кно­пок</h4>

<p>Сей­час мы по­ра­бо­та­ет над ани­ма­ци­я­ми во­круг глав­ной кноп­ки. Спер­ва со­зда­дим свой­ство @ViewChildren() для по­лу­че­ния GridLayout-ов всех кно­пок:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">@ViewChildren(&#39;shareButton&#39;) shareButtonRefs: QueryList&lt;ElementRef&gt;;

  private get shareButtons(): Array&lt;GridLayout&gt; {
    return this.shareButtonRefs.map(s =&gt; s.nativeElement);
  }</pre></div>
<p>Мы хо­тим сде­лать двух­этап­ные ани­ма­ции. Сна­ча­ла кноп­ки соц­се­тей вы­ле­та­ют из-за глав­ной кноп­ки про­стым ли­ней­ным пе­ре­ме­ще­ни­ем. За­тем нам нуж­но сде­лать кое-что по­слож­нее &mdash; нам нуж­но, что­бы мел­кие кноп­ки вы­ле­та­ли по кру­гу от глав­ной. Фи­наль­ная по­зи­ция кноп­ки в кру­ге бу­дет за­ви­сеть от по­ло­же­ния дру­гих кно­пок или, дру­ги­ми сло­ва­ми, от её по­зи­ции в мас­си­ве shareButtons.<br />
Для со­зда­ния кру­го­во­го пе­ре­ме­ще­ния вспом­ним, как расчи­ты­ва­ют­ся ко­ор­ди­на­ты x, y от точ­ки по краю окруж­но­сти, в уг­ло­вой функ­ции:</p>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAM0AAABQCAAAAACfL64oAAAEy0lEQVR42u2bwZHjKhCGCUG1IRDAO5DAXhQCMRACMRBC3/fWIRADIRADKfzvgGwLBLLWeKsk1VA1MzXGePRJTdMaPgkszWpcqXk5TXKSsnxV5B9JyXQlmEjwEa5+eaG5GAwS4BC4TWME42ItWVBo0iQhzzId4tF3Oobz6xfoQeOEPcl0cIffKgFr67FiLNCIyH2Rxhx+Z9CAL9OwjZlmFuFDGAfw+gyNTT/vlinBn5yiaDKN+pRGRgDTRye3eWlyYp0T1Ccpdh6jSQIA1oPHaHIu0gxo/8nJCEM0efTE72mYcmg/DtIRcQIcswPgmBwBcQaAOAFQvj3uTdx3aJhNINP9jKXbCwCQ1KQhG5if89TS4xsAGAfMDtoDcQZTzkjBAICxAERsjttvbNo0DBgNm1/Vz0ZV9x5NSE4ivn639DqoKADEFCcAUJ7mBHiADQAI45wRzXHvkohu08TXtW5mj6W7iDSttdbyCR2hy4Ow8zNRcU4cpABAW8xCOSw0SQCwpjkOEL22ovndmDdi/zwsNUTayQIiVTTUoUmIJO2yfngFQIbmuHeRZnvrjVfAErvbSHt2y1hxr2hCWS2VkZYAxDABgGSXgKSWLBDmcln8i0jrZIFgoU1/KXx1k80raIvGmQqmygLJQzMQFJxbRipkLN0b9yZD+yaNNz4a7n7Eqtsx2U5pUiwZdaa1jhmAJbIAEbNLAHQCQGxjd9y/XD23bax6ZTqUuZYK0dlUVIqPyub312gG2/u7eW+NAgCKQDJFpfioOk9DEw5cHFY5qjL8q1KMhG9H2mjjeJBGOQB6XSk+79bOQ4Oj18aLOdpYV4pXpYEXgoGqtjrXvDlOE02YBd2FZgZAIt4j0oLNhUJVKV6ahnxVKV6PJlfec8p1VFkpXo0mWCkMAcnaXNkUleL1rs3bu64fmvPSSJFuRHOaLYJv0PBZtgi+QqOmdB8af72NtT5NnAi3oYnS4z40SdKNaJAmcyMaeOFuRAMt4o1ovDA3ooGY7kRzr6rz5/7mh+aHptHa3uBFaTre4EVpOt7gk+a/i82bpjf4pPkl/pxiPhwtsDbeIOh0kXZcHNx4g4+xYzRD6mBtYB8uFhveIPKu/BBNrQ7+3f8XKkFwWBzE4G5UrQ4OleLD4uAgzUYdHKIZFgcHI22jDh42B5kcBaUAr1RgZ/ANcbBLw+Syv9M5uNy7ke3WNIU6WLo/iyvoJQAvfRa4xsXBHk0IQQK0HEttdD1792gqdbDwshZXMMjH9Z35G+Jgb95EWIva/dv2riOtMgc36mBhAGZXMNNMAGb6hjjYzwJTzF/ttvRu1MFi3pT3s2sDcHEFS5pxcbA7b+K0/J1WpL16a3VwTVOqg0XILK5gSTMuDnZpgioveKe3VgfXIwp1sJzOiytY0oyLg/0MbZhkf2V/9lbq4BpgvWhUqTa7gmEWBmEWJlmh+KA42FXtVqtna71Ju/+VavcObWodEAd3VLtVZVPTpClBc59kr/fzduQxwJ5qt1t1OnZ+7/bC/YtdkuPi4Fa1i/S6I5jFKfZwDouDW9Vufbd2nYfw9lS7Bw1dZlN6T7XD6Z4pPJ4FtqrdcyW3Vwm1PdXuVZdcRRnYU+1wueek91S7NZm7wDPs+6od3j40dLH2Py3rrcGF9SMWAAAAAElFTkSuQmCC" alt="Разработка: Создание анимированной кнопки Поделиться в NativeScript" /><br />
где x0 и y0 это ко­ор­ди­на­ты на­ча­ла кру­га, r это его ра­ди­ус, а ϴ это угол.</p>

<p>Что­бы мы мог­ли уви­деть кру­го­вую ани­ма­цию, нель­зя про­сто пе­ре­ме­стить точ­ку по кру­гу. Это бы при­ве­ло к пе­ре­се­че­нию окруж­но­сти:<br />
<img src="img/x0505780f75.png.pagespeed.ic.aUPuRm9-k8.png" alt="Разработка: Создание анимированной кнопки Поделиться в NativeScript" /><br />
Вме­сто это­го нуж­но сде­лать несколь­ко по­сле­до­ва­тель­ных пе­ре­ме­ще­ний, ма­лы­ми ша­га­ми (ма­лень­кие ва­ри­а­ции ϴ):<br />
<img src="img/x66e7960a8c.png.pagespeed.ic.6yFZTab06D.png" alt="Разработка: Создание анимированной кнопки Поделиться в NativeScript" /><br />
Пе­ре­ве­дём те­перь это в код.</p>

<h4 id="ани-ми-ру-ем-ма-лые-кноп-ки-во-круг-глав-ной">Ани­ми­ру­ем ма­лые кноп­ки во­круг глав­ной</h4>

<p>От­сле­дим тап по глав­ной кноп­ке ме­то­дом onMainButtonTap() на­ше­го Component:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app/social-share-button/social-share-button.component.html --&gt;

[...]
  &lt;GridLayout
    (tap)=&#34;onMainButtonTap()&#34;
    [style.width]=&#34;size&#34;&gt;
[...]</pre></div>
<p>И со­от­вет­ству­ю­щий ме­тод в Component:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/social-share-button/social-share-button.component.ts

[...]
import { Animation } from &#39;ui/animation&#39;;
[...]
  constructor(private fonticon: TNSFontIconModule) {}

  public onMainButtonTap(): void {
    const animationDefinitions = this.shareButtons.map(button =&gt; {
      return {
        target: button,
        translate: { x: this.size * 0.8, y: 0 },
        duration: 200
      };
    });
    const animation = new Animation(animationDefinitions);
    animation.play();
  }
}</pre></div>
<p>Пе­ре­ме­ще­ние по оси x бу­дет рав­но зна­че­нию, пря­мо про­пор­ци­о­наль­но­му раз­ме­ру глав­ной кноп­ки. С это­го зна­че­ния и нач­нут­ся все вра­ще­ния. Ес­ли вер­нуть­ся к рас­че­там ко­ор­ди­нат, то это бу­дет ра­ди­у­сом, во­круг ко­то­ро­го мы вра­ща­ем кноп­ки. Зная всё это, со­зда­дим свой­ство-getter для по­лу­че­ния это­го зна­че­ния:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
  private get buttonRotationRadius(): number {
    return this.size * 0.8;
  }

[...]
  public onMainButtonTap(): void {
    const animationDefinitions = this.shareButtons.map(button =&gt; {
      return {
        target: button,
        translate: { x: this.buttonRotationRadius, y: 0 },
        duration: 200
      };
    });
    const animation = new Animation(animationDefinitions);
    animation.play();
  }
}</pre></div>
<p>От­сю­да угол ϴ ра­вен ну­лю. Те­перь пе­рей­дём к са­мо­му за­бав­но­му: вра­ще­нию кно­пок.</p>

<h4 id="кру-го-вые-пе-ре-ме-ще-ния-кно-пок">Кру­го­вые пе­ре­ме­ще­ния кно­пок</h4>

<p>Пе­ред тем, как мы про­дол­жим ре­а­ли­за­цию ме­то­да, да­вай­те по­ду­ма­ем о том, что нам нуж­но. Мы го­во­ри­ли, что хо­тим иметь воз­мож­ность пе­ре­ме­щать кноп­ки на неболь­шие уг­лы, или по­ша­го­во. Нам та­к­же нуж­но расчи­тать зна­че­ние мак­си­маль­но­го уг­ла пе­ре­ме­ще­ния каж­дой кноп­ки, в за­ви­си­мо­сти от её по­зи­ции в мас­си­ве. Сде­ла­ем по­ка толь­ко это и со­зда­дим два сле­ду­ю­щих ме­то­да:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
import { range } from &#39;lodash&#39;;
[...]

  private maxAngleFor(index: number): number {
    return index * 45;
  }

  private angleIntervals(maxAngle: number): Array&lt;number&gt; {
    const step = 5;
    return range(0, maxAngle + step, step);
  }
}</pre></div>
<p>Ме­тод maxAngleFor() на вхо­де при­ни­ма­ет index и воз­вра­ща­ет его, умно­жен­ным на 45. Это зна­чит, что каж­дая кноп­ка бу­дет от­де­ле­на чет­вер­тью кру­га &mdash; для сим­мет­рии.<br />
Ме­тод angleIntervals() при­ни­ма­ет maxAngle, и воз­вра­ща­ет мас­сив по­сле­до­ва­тель­ных зна­че­ний с ша­гом 5, в пре­де­лах maxAngle. Это бу­дут на­ши ша­ги вра­ще­ния.<br />
Та­к­же мы ре­а­ли­зу­ем ме­тод по­лу­че­ния ко­ор­ди­нат точ­ки, со­от­вет­ству­ю­щей зна­че­нию уг­ла:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
import { Animation, Pair } from &#39;ui/animation&#39;;
[...]
  private buttonCoordinatesFor(angle: number): Pair {
    const x = this.buttonRotationRadius * Math.cos(angle * Math.PI / 180);
    const y = this.buttonRotationRadius * Math.sin(angle * Math.PI / 180);

    return { x: x, y: y };
  }
}</pre></div>
<p>Те­перь важ­ная за­да­ча &mdash; сде­лать пе­ре­ме­ще­ния кно­пок с при­вяз­кой к ша­гу по окруж­но­сти. Од­но из ре­ше­ний для это­го &mdash; со­здать мас­сив из AnimationDefinition, как мы сде­ла­ли в преды­ду­щем раз­де­ле, и вы­зы­вать ани­ма­ции с фла­гом playSequentially. К со­жа­ле­нию, сде­лай мы так, это при­ве­ло бы к очист­ке пред­став­ле­ния по­сле каж­до­го ша­га ани­ма­ции, что нам аб­со­лют­но не нуж­но. Дру­гое ре­ше­ние &mdash; к каж­до­му ша­гу ани­ма­ции при­вя­зы­вать воз­вра­щён­ное зна­че­ние Promise че­рез ме­тод then(). Мы мо­жем сде­лать это с по­мо­щью ме­то­да reduce(), вы­зван­но­го по­сле ме­то­да angleIntervals(). Несколь­ко строк ко­да рас­ска­жут нам боль­ше ты­ся­чи слов:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
    animation.play().then(() =&gt; {
      this.shareButtons.forEach((button, index) =&gt; {
        const maxAngle = this.maxAngleFor(index);
          this.angleIntervals(maxAngle).reduce((accumulator, currentAngle, index) =&gt; {
            return accumulator.then(() =&gt; {
              return button.animate({
                translate: this.buttonCoordinatesFor(currentAngle),
                duration: 0.8
              });
            });
          }, Promise.resolve({}));
      });
[...]</pre></div>
<p>Для каж­дой кноп­ки мы по­лу­ча­ем со­от­вет­ству­ю­щее ей зна­че­ние maxAngle. И ис­поль­зу­ем его для рас­чё­та уг­ло­вых ша­гов, вы­зы­вая ме­тод reduce, свя­зы­вая вме­сте все Promise (мы на­ча­ли с ре­зуль­та­та пу­сто­го Promise). Про­дол­жи­тель­ность ани­ма­ции за­ни­ма­ет все­го 0.8 мс, так мы пе­ре­ме­ща­ем кноп­ку на со­от­вет­ству­ю­щие ко­ор­ди­на­ты для те­ку­ще­го уг­ла. На­пом­ню, что на­чи­на­ем мы с уг­ла, рав­но­го 0.</p>

<p>По­сле неболь­шо­го ре­фак­то­рин­га, это пре­вра­ща­ет­ся в:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
  public onMainButtonTap(): void {
    this.translateShareButtonsOutOfMainButton().then(() =&gt; {
      this.rotateShareButtonsAroundMainButton();
    });
  }

  private translateShareButtonsOutOfMainButton(): AnimationPromise {
    const animationDefinitions = this.shareButtons.map(button =&gt; {
      return {
        target: button,
        translate: { x: this.circularRotationRadius, y: 0 },
        duration: 200
      };
    });
    const animation = new Animation(animationDefinitions);
    return animation.play();
  }

  private rotateShareButtonsAroundMainButton(): void {
    this.shareButtons.forEach((button, index) =&gt; {
      this.rotateAroundMainButton(button, index);
    });
  }

  private rotateAroundMainButton(button: GridLayout, index: number): AnimationPromise {
    const maxAngle = this.maxAngleFor(index);
    return this.angleIntervals(maxAngle).reduce(
      this.getStepRotationAccumulatorFor(button),Promise.resolve()
    );
  }

  private getStepRotationAccumulatorFor(button: GridLayout) {
    return (accumulator, currentAngle, index) =&gt; {
      return accumulator.then(() =&gt; this.doStepRotation(button, currentAngle));
    }
  }

  private doStepRotation(button: GridLayout, angle: number): AnimationPromise {
    return button.animate({
      translate: this.buttonCoordinatesFor(angle),
      duration: 0.8
    });
  }
}</pre></div>
<h4 id="воз-врат-кно-пок-на-ме-сто">Воз­врат кно­пок на ме­сто</h4>

<p>Ко­гда кноп­ки по­ка­жут­ся, нам по­на­до­бит­ся спо­соб вер­нуть их на­зад, от­ку­да они вы­шли. Что­бы это сде­лать, нам по­на­до­бит­ся флаг shareButtonDisplayed, по­ка­зы­ва­ю­щий ви­ди­мость кно­пок:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
@Component({
  selector: &#39;social-share-button&#39;,
  templateUrl: &#39;social-share-button/social-share-button.component.html&#39;,
  styleUrls: [&#39;social-share-button/social-share-button.component.css&#39;]
})
export class SocialShareButtonComponent {

  private shareButtonDisplayed = false;
[...]</pre></div>
<p>Ани­ма­ция об­рат­но­го воз­вра­та кно­пок бу­дет очень по­хо­жа на translateShareButtonsOutOfMainButton(), по­это­му мы возь­мём со­дер­жи­мое ме­то­да, что­бы сде­лать его бо­лее уни­фи­ци­ро­ван­ным:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
  private translateShareButtonsOutOfMainButton(): AnimationPromise {
    return this.translateShareButtonsTo({
      x: this.circularRotationRadius,
      y: 0
    })
  }

  private translateShareButtonsTo(coordinates: Pair): AnimationPromise {
    const animationDefinitions = this.shareButtons.map(button =&gt; {
      return {
        target: button,
        translate: coordinates,
        duration: 200
      };
    });
    const animation = new Animation(animationDefinitions);
    return animation.play();
  }
[...]</pre></div>
<p>Что поз­во­лит нам на­пи­сать:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
  private translateShareButtonsBackInMainButton(): AnimationPromise {
    return this.translateShareButtonsTo({ x: 0, y: 0 });
  }
[...]</pre></div>
<p>И те­перь мы мо­жем пе­ре­пи­сать onMainButtonTap():</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
  public onMainButtonTap(): void {
    if (!this.shareButtonDisplayed) {
      this.translateShareButtonsOutOfMainButton().then(() =&gt; {
        this.rotateShareButtonsAroundMainButton();
      });
    }
    else {
      this.translateShareButtonsBackInMainButton();
    }
    this.shareButtonDisplayed = !this.shareButtonDisplayed;
  }
[...]</pre></div>
<p>Про­бле­ма те­ку­щей ре­а­ли­за­ции в том, что поль­зо­ва­тель мо­жет по­ло­мать на­шу ани­ма­цию. Что­бы это­го из­бе­жать, мы вве­дём пе­ре­мен­ную-пе­ре­чис­ле­ние State, по­ка­зы­ва­ю­щую со­сто­я­ние Component: ожи­да­ние, про­иг­ры­ва­ние или оста­нов­лен. Пе­ред этим необ­хо­ди­мо пе­ре­де­лать ме­тод rotateShareButtonsAroundMainButton() для воз­вра­та Promise. В этом ме­то­де мы хо­тим воз­вра­щать ре­зуль­тат Promise-ов всех ани­ма­ций, по­это­му мы долж­ны пой­мать мо­мент окон­ча­ния всей ани­ма­ции (оста­нов­лен). Из­ме­ним ме­тод сле­ду­ю­щим об­ра­зом:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
  private rotateShareButtonsAroundMainButton(): AnimationPromise {
    const animationPromises = this.shareButtons.map((button, index) =&gt; {
      return this.rotateAroundMainButton(button, index);
    });
    return &lt;AnimationPromise&gt;Promise.all(animationPromises);
  }
[...]</pre></div>
<p>Из­ме­ним флаг по со­сто­я­нию ани­ма­ции:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
enum AnimationState {
  idle,
  animating,
  settled
}

@Component({
  selector: &#39;social-share-button&#39;,
  templateUrl: &#39;social-share-button/social-share-button.component.html&#39;,
  styleUrls: [&#39;social-share-button/social-share-button.component.css&#39;]
})
export class SocialShareButtonComponent {

  private animationState = AnimationState.idle;
[...]</pre></div>
<p>И фи­наль­ная ре­а­ли­за­ция:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
  public onMainButtonTap(): void {
    if (this.animationState === AnimationState.idle) {
      this.translateShareButtonsOutOfMainButton().then(() =&gt; {
        this.animationState = AnimationState.animating;
        return this.rotateShareButtonsAroundMainButton();
      }).then(() =&gt; {
       this.animationState = AnimationState.settled;
      });
    }
    if (this.animationState === AnimationState.settled) {
      this.translateShareButtonsBackInMainButton().then(() =&gt; {
        this.animationState = AnimationState.idle;
      });
    }
  }
[...]</pre></div>
<p>К это­му мо­мен­ту вы уже долж­ны убе­дить­ся в кра­со­те Promise-ов в JavaScript.</p>

<h4 id="де-ла-ем-кноп-ки-на-стра-и-ва-е-мы-ми">Де­ла­ем кноп­ки на­стра­и­ва­е­мы­ми</h4>

<p>Сей­час на­ши чер­но-бе­лые кноп­ки вы­гля­дят очень скуч­но. Сде­ла­ем их на­стра­и­ва­е­мы­ми. До­ба­вим па­ру Input-ов (с неко­то­ры­ми зна­че­ни­я­ми по-умол­ча­нию):</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">[...]
  @Input(&#39;buttonColor&#39;) buttonColor = &#39;#CC0000&#39;;
  @Input(&#39;iconColor&#39;) iconColor = &#39;#FFFFFF&#39;;
[...]</pre></div>
<p>И при­вя­жем к шаб­ло­ну:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app/social-share-button/social-share-button.component.html --&gt;

&lt;GridLayout rows=&#34;auto&#34;
  [style.width]=&#34;viewWidth&#34;
  [style.height]=&#34;viewHeight&#34;&gt;
  &lt;GridLayout #shareButton
    [style.width]=&#34;shareButtonSize&#34;
    *ngFor=&#34;let shareIcon of shareIcons&#34;&gt;
    &lt;Label
      [style.color]=&#34;buttonColor&#34;
      [style.font-size]=&#34;shareButtonSize&#34;
      class=&#34;fa button&#34;
      [text]=&#34;&#39;fa-circle&#39; | fonticon&#34;&gt;
    &lt;/Label&gt;
    &lt;Label [style.font-size]=&#34;shareIconSize&#34;
      [style.color]=&#34;iconColor&#34;
      class=&#34;fa share-icon&#34;
      [text]=&#34;&#39;fa-&#39; + shareIcon | fonticon&#34;&gt;&lt;/Label&gt;
  &lt;/GridLayout&gt;
  &lt;GridLayout
    (tap)=&#34;onMainButtonTap()&#34;
    [style.width]=&#34;size&#34;&gt;
    &lt;Label
      [style.color]=&#34;buttonColor&#34;
      [style.font-size]=&#34;size&#34;
      class=&#34;fa button&#34;
      [text]=&#34;&#39;fa-circle&#39; | fonticon&#34;&gt;&lt;/Label&gt;
    &lt;Label [style.font-size]=&#34;mainIconSize&#34;
      [style.color]=&#34;iconColor&#34;
      class=&#34;fa share-icon&#34;
      [text]=&#34;&#39;fa-share-alt&#39; | fonticon&#34;&gt;&lt;/Label&gt;
  &lt;/GridLayout&gt;
&lt;/GridLayout&gt;</pre></div>
<p>А та­к­же мож­но немно­го под­со­кра­тить таб­ли­цу сти­лей:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">/* app/social-share-button/social-share-button.component.css */

GridLayout {
  text-align: center;
  vertical-align: center;
}

Label.share-icon {
  vertical-align: center;
}</pre></div>
<h4 id="до-ба-вим-эф-фект-те-ни-с-по-мо-щью-на-тив-но-го-ко-да">До­ба­вим эф­фект те­ни с по­мо­щью на­тив­но­го ко­да</h4>

<p>Немно­го улуч­шим стиль кноп­ки, до­ба­вив к ней тень. NativeScript по­ка не под­дер­жи­ва­ет по­каз те­ни в пред­став­ле­нии, по­это­му мы сде­ла­ем это на на­тив­ном ко­де, с по­мо­щью Directive, ко­то­рая мо­жет быть ре­а­ли­зо­ва­на и для iOS и для Android.<br />
Со­зда­дим но­вую пап­ку спе­ци­аль­но для ко­да на­шей Directive, на­зо­вём её label-shadow. Те­перь со­зда­дим аб­стракт­ную ба­зо­вую ди­рек­ти­ву, ко­то­рая бу­дет уна­сле­до­ва­на каж­дой плат­фор­мой:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/label-shadow/label-shadow-base.directive.ts

import { Directive, ElementRef } from &#39;@angular/core&#39;;
import { Label } from &#39;ui/label&#39;;
import { Observable } from &#39;data/observable&#39;;
import { Color } from &#39;color&#39;;

@Directive({
  selector: &#39;[shadow]&#39;
})

export abstract class LabelShadowBaseDirective {

  private get label(): Label {
    return this.el.nativeElement;
  }

  protected get shadowColor(): Color {
    return new Color(&#39;#888888&#39;);
  }

  protected get shadowOffset(): number {
    return 5.0;
  }

  constructor(protected el: ElementRef) {
    this.label.on(Observable.propertyChangeEvent, () =&gt; {
      if (this.label.text !== undefined) {
        this.displayShadowOn(this.label);
      }
    });
  }

  protected abstract displayShadowOn(label: Label);
}</pre></div>
<p>Нам нуж­но по­до­ждать, по­ка Label с пла­ги­ном FontIcon на­стро­ит­ся, по­это­му до­ба­вим хук &mdash; пе­ре­хват­чик со­бы­тия. По его го­тов­но­сти мы при­ме­ним аб­стракт­ный ме­тод displayShadowOn().</p>

<p>Пе­ред тем, как взять­ся за ре­а­ли­за­цию, со­зда­дим опи­са­ние ти­пов, ко­то­рое по­ка­жет TypeScript, что ди­рек­ти­ва здесь бу­дет во вре­мя ком­пи­ля­ции:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/label-shadow/label-shadow.directive.ts

import { Label } from &#39;ui/label&#39;;
import { LabelShadowBaseDirective } from &#39;./label-shadow-base.directive&#39;;

export declare class LabelShadowDirective extends LabelShadowBaseDirective {
  constructor(label: Label);
  protected displayShadowOn(label: Label);
}</pre></div>
<p>Со­зда­дим ре­а­ли­за­цию под Android:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/label/label-shadow.directive.android.ts

import { Directive, ElementRef } from &#39;@angular/core&#39;;
import { Label } from &#39;ui/label&#39;;
import { LabelShadowBaseDirective } from &#39;./label-shadow-base.directive&#39;;
import { Color } from &#39;color&#39;;

@Directive({
  selector: &#39;[shadow]&#39;
})
export class LabelShadowDirective extends LabelShadowBaseDirective {
  constructor(protected el: ElementRef) {
    super(el);
  }

  protected displayShadowOn(label: Label) {
    const nativeView = label.android;
    nativeView.setShadowLayer(
      10.0,
      this.shadowOffset,
      this.shadowOffset,
      this.shadowColor.android
    );
  }
}</pre></div>
<p>И для iOS:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/label-shadow/label-shadow.directive.ios.ts

import { Directive, ElementRef } from &#39;@angular/core&#39;;
import { Label } from &#39;ui/label&#39;;
import { Observable } from &#39;data/observable&#39;;
import { LabelShadowBaseDirective } from &#39;./label-shadow-base.directive&#39;;
import { Color } from &#39;color&#39;;

declare const CGSizeMake: any;

@Directive({
  selector: &#39;[shadow]&#39;
})
export abstract class LabelShadowDirective extends LabelShadowBaseDirective {

  constructor(protected el: ElementRef) {
    super(el);
  }

  protected displayShadowOn(label: Label) {
    const nativeView = label.ios;
    nativeView.layer.shadowColor = this.shadowColor.ios.CGColor;
    nativeView.layer.shadowOffset = CGSizeMake(this.shadowOffset, this.shadowOffset);
    nativeView.layer.shadowOpacity = 1.0;
    nativeView.layer.shadowRadius = 2.0;
  }
}</pre></div>
<p>За­тем до­ба­вим Directive в де­кла­ра­ции AppModule:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/app.module.ts

import { NgModule, NO_ERRORS_SCHEMA } from &#39;@angular/core&#39;;
import { NativeScriptModule } from &#39;nativescript-angular/platform&#39;;
import { SocialShareButtonComponent } from &#39;./social-share-button/social-share-button.component&#39;;
import { TNSFontIconModule } from &#39;nativescript-ng2-fonticon&#39;;
import { AppComponent } from &#39;./app.component&#39;;
import { LabelShadowDirective } from &#39;./label-shadow/label-shadow.directive&#39;;

@NgModule({
    declarations: [
      AppComponent,
      SocialShareButtonComponent,
      LabelShadowDirective
    ],
    bootstrap: [AppComponent],
    imports: [
      NativeScriptModule,
      TNSFontIconModule.forRoot({
        &#39;fa&#39;: &#39;font-awesome.css&#39;
      })
    ],
    schemas: [NO_ERRORS_SCHEMA]
})
export class AppModule { }</pre></div>
<p>Те­перь мы мо­жем до­ба­вить ди­рек­ти­ву в Label-ы FontIcon, пред­став­ля­ю­щие на­ши кноп­ки:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app/social-share-button/social-share-button.component.html --&gt;

[...]
    &lt;Label
      shadow
      [style.color]=&#34;buttonColor&#34;
      [style.font-size]=&#34;shareButtonSize&#34;
      class=&#34;fa button&#34;
      [text]=&#34;&#39;fa-circle&#39; | fonticon&#34;&gt;
    &lt;/Label&gt;
[...]
    &lt;Label
      shadow
      [style.color]=&#34;buttonColor&#34;
      [style.font-size]=&#34;size&#34;
      class=&#34;fa button&#34;
      [text]=&#34;&#39;fa-circle&#39; | fonticon&#34;&gt;&lt;/Label&gt;
[...]</pre></div>
<p>Пред­ста­вим Component в раз­ных раз­ме­рах и цве­тах. От­ре­дак­ти­ру­ем AppComponent:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/app.component.ts

import { Component } from &#34;@angular/core&#34;;

@Component({
  selector: &#34;my-app&#34;,
  templateUrl: &#34;app.component.html&#34;,
  styleUrls: [&#39;app.component.css&#39;]
})
export class AppComponent {
  public get shareIcons(): Array&lt;string&gt; {
    return [&#39;facebook&#39;, &#39;twitter&#39;, &#39;linkedin&#39;, &#39;github&#39;, &#39;tumblr&#39;];
  }
}</pre></div>
<p>И шаб­лон:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app/app.component.html --&gt;

&lt;StackLayout class=&#34;container&#34;&gt;
  &lt;social-share-button
    [shareIcons]=&#34;shareIcons&#34;
    [size]=&#34;100&#34;&gt;
  &lt;social-share-button
    [buttonColor]=&#34;&#39;#581845&#39;&#34;
    [shareIcons]=&#34;shareIcons&#34;
    [size]=&#34;80&#34;&gt;
  &lt;social-share-button
    [buttonColor]=&#34;&#39;#FFC300&#39;&#34;
    [iconColor]=&#34;&#39;#C70039&#39;&#34;
    [shareIcons]=&#34;shareIcons&#34;
    [size]=&#34;60&#34;&gt;
  &lt;social-share-button
    [buttonColor]=&#34;&#39;#99D5FF&#39;&#34;
    [iconColor]=&#34;&#39;#000000&#39;&#34;
    [shareIcons]=&#34;shareIcons&#34;
    [size]=&#34;40&#34;&gt;
&lt;/StackLayout&gt;</pre></div>
<p>Что даст нам:</p>

<p><img src="img/x92062e41b1.png.pagespeed.ic.oVK2Ku7sZe.png" alt="Разработка: Создание анимированной кнопки Поделиться в NativeScript" /></p>

<h4 id="ре-зуль-тат-на-жа-той-кноп-ки-по-де-лить-ся">Ре­зуль­тат на­жа­той кноп­ки «По­де­лить­ся»</h4>

<p>Кноп­ки уже вы­гля­дят хо­ро­шо, но они бес­по­лез­ны, по­то­му что ни­че­го не де­ла­ют. Вве­дём EventEmitter Output, ко­то­рый бу­дет по­ка­зы­вать имя икон­ки, ко­гда со­от­вет­ству­ю­щая кноп­ка бу­дет на­жа­та:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/social-share-button.component.ts

[...]
  @Output(&#39;shareButtonTap&#39;) shareButtonTap = new EventEmitter&lt;string&gt;();
[...]</pre></div>
<p>За­тем при­вя­жем хук к (tap) GridLayout-а кноп­ки на ме­тод onShareButton(), пе­ре­да­вая ему на­зва­ние икон­ки:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app/social-share-button/social-share-button.component.html --&gt;

[...]
  &lt;GridLayout #shareButton
    [style.width]=&#34;shareButtonSize&#34;
    *ngFor=&#34;let shareIcon of shareIcons&#34;
    (tap)=&#34;onShareButtonTap(shareIcon)&#34;&gt;
[...]</pre></div>
<p>Со­зда­дим со­от­вет­ству­ю­щий ме­тод, по­ка­зы­ва­ю­щий имя знач­ка, пе­ре­дав ему па­ра­мет­ром икон­ку:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/social-share-button/social-share-button.component.ts

[...]
  public onShareButtonTap(icon: string): void {
    this.shareButtonTap.emit(icon);
  }
[...]</pre></div>
<p>Это поз­во­ля­ет под­пи­сать­ся на со­бы­тие в AppComponent:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;!-- app/app.component.html --&gt;

[...]
  &lt;social-share-button
    [shareIcons]=&#34;shareIcons&#34;
    [size]=&#34;100&#34;
    (shareButtonTap)=&#34;onShareButtonTap($event)&#34;&gt;&lt;/social-share-button&gt;
[...]</pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/app.component.ts

import { Component } from &#34;@angular/core&#34;;
import * as dialogs from &#39;ui/dialogs&#39;;

@Component({
  selector: &#34;my-app&#34;,
  templateUrl: &#34;app.component.html&#34;,
  styleUrls: [&#39;app.component.css&#39;]
})
export class AppComponent {
  public get shareIcons(): Array&lt;string&gt; {
    return [&#39;facebook&#39;, &#39;twitter&#39;, &#39;linkedin&#39;, &#39;github&#39;, &#39;tumblr&#39;];
  }

  public onShareButtonTap(event: string): void {
    dialogs.alert(`share on: ${event}`);
  }
}</pre></div>
<h4 id="до-ба-вим-немно-го-про-ве-рок">До­ба­вим немно­го про­ве­рок</h4>

<p>В по­след­нем ша­ге до­ба­вим про­вер­ки, для то­го, что­бы предот­вра­тить некор­рект­ное ис­поль­зо­ва­ние Component-а.</p>

<p>Окро­ем ещё раз SocialShareButton, и сде­ла­ем так, что­бы он ре­а­ли­зо­вы­вал ин­тер­фейс OnInit:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/social-share-button/social-share-button.component.ts

import {
[...]
  OnInit
} from &#39;@angular/core&#39;;

[...]
export class SocialShareButtonComponent implements OnInit {
[...]</pre></div>
<p>за­тем ре­а­ли­зу­ем пе­ре­хват ngOnInit() с про­вер­ка­ми:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// app/social-share-button.component.ts

[...]
  public ngOnInit() {
    if (!this.shareIcons || this.shareIcons.length === 0) {
      throw new Error(&#39;you need to specify at least 1 icon&#39;);
    }
    if (this.shareIcons.length &gt; 5) {
      throw new Error(&#39;the list of icons cannot contain more than 5 elements&#39;);
    }
  }
[...]</pre></div>
<p>Наш Component те­перь го­тов!</p>

<p><a href="http://www.blog.bdauria.com/wp-content/uploads/2017/01/showcase.webm?_=1"><img src="http://www.blog.bdauria.com/wp-content/uploads/2017/01/showcase.webm?_=1" alt="video" /></a></p>

<p>Ес­ли вам по­нра­вил­ся этот ма­те­ри­ал, не за­будь­те по­де­лить­ся им с кол­ле­га­ми!</p>

<p><a href="http://www.blog.bdauria.com/?p=1021">Ис­точ­ник</a></p>

      </div>

      <footer>
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "fokusovcom" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </footer>
    </article>

    <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML-full">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$']],
        displayMath: [['$$','$$']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        TeX: { extensions: ["AMSmath.js", "AMSsymbols.js"] }
      }
    });
    MathJax.Hub.Queue(function() {
      
      
      
      var all = MathJax.Hub.getAllJax(), i;
      for(i = 0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
     © 2018    ·  Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>. 
  </section>
</footer>

    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-54274841-9', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
